[
    {
        "id": "5fb64aedc3e2bcf3",
        "type": "tab",
        "label": "Main",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3b19f9a67be11a89",
        "type": "tab",
        "label": "DB Populate",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b9028a431261c8bd",
        "type": "tab",
        "label": "Endpoints dev",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "46183d332de8b18f",
        "type": "tab",
        "label": "Endpoint Production",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "6279944e36da2c77",
        "type": "group",
        "z": "3b19f9a67be11a89",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "3c6319e9bc664095",
            "2f8e81c7042cd0c0",
            "0ec8938a41a5c613",
            "35197bad4cad825c",
            "f2db5c4946548328",
            "324b7e42861a2639",
            "0bf93ae942b542d0",
            "784043ca445a1ee6",
            "dc666437d3a050b6",
            "65497589c66a99f1",
            "422fe7665c60df65",
            "689bb04d901e1885",
            "e6f0fdbc5029be92",
            "991aaea937878ac1",
            "c2834d268bc206f9",
            "982e5d316445ea9a",
            "0f250da2f6d5dcc8",
            "0e7e93b3805270a9",
            "ea4fd56b73cc365a",
            "73916e792cf222c5",
            "4f3a84c21b396fdb",
            "70d2564cb9e099ff",
            "6c4501b6dddb5058",
            "8059a1c9e03af413",
            "1de127740bca8f35",
            "876275f32ebdbaea",
            "ee1370e4be40fc03",
            "d3bf55f43e15e822",
            "04eb5842da886500",
            "6063e3b8dbe13fc3",
            "b3863cf582695346",
            "b92ee793ce467c6d",
            "0477c28a2ed3f03e",
            "d52eff52c9843659",
            "aff5a1878dacfe62",
            "bfbea80e7382716d",
            "f9ab34152ad497f0",
            "7d79ba46b5bf61f7",
            "7754315b96fca4a3",
            "676d9d6efbeb3fba",
            "f571dca59479816d",
            "869d0eb71c849fdd"
        ],
        "x": 54,
        "y": 59,
        "w": 812,
        "h": 642
    },
    {
        "id": "41b667f64e4a22d7",
        "type": "group",
        "z": "b9028a431261c8bd",
        "name": "GET API",
        "style": {
            "label": true
        },
        "nodes": [
            "b33a88c809d7dfd4",
            "4064c40a44d53526",
            "db09ac97d896844f",
            "80864df0e24a0f23",
            "b2ab025f0662937f",
            "04d951a659feb84a",
            "98cbfac8213259b5",
            "7ac2b878b5e6dada",
            "0883d98739d01269",
            "d2ba316030500a68",
            "61133677afef0b39",
            "f39544220d8486be",
            "8a773f6151557090",
            "1b858089d3952c94",
            "8b185a9b70fd48a6",
            "bca9372ffa1b023c",
            "d59ee337f9ab37cb",
            "9627c1cf4a4705d7",
            "9cdb69be95b74456",
            "b79cca0ee4983469",
            "89f334513d8a7aed",
            "866bd3c2bcb204ef",
            "330c225a9b475ed1",
            "a00bb57686b43652",
            "288510282f69d5b1",
            "2ddb9dff9ac99ee6",
            "161a93311580789c",
            "3e70395521109352",
            "0931d21a7b4a4c80",
            "45ac30c0effd0152",
            "862eea9415dbd9f4",
            "a73cdf140457f4be",
            "de4b3a866a8e7494",
            "169c04a123d19263",
            "a2a1ada42ebcf374",
            "a2f27f11f0b1c6be",
            "bea632b38357d612",
            "6718453f8429033a",
            "e9b9294645378dfa",
            "88e91b3e8e0ed5bf",
            "70de676005121b16",
            "40af4e7cfc184a2e",
            "d261b8c9eb4eab4d",
            "9f49f384954a660c",
            "0dae4bc5b866ba78",
            "19621298ec0e60f2",
            "f33fc3082accd167",
            "15bdbe38cdbed656",
            "32237266132f9dd7",
            "8ca2368efbf7f6fc",
            "37e6357ee56f358d"
        ],
        "x": 54,
        "y": 19,
        "w": 1172,
        "h": 522
    },
    {
        "id": "e956e789109d8613",
        "type": "group",
        "z": "b9028a431261c8bd",
        "name": "POST API (CREATE)",
        "style": {
            "label": true
        },
        "nodes": [
            "b95d1e90260f7f3a",
            "40a89dc6e9cf1716",
            "9bc9b1182fbc0723",
            "63988b85e29c5d8d",
            "8f9abe643d6230e0",
            "be04b5ad297d726f",
            "0f9120d84b12ded0",
            "10ba5665c41039a6",
            "266d506455956098",
            "45015072c2e4f050",
            "29edd99d5611d6d4",
            "39eba60a795e2f1a",
            "2cb7d199c66116c3",
            "e55e2d06b698d4be",
            "1976e499c64fd5ac",
            "b7302009055a4662",
            "618e59aa269e2ee6",
            "5fe23c197a07d03d",
            "a6d6a440fb0fe680",
            "bd508f639bc54b5b",
            "88c2f4086108a3ba",
            "a57ba12f9544130b",
            "c24017ec7b7e7ef2",
            "8b8d6d6c6541565a",
            "f0e75a4f004d5f1f",
            "466ba6a8521b0173",
            "d7e438f2818583dc",
            "180ee19af01a8013",
            "2f9c6e2c722f0eca",
            "4bb0ebc71c4626ae",
            "3bc3ade665fd95a1",
            "1fe325820ebffb6f",
            "bbeb14bffbca71fb",
            "1807f2950052995e",
            "e0d0a4a9fb0e96ba",
            "5319907d595c741f",
            "bab4b2c89e96e7e2",
            "726dfa9ff66f9335",
            "1a972f172c4e19b2",
            "498da67479a8223b",
            "a2b8702f23e75ba1",
            "9ec3457ba543d418",
            "968b8efce82c5727",
            "ae7bc59d16d0fdaf",
            "285c4739dc7930ac"
        ],
        "x": 74,
        "y": 559,
        "w": 1132,
        "h": 402
    },
    {
        "id": "0a854dfffe5aa1e7",
        "type": "group",
        "z": "b9028a431261c8bd",
        "name": "POST API (UPDATE)",
        "style": {
            "label": true
        },
        "nodes": [
            "b44516ce4e0dcf5b",
            "1d4bab6811cbe5a6",
            "c9337d4167faf15f",
            "5e058ac9ef83cad6",
            "7a5534ae08bd0762",
            "688bf453afadcef3",
            "cdfc9b132e9e5e57",
            "08919acebc7bba71",
            "18de389cdca2cf80",
            "e170918e7f5dbc58",
            "99d665f0443c73d7",
            "d347cc3c685b9566",
            "79e74c69e3450b5a",
            "6f196ff5fc7fe4eb",
            "7c7cce005aa64951",
            "dec0e2d7c04d9be0",
            "3f64bebf8610ebf4",
            "8e2ef0315a96399e",
            "1dbbc1343366061c",
            "e056cbde63513d5e",
            "dc084f8c4a46667c",
            "f78c27419ea047a0",
            "d9fba55b92a15b0a",
            "85b3df574eb3ea5f",
            "5c7488c5b54210fa",
            "804d7591b1e06067",
            "9ad0e4463f21488f",
            "eb11da62e9f52618",
            "edd0a1ac31b4087e",
            "1dc9ba5674c471ce",
            "df7a4ee26b223100",
            "9a89cb5ef8db6c07",
            "173d7eea94be9a62",
            "283db352e4a59a69",
            "5ccdfdde1ca97c53",
            "d3226963e335a503",
            "c294c6107e202a98",
            "2d9879d148e475be",
            "c4deafec07e8c394",
            "b950eb01c040c9ef"
        ],
        "x": 1234,
        "y": 79,
        "w": 1092,
        "h": 362
    },
    {
        "id": "f2fcd8507fa996af",
        "type": "group",
        "z": "b9028a431261c8bd",
        "name": "POST API (DELETE)",
        "style": {
            "label": true
        },
        "nodes": [
            "2339173ac480ce8a",
            "936a97a69f991ef2",
            "dca361faf165c89e",
            "ac38a7f370289a70",
            "fd751ce4c28d9af5",
            "e91780233d69133f",
            "02e4a9849fc1cce0",
            "d2423d0ea8a95d93",
            "bb16c58c90f01267",
            "67fe2bd643ac2699",
            "e3c448a7cbb59b70",
            "b79be0ea0d27758c",
            "ba10d56d12e1b578",
            "9ef318e5bce73751",
            "a1348c1128b1869e",
            "c7eff8dab8a89e10",
            "0231068bedb8c4a5",
            "73060267c865188a",
            "2d9c5cb53d5128b6",
            "d02b0b8806e83641",
            "d04be732f33bd157",
            "4d598865f45dba95",
            "bb33aac87489b347",
            "f6a4089b673a0ac4",
            "ee08da16a0c3b673",
            "12d845eb17999df7",
            "59816f1d47d056c1",
            "dc00edbc1d6b60d6",
            "88569d79d47273ba",
            "dc8980003b75434a",
            "58a7773599e18b9f",
            "f20f15658ab659f4",
            "5050e6676e5fb3d0",
            "1a04ed24f6cc6744",
            "94277d28497a6667"
        ],
        "x": 1234,
        "y": 499,
        "w": 1092,
        "h": 322
    },
    {
        "id": "2ed4e9fed9718eaf",
        "type": "group",
        "z": "b9028a431261c8bd",
        "name": "GET API (SEARCH)",
        "style": {
            "label": true
        },
        "nodes": [
            "b4432e4647c01c2b",
            "29dd40b4d7e0107e",
            "897dbc479548c0f5",
            "52903accd4bc89dc",
            "91f156626870b43e",
            "7f986d88b2a40fe8",
            "e826f0647edf5a19",
            "36b458d5e01b5403",
            "2198b7da1905cdac",
            "0aff145959dd50bb",
            "b9c4e6f1aef3206c",
            "a4618a08f6727d63",
            "c4202d2dfae9348e",
            "7a70110d7f0dc399",
            "7f98e111c988c39d",
            "0acf9b908c1d63bd",
            "86bcfc5d027318c6",
            "594dae7fdb0a89b3",
            "77db71f819795db4",
            "4ee0681f5ff263de"
        ],
        "x": 74,
        "y": 999,
        "w": 1132,
        "h": 202
    },
    {
        "id": "a428cef3584244ff",
        "type": "group",
        "z": "46183d332de8b18f",
        "name": "Dashboard APIs",
        "style": {
            "label": true
        },
        "nodes": [
            "c9dd0bee078610dd",
            "11bbf920bc70be60",
            "5ee6e7e6112b7d57",
            "07a1f2e0af111f21",
            "090ebfb08a8ab273",
            "060cdca3bfae5f5b",
            "99cd3462bc22c5a8",
            "2cb72e179fa185f8",
            "bbe9b9eb9dd66dc6",
            "8d7268b919feebd5",
            "ad7bd9e2daa32fef",
            "fb3a0e2a0a704a0d",
            "1cb34f3ccb1d836b",
            "47f3cb2d817de769",
            "4440c61fceb80da0",
            "1ef57e1e3ad923f3",
            "89a8e8326f42fe01",
            "2654e3fc0cab17e1"
        ],
        "x": 34,
        "y": 99,
        "w": 732,
        "h": 342
    },
    {
        "id": "3b5fddf13427ab4a",
        "type": "group",
        "z": "46183d332de8b18f",
        "name": "Lab Workspace APIs",
        "style": {
            "label": true
        },
        "nodes": [
            "d351b04153bfba19",
            "b8c068dee7f01d2a",
            "8d198522e922ef0d"
        ],
        "x": 34,
        "y": 479,
        "w": 732,
        "h": 82
    },
    {
        "id": "4d1c4112eae14a37",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.001",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 110,
        "y": 60,
        "wires": [
            [
                "b893109eec9a9ab2"
            ]
        ]
    },
    {
        "id": "b893109eec9a9ab2",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "layer0",
        "func": "const { Pool } = global.get('pg');\n\n// DATABASE CLIENT\n// TODO: create client protocol\n\n// Create a new connection pool with the given configuration\nconst pool = new Pool({\n\tuser: env.get('PG_IRDOP_USER'), // USERNAME\n\thost: env.get('PG_IRDOP_HOST'), // HOST\n\tdatabase: env.get('PG_IRDOP_DB'), // DATABASE NAME\n\tpassword: env.get('PG_IRDOP_PW'), // PASSWORD\n\tport: env.get('PG_IRDOP_PORT'), // PORT\n});\n(async () => {\n\ttry {\n\t\t// Attempt to connect to the database\n\t\t// const client = await pool.connect();\n\t\t// Set the connected client in the global scope\n\t\tglobal.set('repoClient', pool);\n\t\t// Log a success message\n\t\tnode.warn('[ COMPLETED ] airdopDB connected');\n\t} catch (error) {\n\t\t// Log an error message if the connection fails\n\t\tnode.warn('[ ERROR ] airdopDB connection failed ' + error.message);\n\t\tconsole.error(error);\n\t}\n})();\n\n\nconst repoClient = global.get('repoClient'); // Postgres client\n\n// Retrieve the Postgres client from the global scope\n// const repoClient = global.get('repoClient');\n\n// CACHE MECHANISM\n// Initialize the cache object\nconst cache = {};\n// Set cache expiration time to 4 minutes\nconst cache_expiration = 4 * 60 * 1000; // 4 minutes\n// Set the cache object in the global scope\nglobal.set('cache',cache);\n\n// Initialize cache objects for different entities\ncache.receipts = {};\ncache.samples = {};\ncache.tests = {};\ncache.clients = {};\ncache.users = {};\ncache.testOrders = {};\ncache.receiptPrices = {};\ncache.protocols = {};\ncache.sampleReports = {};\ncache.sampleReportTests = {};\ncache.samplePrices = {};\ncache.libProtocols = {};\ncache.processingSamples = {};\n\n// TEST DATA\n// Add test data to the cache for receipts\ncache.receipts['123'] = {\n\tcached_at: new Date(),\n\tvalue: {\n\t\tid: 123,\n\t\treceipt_uid: 'TNM.123', // unique id\n\t\tclient_id: 123,\n\t},\n};\n\n// CRUD & CACHE FUNCTIONS\nasync function getReceipt(id) {\n\t/** Get a receipt from the cache or the database\n\t * @param {number} id - The id of the receipt to fetch\n\t * @returns {object} - The receipt object\n\t */\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t/** 1. Check cache */\n\t\t\tif (cache.receipts[id] && cache.receipts[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.receipts[id].value;\n\t\t\t} else delete cache.receipts[id];\n\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM receipts WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst receipt = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Receipt',\n\t\t\t\t};\n\t\t\t\tcache.receipts[id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: receipt,\n\t\t\t\t};\n\t\t\t\treturn cache.receipts[id].value;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid receipt id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getReceipt');\n\t}\n}\n\nasync function getSample(id) {\n\t/** Get a sample from the cache or the database\n\t * @param {number} id - The id of the sample to fetch\n\t * @returns {object} - The sample object\n\t */\n\n\ttry {\n\t\t/** 1. Validate id */\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tif (cache.samples[id] && cache.samples[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.samples[id].value;\n\t\t\t} else delete cache.samples[id];\n\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM samples WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst sample = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Sample',\n\t\t\t\t};\n\t\t\t\tcache.samples[id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: sample,\n\t\t\t\t};\n\t\t\t\treturn cache.samples[id].value;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid sample id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getSample');\n\t}\n}\n\nasync function getTest(id) {\n\t/** Get a test from the cache or the database\n\t * @param {number} id - The id of the test to fetch\n\t * @returns {object} - The test object\n\t */\n\ttry {\n\t\t/** 1. Validate id */\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tif (cache.tests[id] && cache.tests[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.tests[id].value;\n\t\t\t} else delete cache.tests[id];\n\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM tests WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst test = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Test',\n\t\t\t\t};\n\t\t\t\tcache.tests[test.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: test,\n\t\t\t\t};\n\t\t\t\treturn cache.tests[test.id].value;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid test id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getTest');\n\t}\n}\n\nasync function getClient(id) {\n\t/** Get a client from the cache or the database\n\t * @param {number} id - The id of the client to fetch\n\t * @returns {object} - The client object\n\t */\n\ttry {\n\t\t/** 1. Validate id */\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tif (cache.clients[id] && cache.clients[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.clients[id].value;\n\t\t\t} else delete cache.clients[id];\n\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM clients WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst client = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Client',\n\t\t\t\t};\n\t\t\t\tcache.clients[client.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: client,\n\t\t\t\t};\n\t\t\t\treturn cache.clients[client.id].value;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid client id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getClient');\n\t}\n}\n\nasync function getReceiptPrice(id) {\n\t/** Get a receipt price from the cache or the database\n\t * @param {number} id - The id of the receipt price to fetch\n\t * @returns {object} - The receipt price object\n\t */\n\ttry {\n\t\t/** 1. Validate id */\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tif (cache.receiptPrices[id] && cache.receiptPrices[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.receiptPrices[id].value;\n\t\t\t} else delete cache.receiptPrices[id];\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM receipt_prices WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst receiptPrice = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'ReceiptPrice',\n\t\t\t\t};\n\t\t\t\tcache.receiptPrices[receiptPrice.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: receiptPrice,\n\t\t\t\t};\n\t\t\t\treturn cache.receiptPrices[receiptPrice.id].value;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid receipt price id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getReceiptPrice');\n\t}\n}\n\nasync function getProtocol(id) {\n\t/** Get a protocol from the cache or the database\n\t * @param {number} id - The id of the protocol to fetch\n\t * @returns {object} - The protocol object\n\t */\n\ttry {\n\t\t/** 1. Validate id */\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tif (cache.protocols[id] && cache.protocols[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.protocols[id].value;\n\t\t\t} else delete cache.protocols[id];\n\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM lib_protocols WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst protocol = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Protocol',\n\t\t\t\t};\n\t\t\t\tcache.protocols[protocol.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: protocol,\n\t\t\t\t};\n\t\t\t\treturn cache.protocols[protocol.id].value;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid protocol id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getProtocol');\n\t}\n}\n\nasync function getTestOrder(id) {\n\t/** Get a test order from the cache or the database\n\t * @param {number} id - The id of the test order to fetch\n\t * @returns {object} - The test order object\n\t */\n\ttry {\n\t\t/** 1. Validate id */\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tif (cache.testOrders[id] && cache.testOrders[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.testOrders[id].value;\n\t\t\t} else delete cache.testOrders[id];\n\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM test_order WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst testOrder = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'TestOrder',\n\t\t\t\t};\n\t\t\t\tcache.testOrders[testOrder.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: testOrder,\n\t\t\t\t};\n\t\t\t\treturn cache.testOrders[testOrder.id].value;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid test order id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getTestOrder');\n\t}\n}\n\nasync function getSampleReport(id) {\n\t/** Get a sample report from the cache or the database\n\t * @param {number} id - The id of the sample report to fetch\n\t * @returns {object} - The sample report object\n\t */\n\ttry {\n\t\t/** 1. Validate id */\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tif (cache.sampleReports[id] && cache.sampleReports[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.sampleReports[id].value;\n\t\t\t} else delete cache.sampleReports[id];\n\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM sample_report WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst sampleReport = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SampleReport',\n\t\t\t\t};\n\t\t\t\tcache.sampleReports[sampleReport.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: sampleReport,\n\t\t\t\t};\n\t\t\t\treturn cache.sampleReports[sampleReport.id].value;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid sample report id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getSampleReport');\n\t}\n}\n\nasync function getSampleReportTest(id) {\n\t/** Get a sample report test from the cache or the database\n\t * @param {number} id - The id of the sample report test to fetch\n\t * @returns {object} - The sample report test object\n\t */\n\ttry {\n\t\t/** 1. Validate id */\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tif (cache.sampleReportTests[id] && cache.sampleReportTests[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.sampleReportTests[id].value;\n\t\t\t} else delete cache.sampleReportTests[id];\n\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM sample_report_tests WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst sampleReportTest = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SampleReportTest',\n\t\t\t\t};\n\t\t\t\tcache.sampleReportTests[sampleReportTest.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: sampleReportTest,\n\t\t\t\t};\n\t\t\t\treturn cache.sampleReportTests[sampleReportTest.id].value;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid sample report test id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getSampleReportTest');\n\t}\n}\n\nasync function getUser(id) {\n\t/** Get a user from the cache or the database\n\t * @param {number} id - The id of the user to fetch\n\t * @returns {object} - The user object\n\t */\n\ttry {\n\t\t/** 1. Validate id */\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tif (cache.users[id] && cache.users[id].cached_at > Date.now() - cache_expiration) {\n\t\t\t\treturn cache.users[id].value;\n\t\t\t} else delete cache.users[id];\n\n\t\t\t/** 2. Fetch from server */\n\t\t\tconst query = `SELECT * FROM users WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache and return */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst user = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'User',\n\t\t\t\t};\n\t\t\t\tcache.users[user.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: user,\n\t\t\t\t};\n\t\t\t\treturn cache.users[user.id].value;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid user id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getUser');\n\t}\n}\n\n// UPDATE FUNCTIONS\nasync function setReceipt(receipt) {\n\t/** Set a receipt in the cache\n\t * @param {object} receipt      - The receipt object to set\n\t * @param {number} receipt.id   - The id of the receipt to set\n\t * @returns {object}            - The receipt object\n\t */\n\ttry {\n\t\tif (typeof receipt === 'object' && receipt.id && Number.isInteger(receipt.id) && receipt.id > 0) {\n\t\t\t/** 1. Validate receipt */\n\t\t\tconst validColumns = await matchValidColumns('receipts', Object.keys(receipt));\n\t\t\tif (validColumns.length !== Object.keys(receipt).length) {\n\t\t\t\tthrow new Error(`Invalid receipt columns: ${Object.keys(receipt).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    UPDATE receipts\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [receipt.id, ...validColumns.map((column) => receipt[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updateReceipt = {\n\t\t\t\t\t...receipt,\n\t\t\t\t\tclassName: 'Receipt',\n\t\t\t\t};\n\t\t\t\tcache.receipts[updateReceipt.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: receipt,\n\t\t\t\t};\n\t\t\t\treturn cache.receipts[updateReceipt.id].value;\n\t\t\t}\n\t\t\tthrow new Error(`Failed to set receipt: ${receipt}`);\n\t\t}\n\t\tthrow new Error(`Invalid receipt: ${receipt}`);\n\t} catch (error) {\n\t\thandleError(error, 'setReceipt');\n\t}\n}\n\nasync function setSample(sample) {\n\t/** Set a sample in the cache\n\t * @param {object} sample      - The sample object to set\n\t * @param {number} sample.id   - The id of the sample to set\n\t * @returns {object}           - The sample object\n\t */\n\ttry {\n\t\tif (typeof sample === 'object' && sample.id && Number.isInteger(sample.id) && sample.id > 0) {\n\t\t\t/** 1. Validate sample */\n\t\t\tconst validColumns = await matchValidColumns('samples', Object.keys(sample));\n\t\t\tif (validColumns.length !== Object.keys(sample).length) {\n\t\t\t\tthrow new Error(`Invalid sample columns: ${Object.keys(sample).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    UPDATE samples\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [sample.id, ...validColumns.map((column) => sample[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedSample = {\n\t\t\t\t\t...sample,\n\t\t\t\t\tclassName: 'Sample',\n\t\t\t\t};\n\t\t\t\tcache.samples[updatedSample.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: updatedSample,\n\t\t\t\t};\n\t\t\t\treturn cache.samples[updatedSample.id].value;\n\t\t\t}\n\t\t\tthrow new Error(`Failed to set sample: ${sample}`);\n\t\t}\n\t\tthrow new Error(`Invalid sample: ${sample}`);\n\t} catch (error) {\n\t\thandleError(error, 'setSample');\n\t}\n}\n\nasync function setTest(test) {\n\t/** Set a test in the cache\n\t * @param {object} test      - The test object to set\n\t * @param {number} test.id   - The id of the test to set\n\t * @returns {object}         - The test object\n\t */\n\ttry {\n\t\tif (typeof test === 'object' && test.id && Number.isInteger(test.id) && test.id > 0) {\n\t\t\t/** 1. Validate test */\n\t\t\tconst validColumns = await matchValidColumns('tests', Object.keys(test));\n\t\t\tif (validColumns.length !== Object.keys(test).length) {\n\t\t\t\tthrow new Error(`Invalid test columns: ${Object.keys(test).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    UPDATE tests\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [test.id, ...validColumns.map((column) => test[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedTest = {\n\t\t\t\t\t...test,\n\t\t\t\t\tclassName: 'Test',\n\t\t\t\t};\n\t\t\t\tcache.tests[updatedTest.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: updatedTest,\n\t\t\t\t};\n\t\t\t\treturn cache.tests[updatedTest.id].value;\n\t\t\t}\n\t\t\tthrow new Error(`Failed to set test: ${test}`);\n\t\t}\n\t\tthrow new Error(`Invalid test: ${test}`);\n\t} catch (error) {\n\t\thandleError(error, 'setTest');\n\t}\n}\n\nasync function setClient(client) {\n\t/** Set a client in the cache\n\t * @param {object} client      - The client object to set\n\t * @param {number} client.id   - The id of the client to set\n\t * @returns {object}           - The client object\n\t */\n\ttry {\n\t\tif (typeof client === 'object' && client.id && Number.isInteger(client.id) && client.id > 0) {\n\t\t\t/** 1. Validate client */\n\t\t\tconst validColumns = await matchValidColumns('clients', Object.keys(client));\n\t\t\tif (validColumns.length !== Object.keys(client).length) {\n\t\t\t\tthrow new Error(`Invalid client columns: ${Object.keys(client).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    UPDATE clients\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [client.id, ...validColumns.map((column) => client[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedClient = {\n\t\t\t\t\t...client,\n\t\t\t\t\tclassName: 'Client',\n\t\t\t\t};\n\t\t\t\tcache.clients[updatedClient.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: updatedClient,\n\t\t\t\t};\n\t\t\t\treturn cache.clients[updatedClient.id].value;\n\t\t\t}\n\t\t\tthrow new Error(`Failed to set client: ${client}`);\n\t\t}\n\t\tthrow new Error(`Invalid client: ${client}`);\n\t} catch (error) {\n\t\thandleError(error, 'setClient');\n\t}\n}\n\nasync function setTestOrder(testOrder) {\n\t/** Set a test order in the cache\n\t * @param {object} testOrder      - The test order object to set\n\t * @param {number} testOrder.id   - The id of the test order to set\n\t * @returns {object}              - The test order object\n\t */\n\ttry {\n\t\tif (typeof testOrder === 'object' && testOrder.id && Number.isInteger(testOrder.id) && testOrder.id > 0) {\n\t\t\t/** 1. Validate test order */\n\t\t\tconst validColumns = await matchValidColumns('test_order', Object.keys(testOrder));\n\t\t\tif (validColumns.length !== Object.keys(testOrder).length) {\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(testOrder).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    UPDATE test_order\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [testOrder.id, ...validColumns.map((column) => testOrder[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedTestOrder = {\n\t\t\t\t\t...testOrder,\n\t\t\t\t\tclassName: 'TestOrder',\n\t\t\t\t};\n\t\t\t\tcache.testOrders[updatedTestOrder.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: updatedTestOrder,\n\t\t\t\t};\n\t\t\t\treturn cache.testOrders[updatedTestOrder.id].value;\n\t\t\t}\n\t\t\tthrow new Error(`Failed to set test order: ${testOrder}`);\n\t\t}\n\t\tthrow new Error(`Invalid test order: ${testOrder}`);\n\t} catch (error) {\n\t\thandleError(error, 'setTestOrder');\n\t}\n}\n\nasync function setProtocol(protocol) {\n\t/** Set a protocol in the cache\n\t * @param {object} protocol      - The protocol object to set\n\t * @param {number} protocol.id   - The id of the protocol to set\n\t * @returns {object}             - The protocol object\n\t */\n\ttry {\n\t\tif (typeof protocol === 'object' && protocol.id && Number.isInteger(protocol.id) && protocol.id > 0) {\n\t\t\t/** 1. Validate protocol */\n\t\t\tconst validColumns = await matchValidColumns('lib_protocols', Object.keys(protocol));\n\t\t\tif (validColumns.length !== Object.keys(protocol).length) {\n\t\t\t\tthrow new Error(`Invalid protocol columns: ${Object.keys(protocol).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    UPDATE lib_protocols\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [protocol.id, ...validColumns.map((column) => protocol[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedProtocol = {\n\t\t\t\t\t...protocol,\n\t\t\t\t\tclassName: 'Protocol',\n\t\t\t\t};\n\t\t\t\tcache.protocols[updatedProtocol.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: updatedProtocol,\n\t\t\t\t};\n\t\t\t\treturn cache.protocols[updatedProtocol.id].value;\n\t\t\t}\n\t\t\tthrow new Error(`Failed to set protocol: ${protocol}`);\n\t\t}\n\t\tthrow new Error(`Invalid protocol: ${protocol}`);\n\t} catch (error) {\n\t\thandleError(error, 'setProtocol');\n\t}\n}\n\nasync function setReceiptPrice(receiptPrice) {\n\t/** Set a receipt price in the cache\n\t * @param {object} receiptPrice      - The receipt price object to set\n\t * @param {number} receiptPrice.id   - The id of the receipt price to set\n\t * @returns {object}                 - The receipt price object\n\t */\n\ttry {\n\t\tif (\n\t\t\ttypeof receiptPrice === 'object' &&\n\t\t\treceiptPrice.id &&\n\t\t\tNumber.isInteger(receiptPrice.id) &&\n\t\t\treceiptPrice.id > 0\n\t\t) {\n\t\t\t/** 1. Validate receipt price */\n\t\t\tconst validColumns = await matchValidColumns('receipt_prices', Object.keys(receiptPrice));\n\t\t\tif (validColumns.length !== Object.keys(receiptPrice).length) {\n\t\t\t\tthrow new Error(`Invalid receipt price columns: ${Object.keys(receiptPrice).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    UPDATE receipt_prices\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\n\t\t\tconst params = [receiptPrice.id, ...validColumns.map((column) => receiptPrice[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedReceiptPrice = {\n\t\t\t\t\t...receiptPrice,\n\t\t\t\t\tclassName: 'ReceiptPrice',\n\t\t\t\t};\n\t\t\t\tcache.receiptPrices[updatedReceiptPrice.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: updatedReceiptPrice,\n\t\t\t\t};\n\t\t\t\treturn cache.receiptPrices[updatedReceiptPrice.id].value;\n\t\t\t}\n\t\t\tthrow new Error(`Failed to set receipt price: ${receiptPrice}`);\n\t\t}\n\t\tthrow new Error(`Invalid receipt price: ${receiptPrice}`);\n\t} catch (error) {\n\t\thandleError(error, 'setReceiptPrice');\n\t}\n}\n\nasync function setSampleReport(sampleReport) {\n\t/** Set a sample report in the cache\n\t * @param {object} sampleReport      - The sample report object to set\n\t * @param {number} sampleReport.id   - The id of the sample report to set\n\t * @returns {object}                 - The sample report object\n\t */\n\ttry {\n\t\tif (\n\t\t\ttypeof sampleReport === 'object' &&\n\t\t\tsampleReport.id &&\n\t\t\tNumber.isInteger(sampleReport.id) &&\n\t\t\tsampleReport.id > 0\n\t\t) {\n\t\t\t/** 1. Validate sample report */\n\t\t\tconst validColumns = await matchValidColumns('sample_report', Object.keys(sampleReport));\n\t\t\tif (validColumns.length !== Object.keys(sampleReport).length) {\n\t\t\t\tthrow new Error(`Invalid sample report columns: ${Object.keys(sampleReport).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    UPDATE sample_report\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [sampleReport.id, ...validColumns.map((column) => sampleReport[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedSampleReport = {\n\t\t\t\t\t...sampleReport,\n\t\t\t\t\tclassName: 'SampleReport',\n\t\t\t\t};\n\t\t\t\tcache.sampleReports[updatedSampleReport.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: updatedSampleReport,\n\t\t\t\t};\n\t\t\t\treturn cache.sampleReports[updatedSampleReport.id].value;\n\t\t\t}\n\t\t\tthrow new Error(`Failed to set sample report: ${sampleReport}`);\n\t\t}\n\t\tthrow new Error(`Invalid sample report: ${sampleReport}`);\n\t} catch (error) {\n\t\thandleError(error, 'setSampleReport');\n\t}\n}\n\nasync function setSampleReportTest(sampleReportTest) {\n\t/** Set a sample report test in the cache\n\t * @param {object} sampleReportTest      - The sample report test object to set\n\t * @param {number} sampleReportTest.id   - The id of the sample report test to set\n\t * @returns {object}                     - The sample report test object\n\t */\n\ttry {\n\t\t// Check if the sampleReportTest is a valid object and has a valid id\n\t\tif (\n\t\t\ttypeof sampleReportTest === 'object' &&\n\t\t\tsampleReportTest.id &&\n\t\t\tNumber.isInteger(sampleReportTest.id) &&\n\t\t\tsampleReportTest.id > 0\n\t\t) {\n\t\t\t/** 1. Validate sample report test */\n\t\t\t// Validate the columns of the sampleReportTest object against the database schema\n\t\t\tconst validColumns = await matchValidColumns('sample_report_tests', Object.keys(sampleReportTest));\n\t\t\tif (validColumns.length !== Object.keys(sampleReportTest).length) {\n\t\t\t\t// Throw an error if there are invalid columns\n\t\t\t\tthrow new Error(`Invalid sample report test columns: ${Object.keys(sampleReportTest).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\t// Construct the SQL query to update the sample_report_tests table\n\t\t\tconst query = `\n                    UPDATE sample_report_tests\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\t// Prepare the parameters for the SQL query\n\t\t\tconst params = [sampleReportTest.id, ...validColumns.map((column) => sampleReportTest[column])];\n\t\t\t// Execute the SQL query to update the sample_report_tests table\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\t// Check if the update was successful\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\t// Create an updated sample report test object\n\t\t\t\tconst updatedSampleReportTest = {\n\t\t\t\t\t...sampleReportTest,\n\t\t\t\t\tclassName: 'SampleReportTest',\n\t\t\t\t};\n\t\t\t\t// Update the cache with the updated sample report test object\n\t\t\t\tcache.sampleReportTests[updatedSampleReportTest.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: updatedSampleReportTest,\n\t\t\t\t};\n\t\t\t\t// Return the updated sample report test object from the cache\n\t\t\t\treturn cache.sampleReportTests[updatedSampleReportTest.id].value;\n\t\t\t}\n\t\t\t// Throw an error if the update failed\n\t\t\tthrow new Error(`Failed to set sample report test: ${sampleReportTest.id}`);\n\t\t} else {\n\t\t\t// Throw an error if the sampleReportTest object is invalid\n\t\t\tthrow new Error('Invalid sample report test object');\n\t\t}\n\t} catch (error) {\n\t\t// Handle any errors that occur during the operation\n\t\tconsole.error(error);\n\t\tthrow error;\n\t}\n}\n\n// DELETE FUNCTIONS\nasync function delReceipt(id) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM receipts WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tdelete cache.receipts[id];\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid receipt id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delReceipt');\n\t}\n}\n\nasync function delSample(id) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM samples WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tdelete cache.samples[id];\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid sample id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delSample');\n\t}\n}\n\nasync function delTest(id) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM tests WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tdelete cache.tests[id];\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid test id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delTest');\n\t}\n}\n\nasync function delClient(id) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM clients WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tdelete cache.clients[id];\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid client id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delClient');\n\t}\n}\n\nasync function delTestOrder(id) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM test_order WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tdelete cache.testOrders[id];\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid test order id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delTestOrder');\n\t}\n}\n\nasync function delProtocol(id) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM lib_protocols WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tdelete cache.libProtocols[id];\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid protocol id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delProtocol');\n\t}\n}\n\nasync function delReceiptPrice(id) {\n\ttry {\n\t\t// Check if the id is valid\n\t\tif (!id || !Number.isInteger(id) || id <= 0) {\n\t\t\tthrow new Error(`Invalid receipt price id: ${id}`);\n\t\t}\n\n\t\t// Construct the SQL query to delete the receipt price\n\t\tconst query = `DELETE FROM receipt_prices WHERE id = $1`;\n\t\tconst params = [id];\n\n\t\t// Execute the SQL query\n\t\tconst result = await repoClient.query(query, params);\n\n\t\t// Check if the deletion was successful\n\t\tif (result.rowCount === 0) {\n\t\t\tthrow new Error(`Receipt price with id ${id} not found`);\n\t\t}\n\n\t\t// Return a success message\n\t\treturn { message: `Receipt price with id ${id} deleted successfully` };\n\t} catch (error) {\n\t\t// Handle any errors that occur during the operation\n\t\thandleError(error, 'delReceiptPrice');\n\t}\n}\n\n// MATCH FUNCTIONS\nasync function matchValidColumns(table_name, columns) {\n\ttry {\n\t\t/** 1. Get table columns from server */\n\t\t// Construct the SQL query to get the column names from the information schema\n\t\tconst validColumnsQuery = `SELECT column_name FROM information_schema.columns WHERE table_name = $1`;\n\t\tconst validColumnsParams = [table_name];\n\n\t\t// Execute the SQL query\n\t\tconst validColumnsResult = await repoClient.query(validColumnsQuery, validColumnsParams);\n\n\t\t// Extract the column names from the query result\n\t\tconst validColumns = validColumnsResult.rows.map((row) => row.column_name);\n\n\t\t/** 2. Match columns */\n\t\t// Filter the input columns to include only valid columns\n\t\tconst matchedColumns = columns.filter((column) => validColumns.includes(column));\n\n\t\t// Return the matched columns\n\t\treturn matchedColumns; // if no match return []\n\t} catch (error) {\n\t\t// Handle any errors that occur during the operation\n\t\thandleError(error, 'matchValidColumns');\n\t}\n}\n\n//ADD FUNCTIONS\nasync function newReceipt(receipt) {\n\t/**\n\t * @param {Object} receipt\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\t// Validate the receipt object\n\t\tif (validateReceipt(receipt)) {\n\t\t\t// Generate a new UID if it doesn't already exist\n\t\t\tif (!receipt.receipt_uid) receipt.receipt_uid = await getNextUID();\n\n\t\t\t/** 1. Validate receipt columns */\n\t\t\t// Validate the columns of the receipt object against the database schema\n\t\t\tconst validColumns = await matchValidColumns('receipts', Object.keys(receipt));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid receipt columns: ${Object.keys(receipt).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\t// Construct the SQL query to insert the receipt into the database\n\t\t\tconst query = `\n                    INSERT INTO receipts (${validColumns.join(',')}) \n                    VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                    RETURNING *`;\n\t\t\t// Prepare the parameters for the SQL query\n\t\t\tconst params = validColumns.map((column) => receipt[column]);\n\n\t\t\t// Execute the SQL query\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Return the newly created receipt\n\t\t\treturn result.rows[0];\n\t\t} else {\n\t\t\t// Throw an error if the receipt object is invalid\n\t\t\tthrow new Error('Invalid receipt object');\n\t\t}\n\t} catch (error) {\n\t\t// Handle any errors that occur during the operation\n\t\thandleError(error, 'newReceipt');\n\t}\n\n\tfunction validateReceipt(receipt) {\n\t\t// Check if the receipt object is valid\n\t\tif (typeof receipt === 'object' && Object.keys(receipt).length > 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync function getNextUID() {\n\t\t// Get the current date\n\t\tconst currentDate = new Date();\n\t\tconst currentYear = currentDate.getFullYear().toString().slice(-2);\n\t\tconst currentWeek = String(\n\t\t\tMath.floor(\n\t\t\t\t(currentDate.getTime() - new Date(currentDate.getFullYear(), 0, 1).getTime()) / (1000 * 60 * 60 * 24 * 7),\n\t\t\t) + 1,\n\t\t).padStart(2, '0');\n\t\tconst currentDay = String(currentDate.getDate()).padStart(2, '0');\n\n\t\t// Get the last receipt UID from the database\n\t\tconst query = `SELECT receipt_uid FROM receipts ORDER BY id DESC LIMIT 1`;\n\t\tconst result = await repoClient.query(query);\n\t\tconst lastUID = result.rows[0].receipt_uid || 'PPT.YYWWDD-01';\n\t\tconst nextIndex =\n\t\t\tlastUID.slice(8, 10) !== currentWeek ? '01' : String(Number(lastUID.slice(11)) + 1).padStart(2, '0');\n\t\tconst nextReceiptUID = `PPT.${currentYear}${currentWeek}${currentDay}-${nextIndex}`;\n\n\t\t// Return the next receipt UID\n\t\treturn nextReceiptUID;\n\t}\n}\n\nasync function newSample(sample) {\n\t/**\n\t * @param {Object} sample\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateSample(sample)) {\n\t\t\tif (!sample.sample_uid) sample.sample_uid = await getNextUID(); // Nu uid  c (populate task) th khng cn to mi\n\n\t\t\t/** 1. Validate sample columns */\n\t\t\tconst validColumns = await matchValidColumns('samples', Object.keys(sample));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid sample columns: ${Object.keys(sample).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO samples (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => sample[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst sample = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Sample',\n\t\t\t\t};\n\t\t\t\tcache.samples[sample.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: sample,\n\t\t\t\t};\n\t\t\t\treturn cache.samples[sample.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tthrow new Error(`Invalid sample: ${sample}`);\n\t} catch (error) {\n\t\thandleError(error, 'newSample');\n\t}\n\n\tfunction validateSample(sample) {\n\t\tif (typeof sample === 'object' && Object.keys(sample).length > 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync function getNextUID() {\n\t\t// Get current day, week and year\n\t\tconst currentDate = new Date();\n\t\tconst currentYear = currentDate.getFullYear().toString().slice(-2);\n\t\tconst currentWeek = String(\n\t\t\tMath.floor(\n\t\t\t\t(currentDate.getTime() - new Date(currentDate.getFullYear(), 0, 1).getTime()) / (1000 * 60 * 60 * 24 * 7),\n\t\t\t) + 1,\n\t\t).padStart(2, '0');\n\t\tconst currentDay = String(currentDate.getDate()).padStart(2, '0');\n\n\t\t// Get next receipt UID\n\t\tconst query = `SELECT sample_uid FROM samples ORDER BY id DESC LIMIT 1`;\n\t\tconst result = await repoClient.query(query);\n\t\tconst lastUID = result.rows[0].sample_uid || 'PPT.YYWWDD-01';\n\t\tconst nextIndex =\n\t\t\tlastUID.slice(5, 7) !== currentWeek ? '01' : String(Number(lastUID.slice(10)) + 1).padStart(2, '0');\n\t\tconst nextReceiptUID = `SP.${currentYear}${currentWeek}${currentDay}-${nextIndex}`;\n\n\t\treturn nextReceiptUID;\n\t}\n}\n\nasync function newTest(test) {\n\t/**\n\t * @param {Object} test\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateTest(test)) {\n\t\t\t// Test khng c uid\n\t\t\t// if (!test.test_uid) test.test_uid = await getNextUID(); // Nu uid  c (populate task) th khng cn to mi\n\n\t\t\t/** 1. Validate test columns */\n\t\t\tconst validColumns = await matchValidColumns('tests', Object.keys(test));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid test columns: ${Object.keys(test).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO tests (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\n\t\t\tconst params = [...validColumns.map((column) => test[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst test = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Test',\n\t\t\t\t};\n\t\t\t\tcache.tests[test.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: test,\n\t\t\t\t};\n\t\t\t\treturn cache.tests[test.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tthrow new Error(`Invalid test: ${test}`);\n\t} catch (error) {\n\t\thandleError(error, 'newTest');\n\t}\n\n\tfunction validateTest(test) {\n\t\tif (\n\t\t\ttypeof test === 'object' &&\n\t\t\tObject.keys(test).length > 0\n\t\t\t// &&\n\t\t\t// test.id === undefined &&\n\t\t\t// test.test_name.trim().length > 0\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newClient(client) {\n\t/**\n\t * @param {Object} client\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateClient(client)) {\n\t\t\t/** 1. Validate client columns */\n\t\t\tif (!client.client_uid) client.client_uid = `CL.${crypto.randomUUID().substr(0, 8)}`;\n\t\t\tconst validColumns = await matchValidColumns('clients', Object.keys(client));\n\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid client columns: ${Object.keys(client).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO clients (${validColumns.join(',')}) \n                    VALUES (  ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => client[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst client = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Client',\n\t\t\t\t};\n\t\t\t\tcache.clients[client.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: client,\n\t\t\t\t};\n\t\t\t\treturn cache.clients[client.id].value;\n\t\t\t}\n\n\t\t\treturn client;\n\t\t}\n\t\tthrow new Error(`Invalid client: ${client}`);\n\t} catch (error) {\n\t\thandleError(error, 'newClient');\n\t}\n\n\tfunction validateClient(client) {\n\t\tif (\n\t\t\ttypeof client === 'object' &&\n\t\t\tObject.keys(client).length > 0\n\t\t\t// &&\n\t\t\t// client.id === undefined &&\n\t\t\t// client.client_name.trim().length > 0\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newTestOrder(testOrder) {\n\t/**\n\t * @param {Object} testOrder\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateTestOrder(testOrder)) {\n\t\t\t/** 1. Validate test order columns */\n\t\t\tconst validColumns = await matchValidColumns('test_order', Object.keys(testOrder));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(testOrder).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO test_order (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => testOrder[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst testOrder = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'TestOrder',\n\t\t\t\t};\n\t\t\t\tcache.testOrder[testOrder.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: testOrder,\n\t\t\t\t};\n\t\t\t\treturn cache.testOrder[testOrder.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newTestOrder');\n\t}\n\n\tfunction validateTestOrder(testOrder) {\n\t\tif (\n\t\t\ttypeof testOrder === 'object' &&\n\t\t\tObject.keys(testOrder).length > 0\n\t\t\t// && testOrder.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newUser(user) {\n\t/**\n\t * @param {Object} user\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateUser(user)) {\n\t\t\t/** 1. Validate user columns */\n\t\t\tconst validColumns = await matchValidColumns('users', Object.keys(user));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid user columns: ${Object.keys(user).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO users (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => user[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst user = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'User',\n\t\t\t\t};\n\t\t\t\tcache.users[user.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: user,\n\t\t\t\t};\n\t\t\t\treturn cache.users[user.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newUser');\n\t}\n\n\tfunction validateUser(user) {\n\t\tif (\n\t\t\ttypeof user === 'object'\n\t\t\t// && Object.keys(user).length > 0\n\t\t\t// && user.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newReceiptPrice(receiptPrice) {\n\t/**\n\t * @param {Object} receiptPrice\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateReceiptPrice(receiptPrice)) {\n\t\t\t/** 1. Validate receipt price columns */\n\t\t\tconst validColumns = await matchValidColumns('receipt_prices', Object.keys(receiptPrice));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(receiptPrice).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO receipt_prices (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => receiptPrice[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst insertReceiptPrice = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'ReceiptPrice',\n\t\t\t\t};\n\t\t\t\tcache.receiptPrices[insertReceiptPrice.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: receiptPrice,\n\t\t\t\t};\n\t\t\t\treturn cache.receiptPrices[insertReceiptPrice.id].value;\n\t\t\t}\n\t\t\treturn result.rows[0];\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newReceiptPrice');\n\t}\n\n\tfunction validateReceiptPrice(receiptPrice) {\n\t\tif (\n\t\t\ttypeof receiptPrice === 'object' &&\n\t\t\tObject.keys(receiptPrice).length > 0\n\t\t\t// && receiptPrice.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newLibProtocol(libProtocols) {\n\ttry {\n\t\tif (validateLibProtocols(libProtocols)) {\n\t\t\tconst validColumns = await matchValidColumns('lib_protocols', Object.keys(libProtocols));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(libProtocols).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO lib_protocols (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => libProtocols[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst libProtocols = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'LibProtocol',\n\t\t\t\t};\n\t\t\t\tcache.libProtocols[libProtocols.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: libProtocols,\n\t\t\t\t};\n\t\t\t\treturn cache.libProtocols[libProtocols.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newLibProtocol');\n\t}\n\n\tfunction validateLibProtocols(libProtocols) {\n\t\tif (\n\t\t\ttypeof libProtocols === 'object'\n\t\t\t// && Object.keys(libProtocols).length > 0\n\t\t\t// && libProtocols.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newLibDept(libDept) {\n\ttry {\n\t\tif (validateLibDept(libDept)) {\n\t\t\tconst validColumns = await matchValidColumns('lib_dept', Object.keys(libDept));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid test order columns: ${Object.keys(libDept).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO lib_dept (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => libDept[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst libDept = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'LibDept',\n\t\t\t\t};\n\t\t\t\tcache.libDept[libDept.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: libDept,\n\t\t\t\t};\n\t\t\t\treturn cache.libDept[libDept.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newLibDept');\n\t}\n\n\tfunction validateLibDept(libDept) {\n\t\tif (\n\t\t\ttypeof libDept === 'object'\n\t\t\t// && Object.keys(libDept).length > 0 &&\n\t\t\t// libDept.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newLibLab(libLab) {\n\ttry {\n\t\tif (validateLibLab(libLab)) {\n\t\t\tconst validColumns = await matchValidColumns('lib_lab', Object.keys(libLab));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid test order columns: ${Object.keys(libLab).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO lib_lab (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => libLab[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst libLab = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'LibLab',\n\t\t\t\t};\n\t\t\t\tcache.libLab[libLab.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: libLab,\n\t\t\t\t};\n\t\t\t\treturn cache.libLab[libLab.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newLibLab');\n\t}\n\n\tfunction validateLibLab(libLab) {\n\t\tif (\n\t\t\ttypeof libLab === 'object'\n\t\t\t// && Object.keys(libLab).length > 0 &&\n\t\t\t// libLab.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newSamplePrice(samplePrices) {\n\ttry {\n\t\tif (validateSamplePrices(samplePrices)) {\n\t\t\tconst validColumns = await matchValidColumns('sample_prices', Object.keys(samplePrices));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(samplePrices).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO sample_prices (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => samplePrices[column])];\n\t\t\tlet result = await repoClient.query(query, params);\n\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst samplePrices = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SamplePrice',\n\t\t\t\t};\n\t\t\t\tcache.samplePrices[samplePrices.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: samplePrices,\n\t\t\t\t};\n\t\t\t\treturn cache.samplePrices[samplePrices.id].value;\n\t\t\t}\n\t\t\treturn result.rows[0];\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newSamplePrice');\n\t}\n\n\tfunction validateSamplePrices(samplePrices) {\n\t\tif (\n\t\t\ttypeof samplePrices === 'object' &&\n\t\t\tObject.keys(samplePrices).length > 0\n\t\t\t// && samplePrices.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newSampleReport(sampleReport) {\n\ttry {\n\t\tif (validateSampleReport(sampleReport)) {\n\t\t\t// if (sampleReport.id) delete sampleReport.id;\n\t\t\t// CHECK\n\t\t\tif (!sampleReport.report_uid) sampleReport.report_uid = await nextSampleReportUID();\n\t\t\tconst validColumns = await matchValidColumns('sample_report', Object.keys(sampleReport));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(sampleReport).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO sample_report (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => sampleReport[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst sampleReport = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SampleReport',\n\t\t\t\t};\n\t\t\t\tcache.sampleReports[sampleReport.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: sampleReport,\n\t\t\t\t};\n\t\t\t\treturn cache.sampleReports[sampleReport.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newSampleReport');\n\t}\n\n\tfunction validateSampleReport(sampleReport) {\n\t\tif (\n\t\t\ttypeof sampleReport === 'object' &&\n\t\t\tObject.keys(sampleReport).length > 0\n\t\t\t//  && sampleReport.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync function nextSampleReportUID() {\n\t\t// Get current day, week and year\n\t\tconst currentDate = new Date();\n\t\tconst currentYear = currentDate.getFullYear().toString().slice(-2);\n\t\tconst currentWeek = String(\n\t\t\tMath.floor(\n\t\t\t\t(currentDate.getTime() - new Date(currentDate.getFullYear(), 0, 1).getTime()) / (1000 * 60 * 60 * 24 * 7),\n\t\t\t) + 1,\n\t\t).padStart(2, '0');\n\t\tconst currentDay = String(currentDate.getDate()).padStart(2, '0');\n\t\tconst currentMonth = String(currentDate.getMonth() + 1).padStart(2, '0');\n\n\t\t// Get next receipt UID\n\t\tconst query = `SELECT report_uid FROM sample_report ORDER BY id DESC LIMIT 1`;\n\t\tconst result = await repoClient.query(query);\n\t\tconst lastUID = result.rows[0].report_uid || 'PPT.YYWWMM-DD01';\n\t\tconst nextIndex =\n\t\t\tlastUID.slice(6, 8) !== currentWeek ? '01' : String(Number(lastUID.slice(12)) + 1).padStart(2, '0');\n\t\tconst nextReceiptUID = `PPT.${currentYear}${currentWeek}${currentMonth}-${currentDay}${nextIndex}`;\n\n\t\treturn nextReceiptUID;\n\t}\n}\n\nasync function newSampleReportTest(sampleReportTest) {\n\ttry {\n\t\tif (validateSampleReportTest(sampleReportTest)) {\n\t\t\tconst validColumns = await matchValidColumns('sample_report_tests', Object.keys(sampleReportTest));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(sampleReportTest).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO sample_report_tests (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => sampleReportTest[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst sampleReportTest = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SampleReportTest',\n\t\t\t\t};\n\t\t\t\tcache.sampleReportTest[sampleReportTest.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: sampleReportTest,\n\t\t\t\t};\n\t\t\t\treturn cache.sampleReportTest[sampleReportTest.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newSampleReportTest');\n\t}\n\n\tfunction validateSampleReportTest(sampleReportTest) {\n\t\tif (\n\t\t\ttypeof sampleReportTest === 'object' &&\n\t\t\tObject.keys(sampleReportTest).length > 0\n\t\t\t// &&\tsampleReportTest.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newLabRole(labRole) {\n\ttry {\n\t\tif (validateLabRole(labRole)) {\n\t\t\tconst validColumns = await matchValidColumns('user_lab_roles', Object.keys(labRole));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid User Lab Role columns: ${Object.keys(labRole).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO user_lab_roles (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => labRole[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst labRole = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'LabRole',\n\t\t\t\t};\n\t\t\t\tcache.labRole[labRole.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: labRole,\n\t\t\t\t};\n\t\t\t\treturn cache.labRole[labRole.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newLabRole');\n\t}\n\n\tfunction validateLabRole(labRole) {\n\t\tif (\n\t\t\ttypeof labRole === 'object' &&\n\t\t\tObject.keys(labRole).length > 0\n\t\t\t// && labRole.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newUserDept(userDept) {\n\ttry {\n\t\tif (validateUserDept(userDept)) {\n\t\t\tconst validColumns = await matchValidColumns('user_depts', Object.keys(userDept));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid User Dept columns: ${Object.keys(userDept).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO user_depts (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\t\t\t\t\n                    RETURNING *\n\n                `;\n\t\t\tconst params = [...validColumns.map((column) => userDept[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst userDept = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'UserDept',\n\t\t\t\t};\n\t\t\t\tcache.userDept[userDept.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: userDept,\n\t\t\t\t};\n\t\t\t\treturn cache.userDept[userDept.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newUserDept');\n\t}\n\n\tfunction validateUserDept(userDept) {\n\t\tif (\n\t\t\ttypeof userDept === 'object' &&\n\t\t\tObject.keys(userDept).length > 0\n\t\t\t// && userDept.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nfunction handleError(error, functionName) {\n\tnode.warn(`[ CAUGHT ERROR ] @layer0.js  ${functionName}() - ${JSON.stringify(error)}`);\n\tnode.warn(error);\n\t// API response\n\terror.statusCode = 500; // Internal Server Error\n\terror.errorMessage = 'Internal Server Error';\n\tthrow error;\n}\n\n//export functions\nconst layer0 = {\n\tgetReceipt,\n\tsetReceipt,\n\tgetSample,\n\tsetSample,\n\tgetTest,\n\tsetTest,\n\tgetClient,\n\tgetProtocol,\n\tgetReceiptPrice,\n\tgetTestOrder,\n\tgetSampleReport,\n\tgetSampleReportTest,\n\tgetUser,\n\tnewClient,\n\tsetClient,\n\tnewReceipt,\n\tnewTest,\n\tnewSample,\n\tnewTestOrder,\n\tnewUser,\n\tnewReceiptPrice,\n\tnewLibProtocol,\n\tnewLibDept,\n\tnewLibLab,\n\tnewSamplePrice,\n\tnewLabRole,\n\tnewUserDept,\n\tdelReceipt,\n\tdelSample,\n\tdelTest,\n\tdelClient,\n\tdelTestOrder,\n\tdelProtocol,\n\tdelReceiptPrice,\n\tsetReceiptPrice,\n\tsetTestOrder,\n\tsetProtocol,\n\tsetSampleReport,\n\tsetSampleReportTest,\n\tnewSampleReport,\n\tnewSampleReportTest,\n};\n\nglobal.set('layer0', layer0);\n\nglobal.set('bcrypt', bcrypt);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "bcrypt",
                "module": "bcrypt"
            },
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 290,
        "y": 60,
        "wires": [
            [
                "1433a20f7944ae6c",
                "e78d8f6b94f6ec77"
            ]
        ]
    },
    {
        "id": "1433a20f7944ae6c",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "tables",
        "func": "class Receipt {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\t// Check if the receipt id is valid\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\t// Get the receipt from the database\n\t\t\t\tconst receipt = await this.#layer0.getReceipt(this.id);\n\n\t\t\t\t// initialize the receipt class with the data from the database\n\t\t\t\tObject.assign(this, receipt);\n\t\t\t\tthis.#initialized = true;\n\n\t\t\t\t// Return the receipt\n\t\t\t\treturn receipt;\n\t\t\t}\n\t\t\t// Throw an error if the receipt id is invalid\n\t\t\tthrow new Error('Invalid receipt id');\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync set(receipt) {\n\t\t// Load the receipt data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Set the receipt id\n\t\t\treceipt.id = this.id;\n\n\t\t\t// Update the receipt in the database\n\t\t\tconst updatedReceipt = await this.#layer0.setReceipt(receipt);\n\n\t\t\t// Return the updated receipt\n\t\t\treturn updatedReceipt;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\t// Load the receipt data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Delete the receipt from the database\n\t\t\tconst deletedReceipt = await this.#layer0.delReceipt(this.id);\n\n\t\t\t// Return the deleted receipt\n\t\t\treturn deletedReceipt;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Create a new receipt in the database\n\t\t\tconst receipt = await global.get('layer0').newReceipt(data);\n\n\t\t\t// Create a new receipt price in the database with the sample_receipt_id of the new receipt\n\t\t\tconst receipt_price = await ReceiptPrice.new({ sample_receipt_id: receipt.id });\n\n\t\t\t// Get the detail of the new receipt and return it\n\t\t\tconst detailReceipt = await Receipt.getDetailReceipt(receipt.id);\n\t\t\treturn detailReceipt;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Receipt.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async recentReceipts(data) {\n\t\treturn [];\n\t\t/**\n\t\t * input data = { receipt_id: Number} or  {sample_id: Number } or null\n\t\t * output: params is null => return all receipt with status < 4\n\t\t * output: params is {receipt_id: Number} => return receipt with receipt_id\n\t\t * output: params is {sample_id: Number} => return receipt with sample_id\n\t\t */\n\t\ttry {\n\t\t\t// Khi to cc bin\n\t\t\tlet whereClause = '';\n\t\t\tlet params = [];\n\n\t\t\t// Kim tra `data`  to cc iu kin WHERE\n\t\t\tif (data) {\n\t\t\t\tif (data.receipt_id) {\n\t\t\t\t\twhereClause += ' r.id = $1';\n\t\t\t\t\tparams.push(data.receipt_id);\n\t\t\t\t} else if (data.sample_id) {\n\t\t\t\t\twhereClause += ' s.id = $1';\n\t\t\t\t\tparams.push(data.sample_id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Trng hp khng c `data`, lc theo `status`\n\t\t\t\twhereClause = ' s.status < 4';\n\t\t\t}\n\n\t\t\t// Xy dng query tch bit vi tham s\n\t\t\tconst query = `\n\t\t\t\tSELECT DISTINCT r.*\n\t\t\t\tFROM receipts r INNER JOIN samples s ON r.id = s.sample_receipt_id\n\t\t\t\tWHERE ${whereClause}\n\t\t\t\tORDER BY r.id DESC\n\t\t\t`;\n\n\t\t\t// Thc thi query vi tham s\n\t\t\tlet receipts = await global.get('repoClient').query(query, params);\n\n\t\t\t// Ly list cc receipt t kt qu query\n\t\t\treceipts = receipts.rows;\n\t\t\tnode.warn(receipts);\t\n\t\t\tconst detailReceipts = [];\n\n\t\t\t// Ly thng tin chi tit t cc receipt : samples, user, client, receipt_prices, ....\n\t\t\tfor (let receipt of receipts) {\n\t\t\t\treceipt = await Receipt.getDetailReceipt(receipt.id);\n\t\t\t\tnode.warn(receipt);\n\t\t\t\tdetailReceipts.push(receipt);\n\t\t\t}\n\n\t\t\t// Tr v list cc detail receipt\n\t\t\treturn detailReceipts;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Receipt.recentReceipts() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async searchReceipts(data) {\n\t\t/**\n\t\t * input: data String  (search data)\n\t\t * output: return list of receipt with search data\n\t\t */\n\t\ttry {\n\t\t\t// Xy dng query tch bit vi tham s\n\t\t\t// Tm kim theo k t c trong (include) : client_name, sample_name  v chui gn ng (trigram) : receipt_uid, sample_uid\n\t\t\tconst query = `\n\t\t\t\tSELECT DISTINCT r.*\n\t\t\t\tFROM receipts r\n\t\t\t\tLEFT JOIN samples s ON s.sample_receipt_id = r.id\n\t\t\t\tLEFT JOIN clients c ON c.id = r.client_id\n\t\t\t\tWHERE \tunaccent_text(c.client_name) ILIKE unaccent_text('%$1%')\n\t\t\t\tOR\t\tunaccent_text(s.sample_name) ILIKE unaccent_text('%$1%')\n\t\t\t\tOR\t\tunaccent_text(r.receipt_uid) % unaccent_text('%$1%')\n\t\t\t\tOR\t\tunaccent_text(s.sample_uid) % unaccent_text('%$1%')\n\t\t\t`;\n\n\t\t\t// Thc thi query vi tham s\n\t\t\tlet receipts = await global.get('repoClient').query(query, [data]);\n\n\t\t\t// Ly list cc receipt t kt qu query\n\t\t\treceipts = receipts.rows;\n\n\t\t\t// Ly thng tin chi tit t cc receipt : samples, user, client, receipt_prices, ....\n\t\t\tfor (let receipt of receipts) {\n\t\t\t\treceipt = await Receipt.getDetailReceipt(receipt.id);\n\t\t\t}\n\n\t\t\t// Tr v list cc detail receipt\n\t\t\treturn receipts;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Receipt.searchReceipts() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async getDetailReceipt(receipt_id) {\n\t\t/**\n\t\t * input: receipt_id Number\n\t\t * output: return detail of receipt with receipt_id\n\t\t */\n\n\t\ttry {\n\t\t\t// Ly thng tin receipt t database\n\t\t\tconst receipt = await global.get('layer0').getReceipt(receipt_id);\n\n\t\t\t// Ly thng tin user t database\n\t\t\treceipt.receipt_by_user = await User.get(receipt.receipt_by_user_id);\n\n\t\t\t// Ly thng tin client t database\n\t\t\treceipt.client = await Client.fromReceipt(receipt.client_id);\n\n\t\t\t// Ly thng tin receipt_prices t database\n\t\t\treceipt.receipt_prices = await ReceiptPrice.fromReceipt(receipt.id);\n\n\t\t\t// Ly thng tin samples t database\n\t\t\treceipt.samples = await Sample.fromReceipt(receipt.id);\n\n\t\t\tconst detailSamples = [];\n\t\t\t// Chi tit cc thng tin trong sample\n\n\t\t\tfor (let sample of receipt.samples) {\n\t\t\t\t// Ly thng tin chi tit ca sample\n\t\t\t\tsample = await Sample.get(sample.id);\n\t\t\t\tdetailSamples.push(sample);\n\t\t\t}\n\n\t\t\t// Cp nht li thng tin samples trong receipt vi chi tit cc thng tin\n\t\t\treceipt.samples = detailSamples;\n\n\t\t\t// Tr v thng tin chi tit ca receipt\n\t\t\treturn receipt;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Receipt.getDetail() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\t// Load the receipt data: check initialized\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\t// Handle the error\n\t\tnode.warn(error);\n\t\treturn null;\n\t}\n}\n\nclass Sample {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\t// Check if the sample id is valid\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\t// Get the sample from the database\n\t\t\t\tconst sample = await this.#layer0.getSample(this.id);\n\n\t\t\t\t// initialize the sample class with the data from the database\n\t\t\t\tObject.assign(this, sample);\n\t\t\t\tthis.#initialized = true;\n\n\t\t\t\t// Return the sample\n\t\t\t\treturn sample;\n\t\t\t}\n\t\t\t// Throw an error if the sample id is invalid\n\t\t\tthrow new Error('Invalid sample id');\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync set(sample) {\n\t\t// Load the sample data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Set the sample id\n\t\t\tsample.id = this.id;\n\n\t\t\t// Update the sample in the database\n\t\t\tconst updatedSample = await this.#layer0.setSample(sample);\n\n\t\t\t// Return the updated sample\n\t\t\treturn updatedSample;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\t// Load the sample data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Delete the sample from the database\n\t\t\tconst deletedSample = await this.#layer0.delSample(this.id);\n\n\t\t\t// Return the deleted sample\n\t\t\treturn deletedSample;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Create a new sample in the database\n\t\t\tconst sample = await global.get('layer0').newSample(data);\n\n\t\t\t// Create a new sample price in the database with the sample_id of the new sample\n\t\t\tconst sample_price = await SamplePrice.new({ sample_id: sample.id, sample_receipt_id: sample.sample_receipt_id });\n\n\t\t\t// Get the detail of the new sample and return it\n\t\t\tconst detailSample = await Sample.get(sample.id);\n\t\t\treturn detailSample;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async fromReceipt(sample_receipt_id) {\n\t\ttry {\n\t\t\t// Check if the sample_receipt_id is valid\n\t\t\tif (Number.isInteger(sample_receipt_id) && sample_receipt_id >= 0) {\n\t\t\t\t// Get the samples from the database\n\t\t\t\tconst query = `SELECT * FROM samples WHERE sample_receipt_id = $1`;\n\t\t\t\tconst params = [sample_receipt_id];\n\n\t\t\t\t// Execute the query\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\n\t\t\t\t// Get the samples from the results\n\t\t\t\tlet samples = results.rows;\n\n\t\t\t\t// return empty array if there are no samples\n\t\t\t\tif (samples && Array.isArray(samples) && samples.length === 0) return [];\n\n\t\t\t\tfor (let sample of samples) {\n\t\t\t\t\t// Get the details of the samples\n\t\t\t\t\tsample = await Sample.get(sample.id);\n\t\t\t\t}\n\n\t\t\t\t// Return list samples with detail\n\t\t\t\treturn samples;\n\t\t\t}\n\t\t\tthrow new Error('Invalid sample_receipt_id');\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.fromReceipt() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async get(id) {\n\t\ttry {\n\t\t\tconst sample = await global.get('layer0').getSample(id);\n\n\t\t\t// Ly thng tin user t database cho sample\n\t\t\tif (sample.created_by_id && sample.created_by_id >= 0) {\n\t\t\t\tsample.created_by = await User.get(sample.created_by_id);\n\t\t\t} else {\n\t\t\t\tsample.created_by = null;\n\t\t\t}\n\n\t\t\t// Ly thng tin test t database cho sample\n\t\t\tsample.test_orders = await TestOrder.fromSample(sample.id);\n\n\t\t\tfor (const test_order of sample.test_orders) {\n\t\t\t\t// Ly thng tin protocol t database cho test_order nu c\n\t\t\t\tif (test_order.protocol_id !== null && test_order.protocol_id !== 0) {\n\t\t\t\t\ttest_order.protocol = await LibProtocol.fromTestOrder(test_order.protocol_id);\n\t\t\t\t}\n\n\t\t\t\t// Ly thng tin lab_dept t database cho test_order nu c\n\t\t\t\tif (test_order.assigned_to_dept_id !== null && test_order.assigned_to_dept_id !== 0) {\n\t\t\t\t\ttest_order.assigned_to_dept = await LibDept.fromTestOrder(test_order.assigned_to_dept_id);\n\t\t\t\t}\n\n\t\t\t\t// Ly thng tin lab ng vi lab_dept t database cho test_order nu c\n\t\t\t\tif (test_order.assigned_to_dept) {\n\t\t\t\t\tif (test_order.assigned_to_dept.lab_id !== null && test_order.assigned_to_dept.lab_id !== 0)\n\t\t\t\t\t\ttest_order.assigned_to_dept.lab = await LibLab.fromLibDept(test_order.assigned_to_dept.lab_id);\n\t\t\t\t}\n\n\t\t\t\t// Ly thng tin ngi test (user) t database cho test_order nu c\n\t\t\t\tif (test_order.tested_by_user_id !== null && test_order.tested_by_user_id !== 0) {\n\t\t\t\t\ttest_order.tested_by = await User.get(test_order.tested_by_user_id);\n\t\t\t\t}\n\n\t\t\t\t// Ly thng tin ngi submit kt qu (user) t database cho test_order nu c\n\t\t\t\tif (test_order.result_submitted_by_id !== null && test_order.result_submitted_by_id !== 0) {\n\t\t\t\t\ttest_order.result_submitted_by = await User.get(test_order.result_submitted_by_id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Ly thng tin sample_prices t database cho sample\n\t\t\tsample.sample_prices = await SamplePrice.fromSample(sample.id);\n\n\t\t\t// Ly thng tin sample_reports t database cho sample\n\t\t\tconst reports = await SampleReport.fromSample(sample.id);\n\t\t\tsample.reports = reports.report !== null ? [reports.report] : [];\n\n\t\t\t\n\t\t\t// return sample\n\t\t\treturn sample;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.get() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async getDetailSample(sample_id) {\n\t\ttry {\n\t\t\t// Get detail receipt for sample_id\n\t\t\tconst receipt = await Receipt.recentReceipts({ sample_id: sample_id });\n\n\t\t\t// Get sample from receipt\n\t\t\tconst sample = receipt[0].samples.filter((sample) => sample.id === sample_id)[0];\n\n\t\t\t// Add receipt to sample and return\n\t\t\tsample.receipt = receipt[0];\n\t\t\treturn sample;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.getDetailSample() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\t\t\t\n\t\t}\n\t}\n\n\tstatic async getProcessings() {\n\t\t/**\n\t\t * input: null\n\t\t * output: return list of sample with status < 4 and created_at >= 40 days\n\t\t */\n\t\tconst query = `\n\t\t\tSELECT * \n\t\t\tFROM samples \n\t\t\tWHERE status < 4 \n\t\t\tAND created_at >= CURRENT_TIMESTAMP - INTERVAL '40 days'\n\t\t\tORDER BY id DESC\n\t\t`;\n\n\t\t// Execute the query\n\t\tconst results = await global.get('repoClient').query(query);\n\n\t\t// Get the samples from the results\n\t\tlet samples = results.rows;\n\n\t\t// return empty array if there are no samples\n\t\tif (samples && Array.isArray(samples) && samples.length === 0) return [];\n\n\t\t// Get the details of the samples\n\t\tfor (const sample of samples) {\n\t\t\t// Get user from database for sample\n\t\t\tif (sample.created_by_id && sample.created_by_id >= 0) {\n\t\t\t\tsample.created_by = await User.get(sample.created_by_id);\n\t\t\t} else {\n\t\t\t\tsample.created_by = null;\n\t\t\t}\n\n\t\t\t// Get test_order from database for sample\n\t\t\tsample.test_orders = await TestOrder.fromSample(sample.id);\n\n\t\t\tfor (const test_order of sample.test_orders) {\n\t\t\t\t// Get protocol from database for test_order if exists\n\t\t\t\tif (test_order.protocol_id !== null && test_order.protocol_id !== 0) {\n\t\t\t\t\ttest_order.protocol = await LibProtocol.fromTestOrder(test_order.protocol_id);\n\t\t\t\t}\n\n\t\t\t\t// Get lab_dept from database for test_order if exists\n\t\t\t\tif (test_order.result_submitted_by_id !== null && test_order.result_submitted_by_id !== 0) {\n\t\t\t\t\ttest_order.result_submitted_by = await User.get(test_order.result_submitted_by_id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get sample_price from database for sample\n\t\t\tsample.sample_prices = await SamplePrice.fromSample(sample.id);\n\n\t\t\t// Get receipt from database for sample\n\t\t\tconst instanceReceipt = new Receipt(sample.sample_receipt_id);\n\t\t\tsample.receipt = await instanceReceipt.get();\n\t\t\tdelete sample.receipt.className;\n\n\t\t\t// Reports : empty\n\t\t\tsample.reports = [];\n\t\t}\n\n\t\t// remove archived samples\n\t\tsamples = samples.filter((sample) => sample.receipt.archived !== true);\n\n\t\t// return list of processing samples\n\t\treturn { samples: samples };\n\t}\n\n\tasync #lazyLoader() {\n\t\t// Load the sample data: check initialized\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\t// Handle the error\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass Test {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\t// Check if the test id is valid\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\t// Get the test from the database\n\t\t\t\tconst test = await this.#layer0.getTest(this.id);\n\t\t\t\tif (test === null) throw new Error('Test not found');\n\n\t\t\t\t// initialize the test class with the data from the database\n\t\t\t\tObject.assign(this, test);\n\t\t\t\tthis.#initialized = true;\n\n\t\t\t\t// Return the test\n\t\t\t\treturn test;\n\t\t\t}\n\t\t\tthrow new Error('Invalid test id');\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync set(test) {\n\t\t// Load the test data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Set the test id\n\t\t\ttest.id = this.id;\n\n\t\t\t// Update the test in the database\n\t\t\tconst updatedTest = await this.#layer0.setTest(test);\n\n\t\t\t// Return the updated test\n\t\t\treturn updatedTest;\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\t// Load the test data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Delete the test from the database\n\t\t\tconst deletedTest = await this.#layer0.delTest(this.id);\n\n\t\t\t// Return the deleted test\n\t\t\treturn deletedTest;\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Create a new test in the database\n\t\t\tconst test = await global.get('layer0').newTest(data);\n\n\t\t\t// Return the new test\n\t\t\treturn test;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Test.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async fromSample(sample_id) {\n\t\ttry {\n\t\t\t// Check if the sample id is valid\n\t\t\tif (Number.isInteger(sample_id) && sample_id >= 0) {\n\t\t\t\t// Get the tests from the database\n\t\t\t\tconst query = `SELECT id FROM test_order WHERE sample_id = $1 ORDER BY id ASC`;\n\t\t\t\tconst params = [sample_id];\n\n\t\t\t\t// Execute the query\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\n\t\t\t\t// Get the tests from the results\n\t\t\t\tconst tests = results.rows;\n\n\t\t\t\t// return empty array if there are no tests\n\t\t\t\tif (tests && Array.isArray(tests) && tests.length === 0) return [];\n\n\t\t\t\t// Return the tests for the sample\n\t\t\t\treturn await Promise.all(\n\t\t\t\t\ttests.map(async (test) => {\n\t\t\t\t\t\tconst newInstance = new Test(test.id);\n\t\t\t\t\t\treturn await newInstance.get();\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Throw an error if the sample id is invalid\n\t\t\tthrow new Error('Invalid sample id');\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Test.fromSample() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async searchTests(data) {\n\t\t// Search tests by test_name, protocol_name, protocol_code\n\t\ttry {\n\t\t\t// Check if the search data is valid\n\t\t\tif (data.trim() === '') return [];\n\n\t\t\t// Set the similarity threshold\n\t\t\tawait global.get('repoClient').query('SET pg_trgm.similarity_threshold = 0.2');\n\n\t\t\t// Search tests by test_name, protocol_name, protocol_code\n\t\t\tconst query = ` SELECT DISTINCT t.* FROM tests t INNER JOIN lib_protocols p ON t.protocol_id = p.id\n\t\t\t\t\t\t\tWHERE unaccent_text(t.test_name) ILIKE unaccent_text('%$1%') \n\t\t\t\t\t\t\tOR unaccent_text(p.name) ILIKE unaccent_text('%$1%') \n\t\t\t\t\t\t\tOR unaccent_text(p.code) % unaccent_text('$1')\n\t\t\t\t\t\t\tORDER BY t.id ASC\n\t\t\t\t\t\t\t`;\n\n\t\t\t// Execute the query\n\t\t\tconst results = await global.get('repoClient').query(query, [data]);\n\n\t\t\t// Get the tests from the results\n\t\t\tlet tests = results.rows;\n\n\t\t\t// return empty array if there are no tests\n\t\t\tif (tests && Array.isArray(tests) && tests.length === 0) return [];\n\n\t\t\t// Get the protocols of the tests\n\t\t\tfor (const test of tests) {\n\t\t\t\ttest.protocol = await LibProtocol.fromTestOrder(test.protocol_id);\n\t\t\t}\n\n\t\t\t// Return the tests for the search data\n\t\t\treturn tests;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Test.searchTest() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\t// load the test data\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\t// Handle the error\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Test.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass TestOrder {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\t// Check if the testOrder id is valid\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\t// Get the testOrder from the database\n\t\t\t\tconst testOrder = await this.#layer0.getTestOrder(this.id);\n\n\t\t\t\t// initialize the testOrder class with the data from the database\n\t\t\t\tObject.assign(this, testOrder);\n\t\t\t\tthis.#initialized = true;\n\n\t\t\t\t// Return the testOrder\n\t\t\t\treturn testOrder;\n\t\t\t}\n\n\t\t\t// Throw an error if the testOrder id is invalid\n\t\t\tthrow new Error('Invalid testOrder id');\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync set(testOrder) {\n\t\t// Load the testOrder data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Set the testOrder id\n\t\t\ttestOrder.id = this.id;\n\n\t\t\t// Update the testOrder in the database\n\t\t\tconst updatedTestOrder = await this.#layer0.setTestOrder(testOrder);\n\n\t\t\t// Return the updated testOrder\n\t\t\treturn updatedTestOrder;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\t// Load the testOrder data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Delete the testOrder from the database\n\t\t\tconst deletedTestOrder = await this.#layer0.delTestOrder(this.id);\n\n\t\t\t// Return the deleted testOrder\n\t\t\treturn deletedTestOrder;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Check if the testOrder data is valid\n\t\t\tif (validateTestOrderData(data)) {\n\t\t\t\t// Create a new testOrder in the database\n\t\t\t\tconst testOrder = await global.get('layer0').newTestOrder(data);\n\n\t\t\t\t// Return the new testOrder\n\t\t\t\treturn testOrder;\n\t\t\t}\n\n\t\t\t// Throw an error if the testOrder data is invalid\n\t\t\tconst error = new Error('Invalid test order data');\n\t\t\terror.statusCode = 400; // Bad Request\n\t\t\tthrow error;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - TestOrder.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\n\t\tfunction validateTestOrderData(data) {\n\t\t\tif (typeof data === 'object' && data !== null && Object.keys(data).length > 0) {\n\t\t\t\tif (!data.sample_receipt_id) throw new Error('sample_receipt_id is required to create test order');\n\t\t\t\tif (!data.sample_id) throw new Error('sample_id is required to create test order');\n\t\t\t\t// if (!data.protocol_id) throw new Error('protocol_id is required to create test order');\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstatic async fromSample(sample_id) {\n\t\t/**\n\t\t * input: sample_id Number\n\t\t * output: return list of test_order with sample_id\n\t\t */\n\n\t\ttry {\n\t\t\t// Check if the sample id is valid\n\t\t\tif (Number.isInteger(sample_id) && sample_id >= 0) {\n\t\t\t\t// Get the test orders from the database\n\t\t\t\tconst query = `SELECT * FROM test_order WHERE sample_id = $1`;\n\t\t\t\tconst params = [sample_id];\n\n\t\t\t\t// Execute the query\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\t\tlet tests = results.rows;\n\n\t\t\t\t// return empty array if there are no tests\n\t\t\t\tif (tests && Array.isArray(tests) && tests.length === 0) return [];\n\n\t\t\t\t// Return the test orders for the sample\n\t\t\t\treturn tests;\n\t\t\t}\n\t\t\t// Throw an error if the sample id is invalid\n\t\t\tthrow new Error('Invalid sample id');\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - TestOrder.fromSample() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\t// Load the testOrder data: check initialized\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - TestOrder.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass Client {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Create a new client in the database\n\t\t\tif (validateClientData(data)) {\n\t\t\t\t// Create a new client in the database\n\t\t\t\tconst client = await global.get('layer0').newClient(data);\n\n\t\t\t\t// Return the new client\n\t\t\t\treturn client;\n\t\t\t}\n\n\t\t\t// Throw an error if the client data is invalid\n\t\t\tconst error = new Error('Invalid client data');\n\t\t\terror.statusCode = 400; // Bad Request\n\t\t\tthrow error;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Client.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\n\t\tfunction validateClientData(data) {\n\t\t\t// rule: client_name is required\n\t\t\treturn typeof data === 'object' && data !== null && data.client_name && data.client_name.trim().length > 0;\n\t\t}\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\t// Check if the client id is valid\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\t// Get the client from the database\n\t\t\t\tconst client = await this.#layer0.getClient(this.id);\n\n\t\t\t\t// initialize the client class with the data from the database\n\t\t\t\tObject.assign(this, client);\n\t\t\t\tthis.#initialized = true;\n\n\t\t\t\t// Return the client\n\t\t\t\treturn client;\n\t\t\t}\n\n\t\t\t// Throw an error if the client id is invalid\n\t\t\tthrow new Error('Invalid client id');\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync set(client) {\n\t\t// Load the client data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Set the client id\n\t\t\tclient.id = this.id;\n\n\t\t\t// Update the client in the database\n\t\t\tconst updatedClient = await this.#layer0.setClient(client);\n\n\t\t\t// Return the updated client\n\t\t\treturn updatedClient;\n\t\t} catch (error) {\n\t\t\t//\tHandle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\t// Load the client data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Delete the client from the database\n\t\t\tconst deletedClient = await this.#layer0.delClient(this.id);\n\n\t\t\t// Return the deleted client\n\t\t\treturn deletedClient;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async fromReceipt(receipt_client_id) {\n\t\ttry {\n\t\t\t// Check if the receipt_client_id is valid\n\t\t\tif (Number.isInteger(receipt_client_id) && receipt_client_id >= 0) {\n\t\t\t\t// Get the client from the database\n\t\t\t\tconst query = `SELECT * FROM clients WHERE id = $1`;\n\t\t\t\tconst params = [receipt_client_id];\n\n\t\t\t\t// Execute the query\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\n\t\t\t\t// Get the client from the results\n\t\t\t\tlet clients = results.rows;\n\n\t\t\t\t// return null if there are no clients\n\t\t\t\tif (clients && Array.isArray(clients) && clients.length === 0) return null;\n\n\t\t\t\t// Return the client for the receipt\n\t\t\t\treturn clients[0];\n\t\t\t}\n\n\t\t\t// Throw an error if the receipt_client_id is invalid\n\t\t\tthrow new Error('Invalid receipt_client_id');\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Client.fromReceipt() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async searchClients(data) {\n\t\ttry {\n\t\t\tif (data.trim() === '') throw new Error('Invalid search data');\n\t\t\tawait global.get('repoClient').query('SET pg_trgm.similarity_threshold = 0.5');\n\t\t\tconst query = ` SELECT * FROM clients \n\t\t\tWHERE \tunaccent_text(client_name) ILIKE unaccent_text('%$1%') \n\t\t\tOR\t\tcode % '$1'\t\t\t\t\n\t\t\tORDER BY id ASC`;\n\t\t\tconst results = await global.get('repoClient').query(query, [data]);\n\t\t\tlet clients = results.rows;\n\t\t\tclients = JSON.parse(JSON.stringify(clients));\n\t\t\tif (clients && Array.isArray(clients) && clients.length === 0) return [];\n\n\t\t\treturn clients;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Client.searchClients() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - Client.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass User {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\tif (validateUserData(data)) {\n\t\t\t\tconst bcrypt = global.get('bcrypt');\n\n\t\t\t\t/** 1. Hash password */\n\t\t\t\tdata.password = await bcrypt.hash(data.password, 10);\n\n\t\t\t\t/** 2. Send to server */\n\t\t\t\tconst user = await global.get('layer0').newUser(data);\n\t\t\t\treturn user;\n\t\t\t}\n\t\t\tconst error = new Error('Invalid user data');\n\t\t\terror.statusCode = 400; // Bad Request\n\t\t\tthrow error;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - User.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\n\t\tfunction validateUserData(data) {\n\t\t\tif (typeof data === 'object' && data !== null && Object.keys(data).length > 0) {\n\t\t\t\tif (!data.name) throw new Error('username is required to create user');\n\t\t\t\tif (!data.password) throw new Error('password is required to create user');\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\tconst user = await this.#layer0.getUser(this.id);\n\t\t\t\tObject.assign(this, user);\n\t\t\t\tthis.#initialized = true;\n\t\t\t\treturn user;\n\t\t\t}\n\t\t\tthrow new Error('Invalid user id');\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync authenticate() {\n\t\t// NOTES\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t/**1. Check user */\n\t\t\tif (this.disabled) throw new Error('User is disabled');\n\t\t\tif (this.force_reset_pw === true) throw new Error('Reset password is required');\n\n\t\t\t/**2. Check lab */\n\t\t\tconst roles = await UserLabRole.fromUser(this.id);\n\t\t\tlet labs = [];\n\t\t\tfor (const role of roles) {\n\t\t\t\tconst lab = await LibLab.fromLibDept(role.lab_id);\n\t\t\t\tlabs.push(lab);\n\t\t\t}\n\t\t\tconst depts = await UserDept.fromUser(this.id);\n\t\t\t// depts.forEach((dept) => {\n\t\t\t// \tdept.dept = LibDept.(dept.dept_id);\n\t\t\t// });\n\n\t\t\tconst test_mgr_authorized_labs = roles.filter((item) => item.test_manager).map((item) => item.lab_id);\n\n\t\t\tconst current_session_roles = roles.find((role) => role.lab_id === labs[0].id);\n\n\t\t\tconst values = {\n\t\t\t\tuser: this,\n\t\t\t\tuser_lab_roles: roles,\n\t\t\t\tlab_session: labs[0],\n\t\t\t\tuser_depts: depts,\n\t\t\t\ttest_mgr_authorized_labs: test_mgr_authorized_labs,\n\t\t\t\tcurrent_session_roles: current_session_roles,\n\t\t\t};\n\n\t\t\tnode.warn(values);\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async get(id) {\n\t\t// NOTES\n\t\ttry {\n\t\t\tconst user = await global.get('layer0').getUser(id);\n\t\t\tdelete user.password;\n\t\t\tdelete user.className;\n\t\t\treturn user;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - User.get() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async login(email, password) {\n\t\t// NOTES\n\t\ttry {\n\t\t\tif (!email || !password) throw new Error('Invalid email or password');\n\t\t\tpassword = password.toString();\n\t\t\temail = email.toString();\n\n\t\t\t/**1. Get user from DB */\n\t\t\tconst query = `SELECT * FROM users WHERE email = $1`;\n\t\t\tconst params = [email];\n\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\tlet users = results.rows;\n\n\t\t\tusers = JSON.parse(JSON.stringify(users));\n\n\t\t\tif (users && Array.isArray(users) && users.length === 0) return null;\n\n\t\t\tconst user = users[0];\n\t\t\tconst bcrypt = global.get('bcrypt');\n\t\t\tconst match = await bcrypt.compare(password, user.password);\n\n\t\t\tconst lab_roles = await UserLabRole.fromUser(user.id);\n\t\t\tconst lib_lab = await LibLab.fromLibDept(lab_roles[0].lab_id);\n\n\t\t\t/** CREATE TOKEN */\n\t\t\t// Payload\n\t\t\tconst tokenInfor = {};\n\t\t\ttokenInfor.user = user;\n\t\t\ttokenInfor.extras = { lab_session: lib_lab, user_lab_roles: lab_roles };\n\t\t\ttokenInfor.expiration = Date.now() + 60 * 60 * 24 * 1000; // 24h\n\t\t\ttokenInfor.id = user.id;\n\n\t\t\t// Header\n\t\t\tconst header = {\n\t\t\t\talg: 'HS256',\n\t\t\t\ttyp: 'JWT',\n\t\t\t};\n\t\t\t//convert to base64\n\t\t\tconst base64url = (obj) => {\n\t\t\t\treturn Buffer.from(JSON.stringify(obj))\n\t\t\t\t\t.toString('base64')\n\t\t\t\t\t.replace(/\\+/g, '-') // Thay + bng -\n\t\t\t\t\t.replace(/\\//g, '_') // Thay / bng _\n\t\t\t\t\t.replace(/=+$/, ''); // Xa padding (=)\n\t\t\t};\n\n\t\t\tconst encodedHeader = base64url(header);\n\t\t\tconst encodedPayload = base64url(tokenInfor);\n\n\t\t\t//secretKey\n\t\t\tconst secretKey = 'secretKey';\n\n\t\t\t// SHA-256\n\t\t\tconst signature = crypto\n\t\t\t\t.createHmac('sha256', secretKey)\n\t\t\t\t.update(encodedHeader + '.' + encodedPayload)\n\t\t\t\t.digest('base64')\n\t\t\t\t.replace(/\\+/g, '-') // Thay + bng -\n\t\t\t\t.replace(/\\//g, '_') // Thay / bng _\n\t\t\t\t.replace(/=+$/, ''); // Xa padding (=)\n\n\t\t\t//encode\n\t\t\tconst token = encodedHeader + '.' + encodedPayload + '.' + signature;\n\n\t\t\tif (match) {\n\t\t\t\tnode.warn(token);\n\n\t\t\t\treturn { tokenInfor: tokenInfor, token: token };\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {}\n\t}\n\n\tasync #lazyLoader() {\n\t\t// Load the user data: check initialized\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\t// Handle the error\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - User.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass ReceiptPrice {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\tconst receiptPrice = await global.get('layer0').newReceiptPrice(data);\n\t\t\treturn receiptPrice;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - ReceiptPrice.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\t// Check if the receiptPrice id is valid\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\t// Get the receiptPrice from the database\n\t\t\t\tconst receiptPrice = await this.#layer0.getReceiptPrice(this.id);\n\n\t\t\t\t// initialize the receiptPrice class with the data from the database\n\t\t\t\tObject.assign(this, receiptPrice);\n\t\t\t\tthis.#initialized = true;\n\n\t\t\t\t// Return the receiptPrice\n\t\t\t\treturn receiptPrice;\n\t\t\t}\n\n\t\t\t// Throw an error if the receiptPrice id is invalid\n\t\t\tthrow new Error('Invalid receiptPrice id');\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync set(receiptPrice) {\n\t\tawait this.#lazyLoader();\n\t\ttry {\n\t\t\treceiptPrice.id = this.id;\n\t\t\treturn await this.#layer0.setReceiptPrice(receiptPrice);\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\treturn await this.#layer0.delReceiptPrice(this.id);\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async fromReceipt(receipt_price_id) {\n\t\ttry {\n\t\t\tif (Number.isInteger(receipt_price_id) && receipt_price_id >= 0) {\n\t\t\t\tconst query = `SELECT * FROM receipt_prices WHERE sample_receipt_id = $1`;\n\t\t\t\tconst params = [receipt_price_id];\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\t\tlet receiptPrices = results.rows;\n\n\t\t\t\treceiptPrices = JSON.parse(JSON.stringify(receiptPrices));\n\n\t\t\t\tif (receiptPrices && Array.isArray(receiptPrices) && receiptPrices.length === 0) return null;\n\n\t\t\t\treturn receiptPrices[0];\n\t\t\t}\n\t\t\tthrow new Error('Invalid receipt_price_id');\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - ReceiptPrice.fromReceipt() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - ReceiptPrice.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass LibProtocol {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\tconst libProtocol = await this.#layer0.getProtocol(this.id);\n\t\t\t\tObject.assign(this, libProtocol);\n\t\t\t\tthis.#initialized = true;\n\t\t\t\treturn libProtocol;\n\t\t\t}\n\t\t\tthrow new Error('Invalid libProtocol id');\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\tconst libProtocol = await global.get('layer0').newLibProtocol(data);\n\t\t\treturn libProtocol;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - LibProtocol.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync set(libProtocol) {\n\t\tawait this.#lazyLoader();\n\t\ttry {\n\t\t\tlibProtocol.id = this.id;\n\t\t\treturn await this.#layer0.setLibProtocol(libProtocol);\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\treturn await this.#layer0.delProtocol(this.id);\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async fromTestOrder(test_order_protocol_id) {\n\t\ttry {\n\t\t\tif (Number.isInteger(test_order_protocol_id) && test_order_protocol_id >= 0) {\n\t\t\t\tconst query = `SELECT * FROM lib_protocols WHERE id = $1`;\n\t\t\t\tconst params = [test_order_protocol_id];\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\t\tlet libProtocols = results.rows;\n\n\t\t\t\tlibProtocols = JSON.parse(JSON.stringify(libProtocols));\n\n\t\t\t\tif (libProtocols && Array.isArray(libProtocols) && libProtocols.length === 0) return null;\n\n\t\t\t\treturn libProtocols[0];\n\t\t\t}\n\t\t\tthrow new Error(`Invalid test_order_protocol_id: ${test_order_protocol_id}`);\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - LibProtocol.fromTestOrder() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async searchProtocols(data) {\n\t\ttry {\n\t\t\tif (data.trim() === '') throw new Error('Invalid search data');\n\t\t\tawait global.get('repoClient').query('SET pg_trgm.similarity_threshold = 0.7');\n\t\t\tconst query = `\tSELECT * FROM lib_protocols\n\t\t\t\t\t\t\tWHERE unaccent_text(name) ILIKE unaccent_text('%$1%') OR code % '$2' \n\t\t\t\t\t\t\tORDER BY name ASC`;\n\t\t\tconst results = await global.get('repoClient').query(query, [data, data]);\n\t\t\tlet protocols = JSON.parse(JSON.stringify(results.rows));\n\t\t\tif (protocols && Array.isArray(protocols) && protocols.length === 0) return [];\n\n\t\t\treturn protocols;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - LibProtocol.searchProtocols() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - LibProtocol.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass LibDept {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\tconst libDept = await global.get('layer0').newLibDept(data);\n\t\t\treturn libDept;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - LibDept.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async fromTestOrder(test_order_assigned_to_dept_id) {\n\t\ttry {\n\t\t\tif (Number.isInteger(test_order_assigned_to_dept_id) && test_order_assigned_to_dept_id >= 0) {\n\t\t\t\tconst query = `SELECT * FROM lib_dept WHERE id = $1`;\n\t\t\t\tconst params = [test_order_assigned_to_dept_id];\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\t\tlet libDepts = results.rows;\n\n\t\t\t\tlibDepts = JSON.parse(JSON.stringify(libDepts));\n\n\t\t\t\tif (libDepts && Array.isArray(libDepts) && libDepts.length === 0) return null;\n\n\t\t\t\treturn libDepts[0];\n\t\t\t}\n\t\t\tthrow new Error(`Invalid test_order_assigned_to_dept_id: ${test_order_assigned_to_dept_id}`);\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - LibDept.fromTestOrder() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nclass SamplePrice {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\tconst samplePrice = await global.get('layer0').newSamplePrice(data);\n\t\t\treturn samplePrice;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - SamplePrice.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync set(samplePrice) {\n\t\tawait this.#lazyLoader();\n\t\ttry {\n\t\t\treturn await this.#layer0.setSamplePrice(this.id, samplePrice);\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\t// Load the samplePrice data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Delete the samplePrice from the database\n\t\t\tconst deletedSamplePrice = await this.#layer0.delSamplePrice(this.id);\n\n\t\t\t// Return the deleted samplePrice\n\t\t\treturn deletedSamplePrice;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async fromSample(sample_price_id) {\n\t\t/**\n\t\t * input: sample_price_id Number\n\t\t * output: return sample_price with sample_price_id\n\t\t */\n\n\t\ttry {\n\t\t\t// Check if the sample_price_id is valid\n\t\t\tif (Number.isInteger(sample_price_id) && sample_price_id >= 0) {\n\t\t\t\t// Get the sample price from the database\n\t\t\t\tconst query = `SELECT * FROM sample_prices WHERE sample_id = $1`;\n\t\t\t\tconst params = [sample_price_id];\n\n\t\t\t\t// Execute the query\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\n\t\t\t\t// Get the sample price from the results\n\t\t\t\tlet samplePrices = results.rows;\n\n\t\t\t\t// return null if there are no sample prices\n\t\t\t\tif (samplePrices && Array.isArray(samplePrices) && samplePrices.length === 0) return null;\n\n\t\t\t\t// Return the sample price for the sample\n\t\t\t\treturn samplePrices[0];\n\t\t\t}\n\t\t\tthrow new Error('Invalid sample_price_id');\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - SamplePrice.fromSample() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\t// Load the samplePrice data: check initialized\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\t// Handle the error\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - SamplePrice.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass LibLab {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Create a new lib_lab in the database\n\t\t\tconst libLab = await global.get('layer0').newLibLab(data);\n\n\t\t\t// Return the new lib_lab\n\t\t\treturn libLab;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - LibLab.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async get_assign_dept_list() {\n\t\ttry {\n\t\t\t// Get the lib_lab from the database\n\t\t\tconst query = `SELECT * FROM lib_lab`;\n\n\t\t\t// Execute the query\n\t\t\tconst results = await global.get('repoClient').query(query);\n\t\t\tlet libLabs = results.rows;\n\n\t\t\t// return empty array if there are no lib_labs\n\t\t\tif (libLabs && Array.isArray(libLabs) && libLabs.length === 0) return [];\n\n\t\t\tfor (const libLab of libLabs) {\n\t\t\t\t// Get the lib_dept from the database\n\t\t\t\tconst query = `SELECT * FROM lib_dept WHERE lab_id = $1`;\n\t\t\t\tconst params = [libLab.id];\n\n\t\t\t\t// Execute the query\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\t\tconst libDepts = results.rows;\n\n\t\t\t\t// return empty array if there are no lib_depts\n\t\t\t\tlibLab.lab = libDepts[0];\n\t\t\t}\n\n\t\t\t// Return the lib_lab\n\t\t\treturn libLabs;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - LibLab.get() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async fromLibDept(lib_dept_lab_id) {\n\t\ttry {\n\t\t\t// Check if the lib_dept_lab_id is valid\n\t\t\tif (Number.isInteger(lib_dept_lab_id) && lib_dept_lab_id >= 0) {\n\t\t\t\t// Get the lib_lab from the database\n\t\t\t\tconst query = `SELECT * FROM lib_lab WHERE id = $1`;\n\t\t\t\tconst params = [lib_dept_lab_id];\n\n\t\t\t\t// Execute the query\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\t\tlet libLabs = results.rows;\n\n\t\t\t\t// return null if there are no lib_labs\n\t\t\t\tif (libLabs && Array.isArray(libLabs) && libLabs.length === 0) return null;\n\n\t\t\t\t// Return the lib_lab\n\t\t\t\treturn libLabs[0];\n\t\t\t} else if (lib_dept_lab_id === null) {\n\t\t\t\t// return empty array if there are no lib_labs\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Throw an error if the lib_dept_lab_id is invalid\n\t\t\tthrow new Error('Invalid lib_dept_lab_id');\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - LibLab.fromLibDept() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nclass SampleReport {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\t// Check if the sampleReport id is valid\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\t// Get the sampleReport from the database\n\t\t\t\tconst sampleReport = await this.#layer0.getSampleReport(this.id);\n\n\t\t\t\t// initialize the sampleReport class with the data from the database\n\t\t\t\tObject.assign(this, sampleReport);\n\t\t\t\tthis.#initialized = true;\n\n\t\t\t\t// Return the sampleReport\n\t\t\t\treturn sampleReport;\n\t\t\t}\n\n\t\t\t// Throw an error if the sampleReport id is invalid\n\t\t\tthrow new Error('Invalid sampleReport id');\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Create a new sampleReport in the database\n\t\t\tconst sampleReport = await global.get('layer0').newSampleReport(data);\n\n\t\t\t// Return the new sampleReport\n\t\t\treturn sampleReport;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - SampleReport.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync set(sampleReport) {\n\t\t// Load the sampleReport data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Set the sampleReport id\n\t\t\tsampleReport.id = this.id;\n\n\t\t\t// Update the sampleReport in the database\n\t\t\tconst updatedSampleReport = await this.#layer0.setSampleReport(sampleReport);\n\n\t\t\t// Return the updated sampleReport\n\t\t\treturn updatedSampleReport;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\t// Load the sampleReport data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Delete the sampleReport from the database\n\t\t\treturn await this.#layer0.delSampleReport(this.id);\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async fromSample(sample_report_id) {\n\t\ttry {\n\t\t\t// Check if the sample_report_id is valid\n\t\t\tif (Number.isInteger(sample_report_id) && sample_report_id >= 0) {\n\t\t\t\t// Get the sampleReport from the database\n\t\t\t\tconst query = `SELECT * FROM sample_report WHERE id = $1`;\n\t\t\t\tconst params = [sample_report_id];\n\n\t\t\t\t// Execute the query\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\t\tlet sampleReports = results.rows;\n\n\t\t\t\t// return null if there are no sampleReports\n\t\t\t\tif (sampleReports && Array.isArray(sampleReports) && sampleReports.length === 0) return null;\n\n\t\t\t\t// Get the testReports for the sampleReport\n\t\t\t\tconst testReports = await TestReport.fromSampleReport(sampleReports[0].id);\n\n\t\t\t\t// Create object Report\n\t\t\t\tconst report = sampleReports[0];\n\t\t\t\tconst reportTests = testReports;\n\t\t\t\tconst result = { report: report, report_tests: reportTests };\n\n\t\t\t\t// Return the sampleReport\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Throw an error if the sample_report_id is invalid\n\t\t\tthrow new Error('Invalid sample_report_id');\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - SampleReport.fromSample() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\t// Load the sampleReport data: check initialized\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\t// Handle the error\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - SampleReport.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass TestReport {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tasync get() {\n\t\ttry {\n\t\t\t// Check if the testReport id is valid\n\t\t\tif (Number.isInteger(this.id) && this.id >= 0) {\n\t\t\t\t// Get the testReport from the database\n\t\t\t\tconst testReport = await this.#layer0.getSampleReportTest(this.id);\n\n\t\t\t\t// initialize the testReport class with the data from the database\n\t\t\t\tObject.assign(this, testReport);\n\t\t\t\tthis.#initialized = true;\n\n\t\t\t\t// Return the testReport\n\t\t\t\treturn testReport;\n\t\t\t}\n\n\t\t\t// Throw an error if the testReport id is invalid\n\t\t\tthrow new Error('Invalid testReport id');\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Create a new testReport in the database\n\t\t\tconst testReport = await global.get('layer0').newSampleReportTest(data);\n\n\t\t\t// Return the new testReport\n\t\t\treturn testReport;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - TestReport.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync set(testReport) {\n\t\t// Load the testReport data: check initialized\n\t\tawait this.#lazyLoader();\n\t\ttry {\n\t\t\t// Set the testReport id\n\t\t\ttestReport.id = this.id;\n\n\t\t\t// Update the testReport in the database\n\t\t\tconst updatedTestReport = await this.#layer0.setSampleReportTest(testReport);\n\n\t\t\t// Return the updated testReport\n\t\t\treturn updatedTestReport;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tasync del() {\n\t\t// Load the testReport data: check initialized\n\t\tawait this.#lazyLoader();\n\n\t\ttry {\n\t\t\t// Delete the testReport from the database\n\t\t\tconst deletedTestReport = await this.#layer0.delSampleReportTest(this.id);\n\n\t\t\t// Return the deleted testReport\n\t\t\treturn deletedTestReport;\n\t\t} catch (error) {\n\t\t\treturn this.#handleError(error);\n\t\t}\n\t}\n\n\tstatic async fromSampleReport(sample_report_test_id) {\n\t\t/**\n\t\t * input: sample_report_test_id Number\n\t\t * output: return test_reports with sample_report_test_id\n\t\t */\n\t\ttry {\n\t\t\tif (Number.isInteger(sample_report_test_id) && sample_report_test_id >= 0) {\n\t\t\t\tconst query = `SELECT * FROM sample_report_tests WHERE sample_report_id = $1`;\n\t\t\t\tconst params = [sample_report_test_id];\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\t\tlet testReports = results.rows;\n\n\t\t\t\ttestReports = JSON.parse(JSON.stringify(testReports));\n\n\t\t\t\tif (testReports && Array.isArray(testReports) && testReports.length === 0) return [];\n\n\t\t\t\treturn testReports;\n\t\t\t}\n\t\t\tthrow new Error('Invalid sample_report_test_id');\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - TestReport.fromSample() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\t// Load the testReport data: check initialized\n\t\tif (this.#initialized) return;\n\t\tawait this.get();\n\t}\n\n\t#handleError(error) {\n\t\t// Handle the error\n\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - TestReport.get() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass UserLabRole {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Create a new userLabRole in the database\n\t\t\tconst userLabRole = await global.get('layer0').newLabRole(data);\n\n\t\t\t// Return the new userLabRole\n\t\t\treturn userLabRole;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - UserLabRole.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async fromUser(user_lab_role_user_id) {\n\t\t/**\n\t\t * input: user_lab_role_user_id Number\n\t\t * output: return user_lab_role with user_lab_role_user_id\n\t\t */\n\t\ttry {\n\t\t\t// Check if the user_lab_role_user_id is valid\n\t\t\tif (Number.isInteger(user_lab_role_user_id) && user_lab_role_user_id >= 0) {\n\t\t\t\t// Get the userLabRole from the database\n\t\t\t\tconst query = `SELECT * FROM user_lab_roles WHERE user_id = $1`;\n\t\t\t\tconst params = [user_lab_role_user_id];\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\n\t\t\t\t// Get the userLabRole from the results\n\t\t\t\tlet userLabRoles = results.rows;\n\n\t\t\t\t// return empty array if there are no userLabRoles\n\t\t\t\tif (userLabRoles && Array.isArray(userLabRoles) && userLabRoles.length === 0) return [];\n\n\t\t\t\t// Return the userLabRole\n\t\t\t\treturn userLabRoles;\n\t\t\t}\n\t\t\tthrow new Error('Invalid user_lab_role_user_id');\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - UserLabRole.fromUser() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nclass UserDept {\n\t#initialized = false;\n\t#layer0 = global.get('layer0');\n\t#repoClient = global.get('repoClient');\n\n\tconstructor(id) {\n\t\tthis.id = id;\n\t}\n\n\tstatic async new(data) {\n\t\ttry {\n\t\t\t// Create a new userDept in the database\n\t\t\tconst userDept = await global.get('layer0').newUserDept(data);\n\n\t\t\t// Return the new userDept\n\t\t\treturn userDept;\n\t\t} catch (error) {\n\t\t\t// Handle the error\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - UserDept.new() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async fromUser(user_id) {\n\t\ttry {\n\t\t\t// Check if the user_id is valid\n\t\t\tif (Number.isInteger(user_id) && user_id >= 0) {\n\t\t\t\tconst query = `SELECT * FROM user_depts WHERE user_id = $1`;\n\t\t\t\tconst params = [user_id];\n\n\t\t\t\t// Execute the query\n\t\t\t\tconst results = await global.get('repoClient').query(query, params);\n\t\t\t\tlet userDepts = results.rows;\n\n\t\t\t\t// return empty array if there are no userDepts\n\t\t\t\tif (userDepts && Array.isArray(userDepts) && userDepts.length === 0) return [];\n\n\t\t\t\t// Return the userDepts\n\t\t\t\treturn userDepts;\n\t\t\t}\n\n\t\t\t// Throw an error if the user_id is invalid\n\t\t\tthrow new Error('Invalid user_id');\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] @layer1.js - UserDept.fromUser() - ${error}`);\n\t\t\tnode.warn(error);\n\t\t\t// API response\n\t\t\terror.statusCode = 500; // Internal Server Error\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n// export classes\nconst tables = {\n\tReceipt,\n\tSample,\n\tTest,\n\tClient,\n\tTestOrder,\n\tUser,\n\tReceiptPrice,\n\tLibProtocol,\n\tLibDept,\n\tSamplePrice,\n\tLibLab,\n\tSampleReport,\n\tTestReport,\n\tUserLabRole,\n\tUserDept,\n};\n\nglobal.set('tables', tables);\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "class Receipt {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    async get() {\n        try {\n            if (Number.isInteger(this.id) && this.id >= 0) {\n                const receipt = await this.#layer0.getReceipt(this.id);\n                Object.assign(this, receipt);\n                this.#initialized = true;\n                return receipt;\n            }\n            throw new Error('Invalid receipt id');\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    async set(receipt) {\n        await this.#lazyLoader();\n        try {\n            return await this.#layer0.setReceipt(this.id, receipt);\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    static async new(data) {\n        try {\n            const receipt = await global.get('layer0').newReceipt(data);\n            return receipt;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Receipt.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async recentReceipts(data) {\n        /** 1. Query recent receipts */\n\n        const query = `\n            SELECT *\n            FROM receipts r\n            WHERE EXISTS (\n                SELECT 1 \n                FROM samples s \n                WHERE r.id = s.sample_receipt_id AND s.status < 4 ${data.receipt_id ? `AND r.id = ${data.receipt_id}` : ''\n            } ${data.sample_id ? `AND s.id = ${data.sample_id}` : ''}\n            ) \n            ORDER BY r.receipt_uid DESC\n        `;\n\n        let receipts = await global.get('repoClient').query(query);\n\n        receipts = JSON.parse(JSON.stringify(receipts.rows));\n\n        for (const receipt of receipts) {\n            /**2. Query get Receipt by user */\n            receipt.receipt_by_user = await User.fromReceipt(receipt.receipt_by_user_id);\n\n            /**3. Query get Client by receipt */\n            receipt.client = await Client.fromReceipt(receipt.client_id);\n\n            /**4. Query get ReceiptPrice by receipt */\n            receipt.receipt_prices = await ReceiptPrice.fromReceipt(receipt.id);\n\n            /**5. Query get Samples by receipt */\n            receipt.samples = await Sample.fromReceipt(receipt.id);\n\n            for (const sample of receipt.samples) {\n                /**6. Query get User by sample */\n                if (sample.created_by_id && sample.created_by_id >= 0) {\n                    sample.created_by = await User.fromSample(sample.created_by_id);\n                } else {\n                    sample.created_by = null;\n                }\n\n                /**7. Query get Test by sample */\n                sample.test_orders = await TestOrder.fromSample(sample.id);\n\n                for (const test_order of sample.test_orders) {\n                    /**9. Query get LibProtocol by test_order */\n                    test_order.protocol = await LibProtocol.fromTestOrder(test_order.protocol_id);\n\n                    /**10. Query get LibDept by test_order */\n                    test_order.assigned_to_dept = await LibDept.fromTestOrder(test_order.assigned_to_dept_id);\n\n                    /**11. Query get LibLab by lib_dept */\n                    if (test_order.assigned_to_dept !== null) {\n                        test_order.assigned_to_dept.lab = await LibLab.fromLibDept(test_order.assigned_to_dept.lab_id);\n                    }\n                }\n\n                /**12. Query get SamplePrice by sample */\n                sample.sample_prices = await SamplePrice.fromSample(sample.id);\n\n                sample.report = [];\n            }\n        }\n\n        return receipts;\n    }\n\n    static async getDashboardData() {\n        const receipts = await Receipt.recentReceipts();\n        let dashboardData = [];\n\n        receipts.forEach((receipt) => {\n            let data = {\n                receipt_uid: receipt.receipt_uid,\n                client_name: receipt.client_name,\n                receipt_date: receipt.receipt_date,\n                receipt_by: receipt.receipt_by_user_id,\n                samples: [],\n            };\n\n            receipt.samples.forEach((sample) => {\n                let sampleData = {\n                    sample_uid: sample.sample_uid,\n                    sample_name: sample.sample_name,\n                    commencement_time: sample.commencement_time,\n                    status: ['ang ch', 'Thng', 'Nhanh', 'Khn', 'Hon thnh'][sample.status],\n                    progress: `${sample.tests.filter((test) => test.test_status === 4).length}/${sample.tests.filter((test) => test.assigned_to_dept_id).length\n                        }/${sample.tests.length}`,\n                };\n                data.samples.push(sampleData);\n            });\n\n            dashboardData.push(data);\n        });\n\n        return dashboardData;\n    }\n\n    async #lazyLoader() {\n        if (this.#initialized) return;\n        await this.get();\n    }\n\n    #handleError(error) {\n        console.error(error);\n        return null;\n    }\n}\n\nclass Sample {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    async get() {\n        try {\n            if (Number.isInteger(this.id) && this.id >= 0) {\n                const sample = await this.#layer0.getSample(this.id);\n                Object.assign(this, sample);\n                this.#initialized = true;\n                return sample;\n            }\n            throw new Error('Invalid sample id');\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    async set(sample) {\n        await this.#lazyLoader();\n        try {\n            return await this.#layer0.setSample(this.id, sample);\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    static async new(data) {\n        try {\n            const sample = await global.get('layer0').newSample(data);\n            return sample;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromReceipt(sample_receipt_id) {\n        try {\n            if (Number.isInteger(sample_receipt_id) && sample_receipt_id >= 0) {\n                const query = `SELECT * FROM samples WHERE sample_receipt_id = $1`;\n                const params = [sample_receipt_id];\n                const results = await global.get('repoClient').query(query, params);\n                let samples = results.rows;\n\n                samples = JSON.parse(JSON.stringify(samples));\n\n                if (samples && Array.isArray(samples) && samples.length === 0) return [];\n\n                return samples;\n            }\n            throw new Error('Invalid sample_receipt_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.fromReceipt() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    async #lazyLoader() {\n        if (this.#initialized) return;\n        await this.get();\n    }\n\n    #handleError(error) {\n        node.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.get() - ${error}`);\n        node.warn(error);\n        // API response\n        error.statusCode = 500; // Internal Server Error\n        error.errorMessage = 'Internal Server Error';\n        throw error;\n    }\n}\n\nclass Test {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    async get() {\n        try {\n            if (Number.isInteger(this.id) && this.id >= 0) {\n                const test = await this.#layer0.getTest(this.id);\n                Object.assign(this, test);\n                this.#initialized = true;\n                return test;\n            }\n            throw new Error('Invalid test id');\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    async set(test) {\n        await this.#lazyLoader();\n        try {\n            return await this.#layer0.setTest(this.id, test);\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    static async new(data) {\n        try {\n            const test = await global.get('layer0').newTest(data);\n            return test;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Test.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromSample(sample_id) {\n        try {\n            if (Number.isInteger(sample_id) && sample_id >= 0) {\n                const query = `SELECT id FROM test_order WHERE sample_id = $1`;\n                const params = [sample_id];\n                const results = await global.get('repoClient').query(query, params);\n                const tests = results.rows;\n\n                if (tests && Array.isArray(tests) && tests.length === 0) return [];\n\n                return Promise.all(\n                    tests.map(async (test) => {\n                        const newInstance = new Test(test.id);\n                        return await newInstance.get();\n                    }),\n                );\n            }\n            throw new Error('Invalid sample id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Test.fromSample() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    async #lazyLoader() {\n        if (this.#initialized) return;\n        await this.get();\n    }\n\n    #handleError(error) {\n        node.warn(`[ CAUGHT ERROR ] @layer1.js - Test.get() - ${error}`);\n        node.warn(error);\n        // API response\n        error.statusCode = 500; // Internal Server Error\n        error.errorMessage = 'Internal Server Error';\n        throw error;\n    }\n}\n\nclass TestOrder {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    async get() {\n        try {\n            if (Number.isInteger(this.id) && this.id >= 0) {\n                const testOrder = await this.#layer0.getTestOrder(this.id);\n                Object.assign(this, testOrder);\n                this.#initialized = true;\n                return testOrder;\n            }\n            throw new Error('Invalid testOrder id');\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    async set(testOrder) {\n        await this.#lazyLoader();\n        try {\n            return await this.#layer0.setTestOrder(this.id, testOrder);\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    static async new(data) {\n        try {\n            const testOrder = await global.get('layer0').newTestOrder(data);\n            return testOrder;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - TestOrder.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromSample(sample_id) {\n        try {\n            if (Number.isInteger(sample_id) && sample_id >= 0) {\n                const query = `SELECT * FROM test_order WHERE sample_id = $1`;\n                const params = [sample_id];\n                const results = await global.get('repoClient').query(query, params);\n                let tests = results.rows;\n\n                tests = JSON.parse(JSON.stringify(tests));\n\n                if (tests && Array.isArray(tests) && tests.length === 0) return [];\n\n                return tests;\n            }\n            throw new Error('Invalid sample id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - TestOrder.fromTest() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    async #lazyLoader() {\n        if (this.#initialized) return;\n        await this.get();\n    }\n\n    #handleError(error) {\n        node.warn(`[ CAUGHT ERROR ] @layer1.js - TestOrder.get() - ${error}`);\n        node.warn(error);\n        // API response\n        error.statusCode = 500; // Internal Server Error\n        error.errorMessage = 'Internal Server Error';\n        throw error;\n    }\n}\n\nclass Client {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const client = await global.get('layer0').newClient(data);\n            return client;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Client.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromReceipt(receipt_client_id) {\n        try {\n            if (Number.isInteger(receipt_client_id) && receipt_client_id >= 0) {\n                const query = `SELECT * FROM clients WHERE id = $1`;\n                const params = [receipt_client_id];\n                const results = await global.get('repoClient').query(query, params);\n                let clients = results.rows;\n\n                clients = JSON.parse(JSON.stringify(clients));\n\n                if (clients && Array.isArray(clients) && clients.length === 0) return [];\n\n                return clients[0];\n            }\n            throw new Error('Invalid receipt_client_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Client.fromReceipt() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass User {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const user = await global.get('layer0').newUser(data);\n            return user;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - User.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromReceipt(receipt_by_user_id) {\n        try {\n            if (Number.isInteger(receipt_by_user_id) && receipt_by_user_id >= 0) {\n                const query = `SELECT * FROM users WHERE id = $1`;\n                const params = [receipt_by_user_id];\n                const results = await global.get('repoClient').query(query, params);\n                let users = results.rows;\n\n                users = JSON.parse(JSON.stringify(users));\n\n                if (users && Array.isArray(users) && users.length === 0) return [];\n\n                return users[0];\n            }\n            throw new Error('Invalid receipt_by_user_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - User.fromReceipt() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromSample(sample_by_user_id) {\n        try {\n            if (Number.isInteger(sample_by_user_id) && sample_by_user_id >= 0) {\n                const query = `SELECT * FROM users WHERE id = $1`;\n                const params = [sample_by_user_id];\n                const results = await global.get('repoClient').query(query, params);\n                let users = results.rows;\n\n                users = JSON.parse(JSON.stringify(users));\n\n                if (users && Array.isArray(users) && users.length === 0) return [];\n\n                return users[0];\n            }\n            throw new Error(`Invalid sample_by_user_id: ${sample_by_user_id}`);\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - User.fromSample() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass ReceiptPrice {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const receiptPrice = await global.get('layer0').newReceiptPrice(data);\n            return receiptPrice;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - ReceiptPrice.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromReceipt(receipt_price_id) {\n        try {\n            if (Number.isInteger(receipt_price_id) && receipt_price_id >= 0) {\n                const query = `SELECT * FROM receipt_prices WHERE sample_receipt_id = $1`;\n                const params = [receipt_price_id];\n                const results = await global.get('repoClient').query(query, params);\n                let receiptPrices = results.rows;\n\n                receiptPrices = JSON.parse(JSON.stringify(receiptPrices));\n\n                if (receiptPrices && Array.isArray(receiptPrices) && receiptPrices.length === 0) return [];\n\n                return receiptPrices[0];\n            }\n            throw new Error('Invalid receipt_price_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - ReceiptPrice.fromReceipt() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass LibProtocol {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const libProtocol = await global.get('layer0').newLibProtocol(data);\n            return libProtocol;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibProtocol.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromTestOrder(test_order_protocol_id) {\n        try {\n            if (Number.isInteger(test_order_protocol_id) && test_order_protocol_id >= 0) {\n                const query = `SELECT * FROM lib_protocols WHERE id = $1`;\n                const params = [test_order_protocol_id];\n                const results = await global.get('repoClient').query(query, params);\n                let libProtocols = results.rows;\n\n                libProtocols = JSON.parse(JSON.stringify(libProtocols));\n\n                if (libProtocols && Array.isArray(libProtocols) && libProtocols.length === 0) return null;\n\n                return libProtocols[0];\n            }\n            throw new Error(`Invalid test_order_protocol_id: ${test_order_protocol_id}`);\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibProtocol.fromTestOrder() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass LibDept {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const libDept = await global.get('layer0').newLibDept(data);\n            return libDept;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibDept.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromTestOrder(test_order_assigned_to_dept_id) {\n        try {\n            if (Number.isInteger(test_order_assigned_to_dept_id) && test_order_assigned_to_dept_id >= 0) {\n                const query = `SELECT * FROM lib_dept WHERE id = $1`;\n                const params = [test_order_assigned_to_dept_id];\n                const results = await global.get('repoClient').query(query, params);\n                let libDepts = results.rows;\n\n                libDepts = JSON.parse(JSON.stringify(libDepts));\n\n                if (libDepts && Array.isArray(libDepts) && libDepts.length === 0) return null;\n\n                return libDepts[0];\n            }\n            throw new Error(`Invalid test_order_assigned_to_dept_id: ${test_order_assigned_to_dept_id}`);\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibDept.fromTestOrder() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass SamplePrice {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const samplePrice = await global.get('layer0').newSamplePrice(data);\n            return samplePrice;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - SamplePrice.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromSample(sample_price_id) {\n        try {\n            if (Number.isInteger(sample_price_id) && sample_price_id >= 0) {\n                const query = `SELECT * FROM sample_prices WHERE sample_id = $1`;\n                const params = [sample_price_id];\n                const results = await global.get('repoClient').query(query, params);\n                let samplePrices = results.rows;\n\n                samplePrices = JSON.parse(JSON.stringify(samplePrices));\n\n                if (samplePrices && Array.isArray(samplePrices) && samplePrices.length === 0) return [];\n\n                return samplePrices[0];\n            }\n            throw new Error('Invalid sample_price_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - SamplePrice.fromSample() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass LibLab {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const libLab = await global.get('layer0').newLibLab(data);\n            return libLab;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibLab.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromLibDept(lib_dept_lab_id) {\n        try {\n            if (Number.isInteger(lib_dept_lab_id) && lib_dept_lab_id >= 0) {\n                const query = `SELECT * FROM lib_lab WHERE id = $1`;\n                const params = [lib_dept_lab_id];\n                const results = await global.get('repoClient').query(query, params);\n                let libLabs = results.rows;\n\n                libLabs = JSON.parse(JSON.stringify(libLabs));\n\n                if (libLabs && Array.isArray(libLabs) && libLabs.length === 0) return null;\n\n                return libLabs[0];\n            } else if (lib_dept_lab_id === null) {\n                return null;\n            }\n            throw new Error('Invalid lib_dept_lab_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibLab.fromLibDept() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\n// export classes\nconst tables = {\n    Receipt,\n    Sample,\n    Test,\n    Client,\n    TestOrder,\n    User,\n    ReceiptPrice,\n    LibProtocol,\n    LibDept,\n    SamplePrice,\n    LibLab,\n};\n\nglobal.set('tables', tables);\n",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 450,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "9b8fef1d3325f9e0",
        "type": "comment",
        "z": "5fb64aedc3e2bcf3",
        "name": "postgres.sql origin",
        "info": "CREATE TABLE IF NOT EXISTS clients (\n    id              SERIAL PRIMARY KEY,\n    client_name     TEXT,\n    client_uid      TEXT,\n    code            TEXT,\n    address         TEXT,\n    email           TEXT,\n    phone           TEXT,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    notes           TEXT    \n);\n\nCREATE TABLE IF NOT EXISTS users (\n    id              SERIAL PRIMARY KEY,\n    user_uid        TEXT,\n    name            TEXT NOT NULL UNIQUE,\n    password        TEXT,\n    email           TEXT NOT NULL UNIQUE,\n    phone           TEXT,\n    disabled        BOOLEAN NOT NULL DEFAULT FALSE,\n    employee        BOOLEAN NOT NULL DEFAULT FALSE,\n    org_admin       BOOLEAN NOT NULL DEFAULT FALSE,\n    force_reset_pw  BOOLEAN NOT NULL DEFAULT FALSE,\n    force_sign_out  BOOLEAN NOT NULL DEFAULT FALSE,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS lib_lab (\n    id              SERIAL PRIMARY KEY,\n    lab_name        TEXT,\n    code            TEXT,\n    address         TEXT,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS lib_sale (\n    id                      SERIAL PRIMARY KEY,\n    sale_name               TEXT,\n    sale_payment_infor      TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS lib_dept (\n    id              SERIAL PRIMARY KEY,\n    dept_name       TEXT,\n    lab_id          INTEGER NOT NULL,\n    is_lab          BOOL NOT NULL DEFAULT FALSE,\n    priority        INTEGER NOT NULL DEFAULT 0,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (lab_id) REFERENCES lib_lab(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS lib_protocols (\n    id                      SERIAL PRIMARY KEY,\n    code                    TEXT,\n    name                    TEXT,\n    name_secondary          TEXT,\n    vlas                    BOOLEAN NOT NULL DEFAULT FALSE,\n    modified_by             INTEGER,\n    accreditation_source    TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (modified_by) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS receipts (\n    id                              SERIAL PRIMARY KEY,\n    receipt_uid                     TEXT,\n    client_id                       INTEGER ,\n    receipt_by_lab_id               INTEGER NOT NULL,\n    receipt_by_user_id              INTEGER NOT NULL,\n    receipt_date                    DATE,\n    commencement_date               DATE,\n    eta_days                        INTEGER,\n    archived                        BOOLEAN NOT NULL DEFAULT FALSE,\n    note                            TEXT,\n    ppt_copies                      INTEGER,\n    submission_person_name          TEXT,\n    submission_courier_name         TEXT,\n    report_method_in_person         BOOLEAN NOT NULL DEFAULT FALSE,\n    report_method_courier_address   TEXT,\n    report_method_email             TEXT,\n    report_method_zalo              TEXT,\n    contact_person_name             TEXT,\n    contact_person_phone            TEXT,\n    contact_person_email            TEXT,\n    created_at                      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS samples (\n    id                      SERIAL PRIMARY KEY,\n    sample_uid              TEXT,\n    sample_name             TEXT,\n    sample_receipt_id       INTEGER NOT NULL,\n    sample_name_secondary   TEXT,\n    sample_lot              TEXT,\n    sample_mfg              DATE,\n    sample_exp              DATE,\n    sample_mfr              TEXT,\n    sample_qty              TEXT,\n    sample_seal             TEXT,\n    sample_desc             TEXT,\n    note                    TEXT,\n    sample_category         TEXT,\n    secondary_language      BOOLEAN NOT NULL DEFAULT FALSE,\n    test_purpose            TEXT,\n    created_by_id           INTEGER,\n    commencement_time       TIMESTAMP,\n    modified_at             TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_id          INTEGER ,\n    ppt_copies              INTEGER,\n    deleted                 BOOLEAN NOT NULL DEFAULT FALSE,\n    sample_deadline         DATE,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    status                  INTEGER,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (created_by_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (modified_by_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS tests (\n    id                      SERIAL PRIMARY KEY,\n    test_name               TEXT,\n    protocol_id             INTEGER ,\n    modified_by_id          INTEGER,\n    test_name_secondary     TEXT,\n    result_unit             TEXT,\n    protocol_source         TEXT,\n    fee                     DOUBLE PRECISION,\n    modified_at             TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    vlas                    BOOLEAN NOT NULL DEFAULT FALSE,\n    created_at              TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    dept_id                 INTEGER,\n    FOREIGN KEY (protocol_id) REFERENCES lib_protocols(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (modified_by_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (dept_id) REFERENCES lib_dept(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_prices (\n    id                      SERIAL PRIMARY KEY,\n    sample_id               INTEGER NOT NULL,\n    sample_receipt_id       INTEGER NOT NULL,\n    gross                   INTEGER,\n    premium                 INTEGER,\n    premium_rate            DOUBLE PRECISION,\n    discount                INTEGER,\n    discount_rate           DOUBLE PRECISION,\n    net                     INTEGER,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_report (\n    id                              SERIAL PRIMARY KEY,\n    modified_at                     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_id                  INTEGER ,\n    report_uid                      TEXT,\n    published_date                  DATE,\n    sample_id                       INTEGER NOT NULL,\n    sample_receipt_id               INTEGER ,\n    title                           TEXT,\n    title_eng                       TEXT,\n    sample_uid                      TEXT,\n    sample_prices_id                INTEGER,\n    format_is_vlas_logo             BOOLEAN NOT NULL DEFAULT FALSE,\n    client_uid                      TEXT,\n    client_section_title_left       TEXT,\n    client_section_title_right      TEXT,\n    sample_name                     TEXT,\n    sample_name_secondary           TEXT,\n    sample_lot                      TEXT,\n    sample_mfg                      TEXT,\n    sample_exp                      TEXT,\n    sample_mfr                      TEXT,\n    receipt_date                    DATE,\n    sample_desc                     TEXT,\n    format_is_std_ref               BOOLEAN NOT NULL DEFAULT FALSE,\n    test_comments                   TEXT,\n    test_notes                      TEXT,\n    signer_fist_title              TEXT,\n    signer_first_name               TEXT,\n    signer_second_title             TEXT,\n    signer_second_name              TEXT,\n    test_table_row_num              TEXT,\n    test_table_row_num_eng          TEXT,\n    test_table_protocol             TEXT,\n    test_table_protocol_eng         TEXT,\n    test_table_std_ref              TEXT,\n    test_table_std_ref_eng          TEXT,\n    test_table_unit                 TEXT,\n    test_table_unit_eng             TEXT,\n    test_table_result               TEXT,\n    test_table_result_eng           TEXT,\n    comment_title                   TEXT,\n    format_is_comment               BOOLEAN NOT NULL DEFAULT FALSE,\n    comment_detail                  TEXT,\n    test_note_title                 TEXT,\n    test_note_detail                TEXT,\n    created_at                      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_prices_id) REFERENCES sample_prices(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (modified_by_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS test_order (\n    id                      SERIAL PRIMARY KEY,\n    sample_id               INTEGER ,\n    sample_receipt_id       INTEGER ,\n    test_name               TEXT,\n    test_name_secondary     TEXT,\n    lib_test_id             INTEGER,\n    std_ref                 TEXT,\n    fee                     DOUBLE PRECISION,\n    protocol_id             INTEGER,\n    protocol_source         TEXT,\n    vlas                    BOOLEAN NOT NULL DEFAULT FALSE,\n    result_unit             TEXT,\n    result_value            TEXT,\n    outsourced              BOOLEAN NOT NULL DEFAULT FALSE,\n    protocol_value          TEXT,\n    assigned_to_user_id     INTEGER ,\n    assigned_to_dept_id     INTEGER ,\n    result_note             TEXT,\n    result_deadline         DATE,  \n    result_submitted_by_id  INTEGER,\n    result_submitted_at     TIMESTAMP,\n    deleted                 BOOLEAN NOT NULL DEFAULT FALSE,\n    tested_by_user_id       INTEGER ,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (lib_test_id) REFERENCES tests(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (protocol_id) REFERENCES lib_protocols(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (assigned_to_user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (assigned_to_dept_id) REFERENCES lib_dept(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (tested_by_user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_report_tests (\n    id                      SERIAL PRIMARY KEY,\n    sample_report_id        INTEGER ,\n    sample_id               INTEGER ,\n    sample_receipt_id       INTEGER,\n    test_order_id           INTEGER ,\n    test_name               TEXT,\n    protocol_id             INTEGER ,\n    protocol_value          TEXT,\n    vlas                    BOOLEAN NOT NULL DEFAULT FALSE,\n    external                BOOLEAN NOT NULL DEFAULT FALSE,\n    lab_id                  INTEGER ,\n    std_ref                 TEXT,\n    result_unit             TEXT,\n    result_value            TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_report_id) REFERENCES sample_report(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (test_order_id) REFERENCES test_order(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (protocol_id) REFERENCES lib_protocols(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (lab_id) REFERENCES lib_lab(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_transfer_report (\n    id                      SERIAL PRIMARY KEY,\n    created_by_user_id      INTEGER NOT NULL,\n    report_uid              TEXT,\n    report_date             DATE,\n    location                TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_transfer_tests (\n    id                      SERIAL PRIMARY KEY,\n    transfer_report_id      INTEGER NOT NULL,\n    sample_id               INTEGER NOT NULL,\n    test_order_id           INTEGER NOT NULL,\n    recipient_user_id       INTEGER NOT NULL,\n    deadline                DATE,\n    note                    TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (transfer_report_id) REFERENCES sample_transfer_report(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (test_order_id) REFERENCES test_order(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (recipient_user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS receipt_prices (\n    id                      SERIAL PRIMARY KEY,\n    sample_receipt_id       INTEGER NOT NULL,\n    gross                   INTEGER,\n    premium                 INTEGER,\n    premium_rate            DOUBLE PRECISION,\n    discount                INTEGER,\n    discount_rate           DOUBLE PRECISION,\n    tax                     INTEGER,\n    tax_rate                DOUBLE PRECISION,\n    payable                 INTEGER,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS test_results (\n    id                      SERIAL PRIMARY KEY,\n    sample_id               INTEGER NOT NULL,\n    sample_receipt_id       INTEGER NOT NULL,\n    test_order_id           INTEGER NOT NULL,\n    std_ref                 TEXT,\n    result_value            TEXT,\n    unit                    TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (test_order_id) REFERENCES test_order(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS user_depts (\n    id              SERIAL PRIMARY KEY,\n    user_id         INTEGER NOT NULL,\n    dept_id         INTEGER NOT NULL,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (dept_id) REFERENCES lib_dept(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS user_lab_roles (\n    id              SERIAL PRIMARY KEY,\n    user_id         INTEGER NOT NULL,\n    lab_id          INTEGER ,\n    sample_manager  BOOLEAN NOT NULL DEFAULT FALSE,\n    test_manager    BOOLEAN NOT NULL DEFAULT FALSE,\n    finance_manager BOOLEAN NOT NULL DEFAULT FALSE,\n    org_admin       BOOLEAN NOT NULL DEFAULT FALSE,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (lab_id) REFERENCES lib_lab(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS user_event_logs (\n    id              SERIAL PRIMARY KEY,\n    user_id         INTEGER NOT NULL,\n    context         TEXT,\n    function        TEXT,\n    message         TEXT,\n    data            JSON,\n    time            TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS receipt_sales (\n    id                      SERIAL PRIMARY KEY,\n    sample_receipt_id       INTEGER NOT NULL,\n    sample_id               INTEGER NOT NULL,\n    sale_id                 INTEGER NOT NULL,\n    commission_percent      DOUBLE PRECISION,\n    commission_value        DOUBLE PRECISION,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- Ch mc cho bng lib_dept\nCREATE INDEX idx_lib_dept_lab_id ON lib_dept(lab_id);\nCREATE INDEX idx_lib_dept_is_lab ON lib_dept(is_lab);\nCREATE INDEX idx_lib_dept_priority ON lib_dept(priority);\n\n-- Ch mc cho bng lib_protocols\nCREATE INDEX idx_lib_protocols_modified_by ON lib_protocols(modified_by);\n\n-- Ch mc cho bng lib_lab\nCREATE INDEX idx_lib_lab_code ON lib_lab(code);\n\n-- Ch mc cho bng tests\nCREATE INDEX idx_tests_protocol_id ON tests(protocol_id);\nCREATE INDEX idx_tests_modified_by_id ON tests(modified_by_id);\nCREATE INDEX idx_tests_dept_id ON tests(dept_id);\n\n-- Ch mc cho bng receipt_sales\nCREATE INDEX idx_receipt_sales_sample_receipt_id ON receipt_sales(sample_receipt_id);\nCREATE INDEX idx_receipt_sales_sample_id ON receipt_sales(sample_id);\nCREATE INDEX idx_receipt_sales_sale_id ON receipt_sales(sale_id);\n\n-- Ch mc cho bng sample\nCREATE INDEX idx_sample_sample_receipt_id ON samples(sample_receipt_id);\nCREATE INDEX idx_sample_created_by_id ON samples(created_by_id);\nCREATE INDEX idx_sample_modified_by_id ON samples(modified_by_id);\nCREATE INDEX idx_sample_status ON samples(status);\n\n-- Ch mc cho bng sample_prices\nCREATE INDEX idx_sample_prices_sample_id ON sample_prices(sample_id);\nCREATE INDEX idx_sample_prices_sample_receipt_id ON sample_prices(sample_receipt_id);\n\n-- Ch mc cho bng sample_receipt\nCREATE INDEX idx_sample_receipt_client_id ON receipts(client_id);\nCREATE INDEX idx_sample_receipt_receipt_by_lab_id ON receipts(receipt_by_lab_id);\nCREATE INDEX idx_sample_receipt_receipt_by_user_id ON receipts(receipt_by_user_id);\n\n-- Ch mc cho bng receipt_prices\nCREATE INDEX idx_receipt_prices_sample_receipt_id ON receipt_prices(sample_receipt_id);\n\n-- Ch mc cho bng sample_report\nCREATE INDEX idx_sample_report_sample_id ON sample_report(sample_id);\nCREATE INDEX idx_sample_report_sample_receipt_id ON sample_report(sample_receipt_id);\nCREATE INDEX idx_sample_report_sample_prices_id ON sample_report(sample_prices_id);\n\n-- Ch mc cho bng sample_report_tests\nCREATE INDEX idx_sample_report_tests_sample_report_id ON sample_report_tests(sample_report_id);\nCREATE INDEX idx_sample_report_tests_sample_id ON sample_report_tests(sample_id);\nCREATE INDEX idx_sample_report_tests_test_order_id ON sample_report_tests(test_order_id);\nCREATE INDEX idx_sample_report_tests_protocol_id ON sample_report_tests(protocol_id);\nCREATE INDEX idx_sample_report_tests_lab_id ON sample_report_tests(lab_id);\n\n-- Ch mc cho bng sample_transfer_report\nCREATE INDEX idx_sample_transfer_report_created_by_user_id ON sample_transfer_report(created_by_user_id);\n\n-- Ch mc cho bng sample_transfer_tests\nCREATE INDEX idx_sample_transfer_tests_transfer_report_id ON sample_transfer_tests(transfer_report_id);\nCREATE INDEX idx_sample_transfer_tests_sample_id ON sample_transfer_tests(sample_id);\nCREATE INDEX idx_sample_transfer_tests_recipient_user_id ON sample_transfer_tests(recipient_user_id);\n\n-- Ch mc cho bng test_order\nCREATE INDEX idx_test_order_sample_id ON test_order(sample_id);\nCREATE INDEX idx_test_order_sample_receipt_id ON test_order(sample_receipt_id);\nCREATE INDEX idx_test_order_lib_test_id ON test_order(lib_test_id);\nCREATE INDEX idx_test_order_protocol_id ON test_order(protocol_id);\nCREATE INDEX idx_test_order_assigned_to_user_id ON test_order(assigned_to_user_id);\nCREATE INDEX idx_test_order_assigned_to_dept_id ON test_order(assigned_to_dept_id);\nCREATE INDEX idx_test_order_tested_by_user_id ON test_order(tested_by_user_id);\n\n-- Ch mc cho bng test_results\nCREATE INDEX idx_test_results_test_order_id ON test_results(test_order_id);\nCREATE INDEX idx_test_results_sample_id ON test_results(sample_id);\nCREATE INDEX idx_test_results_sample_receipt_id ON test_results(sample_receipt_id);\n\n-- Ch mc cho bng user_depts\nCREATE INDEX idx_user_depts_user_id ON user_depts(user_id);\nCREATE INDEX idx_user_depts_dept_id ON user_depts(dept_id);\n\n-- Ch mc cho bng user_lab_roles\nCREATE INDEX idx_user_lab_roles_user_id ON user_lab_roles(user_id);\nCREATE INDEX idx_user_lab_roles_lab_id ON user_lab_roles(lab_id);\n\n-- Ch mc cho bng user_event_logs\nCREATE INDEX idx_user_event_logs_user_id ON user_event_logs(user_id);\nCREATE INDEX idx_user_event_logs_time ON user_event_logs(time);\n\n-- Ch mc cho bng users\n--  to ch mc UNIQUE trong nh ngha bng, khng cn to thm\n\n\n-- Clients table\nCREATE SEQUENCE IF NOT EXISTS clients_id_seq;\nALTER TABLE clients ALTER COLUMN id SET DEFAULT nextval('clients_id_seq'::regclass);\n\n-- Lib_dept table\nCREATE SEQUENCE IF NOT EXISTS lib_dept_id_seq;\nALTER TABLE lib_dept ALTER COLUMN id SET DEFAULT nextval('lib_dept_id_seq'::regclass);\n\n-- Lib_lab table\nCREATE SEQUENCE IF NOT EXISTS lib_lab_id_seq;\nALTER TABLE lib_lab ALTER COLUMN id SET DEFAULT nextval('lib_lab_id_seq'::regclass);\n\n-- Lib_protocols table\nCREATE SEQUENCE IF NOT EXISTS lib_protocols_id_seq;\nALTER TABLE lib_protocols ALTER COLUMN id SET DEFAULT nextval('lib_protocols_id_seq'::regclass);\n\n-- Lib_sale table\nCREATE SEQUENCE IF NOT EXISTS lib_sale_id_seq;\nALTER TABLE lib_sale ALTER COLUMN id SET DEFAULT nextval('lib_sale_id_seq'::regclass);\n\n-- Receipt_prices table\nCREATE SEQUENCE IF NOT EXISTS receipt_prices_id_seq;\nALTER TABLE receipt_prices ALTER COLUMN id SET DEFAULT nextval('receipt_prices_id_seq'::regclass);\n\n-- Receipt_sales table\nCREATE SEQUENCE IF NOT EXISTS receipt_sales_id_seq;\nALTER TABLE receipt_sales ALTER COLUMN id SET DEFAULT nextval('receipt_sales_id_seq'::regclass);\n\n-- Receipts table\nCREATE SEQUENCE IF NOT EXISTS receipts_id_seq;\nALTER TABLE receipts ALTER COLUMN id SET DEFAULT nextval('receipts_id_seq'::regclass);\n\n-- Sample_prices table\nCREATE SEQUENCE IF NOT EXISTS sample_prices_id_seq;\nALTER TABLE sample_prices ALTER COLUMN id SET DEFAULT nextval('sample_prices_id_seq'::regclass);\n\n-- Sample_report table\nCREATE SEQUENCE IF NOT EXISTS sample_report_id_seq;\nALTER TABLE sample_report ALTER COLUMN id SET DEFAULT nextval('sample_report_id_seq'::regclass);\n\n-- Sample_report_tests table\nCREATE SEQUENCE IF NOT EXISTS sample_report_tests_id_seq;\nALTER TABLE sample_report_tests ALTER COLUMN id SET DEFAULT nextval('sample_report_tests_id_seq'::regclass);\n\n-- Sample_transfer_report table\nCREATE SEQUENCE IF NOT EXISTS sample_transfer_report_id_seq;\nALTER TABLE sample_transfer_report ALTER COLUMN id SET DEFAULT nextval('sample_transfer_report_id_seq'::regclass);\n\n-- Sample_transfer_tests table\nCREATE SEQUENCE IF NOT EXISTS sample_transfer_tests_id_seq;\nALTER TABLE sample_transfer_tests ALTER COLUMN id SET DEFAULT nextval('sample_transfer_tests_id_seq'::regclass);\n\n-- Samples table\nCREATE SEQUENCE IF NOT EXISTS samples_id_seq;\nALTER TABLE samples ALTER COLUMN id SET DEFAULT nextval('samples_id_seq'::regclass);\n\n-- Test_order table\nCREATE SEQUENCE IF NOT EXISTS test_order_id_seq;\nALTER TABLE test_order ALTER COLUMN id SET DEFAULT nextval('test_order_id_seq'::regclass);\n\n-- Test_results table\nCREATE SEQUENCE IF NOT EXISTS test_results_id_seq;\nALTER TABLE test_results ALTER COLUMN id SET DEFAULT nextval('test_results_id_seq'::regclass);\n\n-- Tests table\nCREATE SEQUENCE IF NOT EXISTS tests_id_seq;\nALTER TABLE tests ALTER COLUMN id SET DEFAULT nextval('tests_id_seq'::regclass);\n\n-- User_depts table\nCREATE SEQUENCE IF NOT EXISTS user_depts_id_seq;\nALTER TABLE user_depts ALTER COLUMN id SET DEFAULT nextval('user_depts_id_seq'::regclass);\n\n-- User_event_logs table\nCREATE SEQUENCE IF NOT EXISTS user_event_logs_id_seq;\nALTER TABLE user_event_logs ALTER COLUMN id SET DEFAULT nextval('user_event_logs_id_seq'::regclass);\n\n-- User_lab_roles table\nCREATE SEQUENCE IF NOT EXISTS user_lab_roles_id_seq;\nALTER TABLE user_lab_roles ALTER COLUMN id SET DEFAULT nextval('user_lab_roles_id_seq'::regclass);\n\n-- Users table\nCREATE SEQUENCE IF NOT EXISTS users_id_seq;\nALTER TABLE users ALTER COLUMN id SET DEFAULT nextval('users_id_seq'::regclass);\n\n\n-- Clients table\nSELECT setval('clients_id_seq', (SELECT COALESCE(MAX(id), 1) FROM clients));\n\n-- Lib_dept table\nSELECT setval('lib_dept_id_seq', (SELECT COALESCE(MAX(id), 1) FROM lib_dept));\n\n-- Lib_lab table\nSELECT setval('lib_lab_id_seq', (SELECT COALESCE(MAX(id), 1) FROM lib_lab));\n\n-- Lib_protocols table\nSELECT setval('lib_protocols_id_seq', (SELECT COALESCE(MAX(id), 1) FROM lib_protocols));\n\n-- Lib_sale table\nSELECT setval('lib_sale_id_seq', (SELECT COALESCE(MAX(id), 1) FROM lib_sale));\n\n-- Receipt_prices table\nSELECT setval('receipt_prices_id_seq', (SELECT COALESCE(MAX(id), 1) FROM receipt_prices));\n\n-- Receipt_sales table\nSELECT setval('receipt_sales_id_seq', (SELECT COALESCE(MAX(id), 1) FROM receipt_sales));\n\n-- Receipts table\nSELECT setval('receipts_id_seq', (SELECT COALESCE(MAX(id), 1) FROM receipts));\n\n-- Sample_prices table\nSELECT setval('sample_prices_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_prices));\n\n-- Sample_report table\nSELECT setval('sample_report_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_report));\n\n-- Sample_report_tests table\nSELECT setval('sample_report_tests_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_report_tests));\n\n-- Sample_transfer_report table\nSELECT setval('sample_transfer_report_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_transfer_report));\n\n-- Sample_transfer_tests table\nSELECT setval('sample_transfer_tests_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_transfer_tests));\n\n-- Samples table\nSELECT setval('samples_id_seq', (SELECT COALESCE(MAX(id), 1) FROM samples));\n\n-- Test_order table\nSELECT setval('test_order_id_seq', (SELECT COALESCE(MAX(id), 1) FROM test_order));\n\n-- Test_results table\nSELECT setval('test_results_id_seq', (SELECT COALESCE(MAX(id), 1) FROM test_results));\n\n-- Tests table\nSELECT setval('tests_id_seq', (SELECT COALESCE(MAX(id), 1) FROM tests));\n\n-- User_depts table\nSELECT setval('user_depts_id_seq', (SELECT COALESCE(MAX(id), 1) FROM user_depts));\n\n-- User_event_logs table\nSELECT setval('user_event_logs_id_seq', (SELECT COALESCE(MAX(id), 1) FROM user_event_logs));\n\n-- User_lab_roles table\nSELECT setval('user_lab_roles_id_seq', (SELECT COALESCE(MAX(id), 1) FROM user_lab_roles));\n\n-- Users table\nSELECT setval('users_id_seq', (SELECT COALESCE(MAX(id), 1) FROM users));\n\nCREATE EXTENSION IF NOT EXISTS pg_trgm;\n\nSET pg_trgm.similarity_threshold = 0.2;\n\nCREATE OR REPLACE FUNCTION unaccent_text(text)\nRETURNS text AS $$\nBEGIN\n    RETURN translate(\n        LOWER($1),\n        '',\n        'aaaaaaaaaaaaaaaaadeeeeeeeeeeeiiiiiooooooooooooooouuuuuuuuuuuuuyyyyy'\n    );\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE;\n\n",
        "x": 610,
        "y": 60,
        "wires": []
    },
    {
        "id": "43c6cc038cc862be",
        "type": "comment",
        "z": "5fb64aedc3e2bcf3",
        "name": "env",
        "info": "process.env.PG_IRDOP_USER\nprocess.env.PG_IRDOP_HOST\nprocess.env.PG_IRDOP_DB \nprocess.env.PG_IRDOP_PW \nprocess.env.PG_IRDOP_PORT",
        "x": 770,
        "y": 60,
        "wires": []
    },
    {
        "id": "aba66d4af74971cc",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 440,
        "wires": [
            [
                "f1e0bf9ceedc729d"
            ]
        ]
    },
    {
        "id": "f1e0bf9ceedc729d",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SAMPLE_TEST",
        "func": "const tables = global.get('tables');\n\ntry {\n    const testOrders = await tables.TestOrder.fromSample(3573);\n    node.warn(testOrders); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "aa693c4897c0f506",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST RECENT RECEIPTS",
        "func": "const tables = global.get('tables');\n\ntry {\n    const recent_receipts = await tables.Receipt.recentReceipts(); //{receipt_id: 1222}\n    node.warn(recent_receipts); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "1145c77e25c64195",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 360,
        "wires": [
            [
                "aa693c4897c0f506"
            ]
        ]
    },
    {
        "id": "b2433469b1ff917b",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SAMPLE",
        "func": "const tables = global.get('tables');\n\ntry {\n    const testOrders = await tables.Sample.fromReceipt(1207);\n    node.warn(testOrders); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "73c61d0ca82caf7c",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 400,
        "wires": [
            [
                "b2433469b1ff917b"
            ]
        ]
    },
    {
        "id": "8765e4ab39e76fed",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 320,
        "wires": [
            [
                "47b067fc658f5615"
            ]
        ]
    },
    {
        "id": "47b067fc658f5615",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SEARCH TESTS",
        "func": "const tables = global.get('tables');\n\ntry {\n    const search = await tables.Test.searchTests('Zn');\n    node.warn(search); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "17a5a0074caeeb8c",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 240,
        "wires": [
            [
                "31c5d341f4399f5c"
            ]
        ]
    },
    {
        "id": "31c5d341f4399f5c",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST NEW SAMPLE REPORT",
        "func": "const tables = global.get('tables');\n//body: test_data: [{}], report_data: {} \nconst sampleReport = {\n    modified_by_id: 35,                     // Example integer ID for the user who modified it\n    published_date: \"2024-11-12\",          // Date in 'YYYY-MM-DD' format\n    sample_id: 3566,                        // Example integer ID for sample\n    sample_receipt_id: 1220,               // Example integer ID for sample receipt\n    title: \"Sample Report Title\",          // Report title\n    title_eng: \"Sample Report Title (ENG)\",// Report title in English\n    sample_uid: \"SMP-56789\",               // Unique identifier for the sample\n    sample_prices_id: 1220,                // ID for associated sample price\n    format_is_vlas_logo: true,             // Boolean for VLAS logo format\n    client_uid: \"CLNT-0001\",               // Unique client identifier\n    client_section_title_left: \"Client Left\",  // Left section title\n    client_section_title_right: \"Client Right\", // Right section title\n    sample_name: \"Sample Name\",            // Primary sample name\n    sample_name_secondary: \"Sample Name 2\",// Secondary sample name\n    sample_lot: \"LOT12345\",                // Lot number\n    sample_mfg: \"Manufacturing Details\",   // Manufacturing details text\n    sample_exp: \"Expiration Details\",      // Expiration details text\n    sample_mfr: \"Sample Manufacturer\",     // Manufacturer name\n    receipt_date: \"2024-11-10\",            // Date of receipt in 'YYYY-MM-DD' format\n    sample_desc: \"Sample description text\",// Description text\n    format_is_std_ref: false,              // Boolean for standard reference format\n    test_comments: \"Test comments here\",   // Comments about the test\n    test_notes: \"Additional test notes\",   // Additional notes\n    signer_first_title: \"Dr.\",             // Title for the first signer\n    signer_first_name: \"Alice\",            // First name of the first signer\n    signer_second_title: \"Mr.\",            // Title for the second signer\n    signer_second_name: \"Bob\",             // Second name of the second signer\n    test_table_row_num: \"5\",               // Row number for test table\n    test_table_row_num_eng: \"5\",           // Row number in English\n    test_table_protocol: \"Protocol A\",     // Protocol name\n    test_table_protocol_eng: \"Protocol A (ENG)\", // Protocol in English\n    test_table_std_ref: \"STD123\",          // Standard reference\n    test_table_std_ref_eng: \"STD123 (ENG)\",// Standard reference in English\n    test_table_unit: \"mg/L\",               // Test unit\n    test_table_unit_eng: \"mg/L\",           // Unit in English\n    test_table_result: \"Positive\",         // Test result\n    test_table_result_eng: \"Positive\",     // Result in English\n    comment_title: \"Test Comment\",         // Comment title\n    format_is_comment: true,               // Boolean for comment format\n    comment_detail: \"Detailed comment here\",// Comment details\n    test_note_title: \"Note Title\",         // Note title\n    test_note_detail: \"Detail for the note\"// Detail for the note\n};\n\nconst {test_data, report_data} = {test_data: [{id:1}, {id:2}] , report_data:sampleReport}\n\ntry {\n    if(test_data !== null && report_data !== null){\n        // check exist sample\n        if(report_data.sample_id !== null){\n            const instance = new tables.Sample(report_data.sample_id);\n            if (await instance.get() === null ) throw new Error('Sample is not exist');\n            node.warn(JSON.parse(JSON.stringify(instance)));\n            //Insert DB\n            const addSampleReport = await tables.SampleReport.new(sampleReport);\n            node.warn(JSON.parse(JSON.stringify(addSampleReport))); \n        } else  {\n            throw new Error('Sample id is required');\n        }\n    }else{   \n        throw new Error('test_data & report_data is empty');\n    }\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "425d2d2592033e6a",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST NEW TEST REPORT",
        "func": "const tables = global.get('tables');\n\nconst sampleReportTest = {\n    sample_report_id: 3700,               // Reference ID linking to `sample_report`\n    sample_id: 3566,                    // ID for the sample\n    sample_receipt_id: 1220,    // Unique identifier for the sample receipt\n    test_name_secondary: \"Secondary Test\", // Secondary test name\n    test_order_id: 24440,                  // Order ID for the test\n    test_name: \"Test Name\",            // Name of the test\n    protocol_id: 1001,                 // ID for the protocol used\n    protocol_value: \"Protocol Value\",  // Value associated with the protocol\n    vlas: false,                       // Boolean for VLAS (default is false)\n    external: true,                    // Boolean for external testing (default is false)\n    lab_id: 1,                      // Lab ID where the test was conducted\n    std_ref: \"STD-12345\",              // Standard reference identifier\n    result_unit: \"mg/L\",               // Unit for the result\n    result_value: \"20.5\"               // Value of the test result\n    // created_at will default to the current timestamp, no need to set it manually\n};\n\ntry {\n    const add = await tables.TestReport.new(sampleReportTest);\n    node.warn(JSON.parse(JSON.stringify(add))); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "dbf7e35619c42da4",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 280,
        "wires": [
            [
                "425d2d2592033e6a"
            ]
        ]
    },
    {
        "id": "7cb5672fb0a1f133",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET REPORT",
        "func": "const tables = global.get('tables');\n\ntry {\n    const instance = new tables.SampleReport(11);\n    const obj = await instance.get();\n\n    node.warn(JSON.parse(JSON.stringify(obj)));\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "f1b2fd8bfe3ae35d",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 320,
        "wires": [
            [
                "7cb5672fb0a1f133"
            ]
        ]
    },
    {
        "id": "2910e99ae2994348",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 360,
        "wires": [
            [
                "e1633ecf3c211bb1"
            ]
        ]
    },
    {
        "id": "e1633ecf3c211bb1",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET SAMPLE",
        "func": "const tables = global.get('tables');\n\ntry {\n    const sample = await tables.Sample.get(3770);\n    node.warn(sample);\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "53b5df58195808c4",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET SAMPLE REPORT",
        "func": "const tables = global.get('tables');\n\ntry {\n    const sample = await tables.SampleReport.fromSample(11);\n    node.warn(sample);\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "b9996aa3dddd8d9c",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 400,
        "wires": [
            [
                "53b5df58195808c4"
            ]
        ]
    },
    {
        "id": "5f56f8d524b846e0",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SEARCH RECIPT",
        "func": "const tables = global.get('tables');\n\ntry {\n    const search = await tables.Receipt.searchReceipts('AVATEK');\n    node.warn(search); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "72de7d067ff17ba9",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 280,
        "wires": [
            [
                "5f56f8d524b846e0"
            ]
        ]
    },
    {
        "id": "5ea3b668f0f5536b",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 240,
        "wires": [
            [
                "69af6a65da9f7a7d"
            ]
        ]
    },
    {
        "id": "69af6a65da9f7a7d",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SEARCH PROTOCOL",
        "func": "const tables = global.get('tables');\n\ntry {\n    const search = await tables.LibProtocol.searchProtocols('HDPP233-KN');\n    node.warn(search); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "23773f85a11b3318",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SEARCH CLIENT",
        "func": "const tables = global.get('tables');\n\ntry {\n    const search = await tables.Client.searchClients('AVATEK');\n    node.warn(search); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "8e017d1c2301e479",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 200,
        "wires": [
            [
                "23773f85a11b3318"
            ]
        ]
    },
    {
        "id": "d7fd09bb478e43d8",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET ASSIGN_DEPT_LIST",
        "func": "const tables = global.get('tables');\n\ntry {\n    const result = await tables.LibLab.get_assign_dept_list();\n    node.warn(result); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "2f3ccf5ef73b7f37",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 200,
        "wires": [
            [
                "d7fd09bb478e43d8"
            ]
        ]
    },
    {
        "id": "0ea883bd94017958",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET PROTOCOL",
        "func": "const tables = global.get('tables');\n\ntry {\n    const instace = new tables.LibProtocol(20);\n    await instace.get();\n    node.warn(JSON.parse(JSON.stringify(instace)));\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "1e48bdb012092b68",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 440,
        "wires": [
            [
                "0ea883bd94017958"
            ]
        ]
    },
    {
        "id": "bd4ebf58b6419979",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET TESTS",
        "func": "const tables = global.get('tables');\n\ntry {\n    const instace = new tables.Test(400);\n    await instace.get();\n    node.warn(JSON.parse(JSON.stringify(instace)));\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "a6e93ccd7d251031",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 480,
        "wires": [
            [
                "bd4ebf58b6419979"
            ]
        ]
    },
    {
        "id": "7666f13515385fab",
        "type": "comment",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "info": "Todo: authenticate",
        "x": 600,
        "y": 120,
        "wires": []
    },
    {
        "id": "384baf7007c675f8",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 480,
        "wires": [
            [
                "1913a0ec76b765b2"
            ]
        ]
    },
    {
        "id": "1913a0ec76b765b2",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Test add user",
        "func": "const tables = global.get('tables');\nconst newUser = {\n        id: 38,\n        created_at: 1730773830107,\n        name: \"Trn T\",\n        user_uid: \"\",\n        email: \"trantu02.efw@gmail.com\",\n        phone: \"\",\n        password: \"123abcd\",\n        employee: true,\n        org_admin: true,\n        disabled: false,\n        force_reset_pw: false,\n        force_sign_out: false\n    }\n\ntry {\n    // Chuyn i thi gian t mili-giy sang giy\n    newUser.created_at = new Date(newUser.created_at).toISOString();\n    const newuser = await tables.User.new(newUser);\n    node.warn(`Populated user ${newUser.id}`);\n    \n    node.warn(newuser);\n} catch (error) {\n    node.warn(error);\n};\n    \nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "88f940cca9302e13",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 520,
        "wires": [
            [
                "59080bb74c31734a"
            ]
        ]
    },
    {
        "id": "59080bb74c31734a",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Test Login",
        "func": "const tables = global.get('tables');\nconst  email = \"trantu02.efw@gmail.com\"\nconst  password = \"123abcd\"\n\ntry {\n    const login = await tables.User.login(email,password);\n    \n    if(login){\n        node.warn(\"Correct\");\n        node.warn(login);\n    }else{\n        node.warn(\"Again\")\n    }\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "a61d70058026ea9c",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 520,
        "wires": [
            [
                "04904e86a0ec26f3"
            ]
        ]
    },
    {
        "id": "04904e86a0ec26f3",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "test client UID",
        "func": "\nconst abc = crypto.randomUUID().substr(0, 8)\nnode.warn(abc);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 840,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "9f1a7d62cd87f04c",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Test auth",
        "func": "const tables = global.get('tables');\nconst  email = \"trantu02.efw@gmail.com\"\nconst  password = \"123abcd\"\n\ntry {\n    const user = new tables.User(5);\n    await user.get();\n    node.warn(JSON.parse(JSON.stringify(user)));\n\n    await user.authenticate();\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "cc5f3a160c1c946e",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 580,
        "wires": [
            [
                "9f1a7d62cd87f04c"
            ]
        ]
    },
    {
        "id": "e78d8f6b94f6ec77",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "xano layer",
        "func": "const axios = global.get(\"axios\");\n\nconst xano = {\n    flag : false,\n\n    bridge_api: true, // if true, use xano\n\n    bridge_auth: true, // if true, use xano auth\n\n    get_recent_receipts: async (headers) => {\n        try {\n            const response = await axios.get(\n                \"https://xn.irdop.org/api:hrFfPpfK/receipt_list/_get/recent_receipts\",\n                { headers: headers },\n            );\n            return response;\n        } catch (error) {\n            if (error.response) {\n                node.warn(error.stack);\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    get_detail_sample: async (params, headers) => {\n        try {\n            const response = await axios.get(\n                \"https://xn.irdop.org/api:hrFfPpfK/sample_detail/_get/sample/\" +\n                params.sample_id,\n                { headers: headers },\n            );\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    get_detail_receipt: async (params, headers) => {\n        try {\n            const response = await axios.get(\n                \"https://xn.irdop.org/api:hrFfPpfK/receipt_detail/_get/receipt/\" +\n                params.receipt_id,\n                { headers: headers },\n            );\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    get_processing_samples: async (headers) => {\n        try {\n            const response = await axios.get(\n                \"https://xn.irdop.org/api:FzsHe1z4/sample_mgr/get_processing_samples\",\n                { headers: headers },\n            );\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    post_create_receipt: async (headers, body) => {\n        try {\n            const response = await axios.post(\n                \"https://xn.irdop.org/api:hrFfPpfK/receipt_list/_new/receipt\",\n                body,\n                { headers: headers },\n            );\n\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    post_create_sample: async (headers, body) => {\n        try {\n            const response = await axios.post(\n                \"https://xn.irdop.org/api:hrFfPpfK/receipt_detail/_new/sample\",\n                body,\n                { headers: headers },\n            );\n\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    post_sample_add_tests: async (headers, body) => {\n        try {\n            const response = await axios.post(\n                \"https://xn.irdop.org/api:hrFfPpfK/sample_detail/_add/tests\",\n                body,\n                { headers: headers },\n            );\n\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    post_delete_test_from_sample: async (headers, body) => {\n        try {\n            const response = await axios.post(\n                \"https://xn.irdop.org/api:hrFfPpfK/test/_delete/delete_test_from_sample\",\n                body,\n                { headers: headers },\n            );\n\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    post_delete_sample: async (headers, body) => {\n        try {\n            const response = await axios.post(\n                \"https://xn.irdop.org/api:hrFfPpfK/receipt_detail/_delete/sample\",\n                body,\n                { headers: headers },\n            );\n\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    post_delete_receipt: async (headers, body) => {\n        try {\n            const response = await axios.post(\n                \"https://xn.irdop.org/api:zGP0ovp2/sample_receipt_dashboard/delete_receipt\",\n                body,\n                { headers: headers },\n            );\n\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n\n    post_submit_test_result: async (headers, body) => {\n        /**\n         * Submits test results to the XN server\n         * @param {Object} headers - The HTTP request headers\n         * @param {Object} body - The request body containing test results\n         * @param {Object} body.result_submit - The test result data\n         * @returns {Promise<{test_order, protocol}|Error>} A promise that resolves with the test order response or rejects with an Error\n         */\n        try {\n            const response = await axios.post(\n                \"https://xn.irdop.org/api:eHOTU1fm/POST/_edit/submit_result\",\n                body,\n                { headers: headers },\n            );\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n\n    auth_me_employee: async (headers) => {\n        try {\n            const response = await axios.get(\n                \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\",\n                { headers: headers },\n            );\n            return response;\n        } catch (error) {\n            if (error.response) {\n                const err = new Error(error.response.data.message);\n                err.statusCode = error.response.status;\n                throw err;\n            }\n            else if (error.request) {\n                const err = new Error(\"No response from XN server\");\n                err.statusCode = 500;\n                throw err;\n            }\n            else {\n                const err = new Error(\"Unexpected error requesting XN server: \" + error.message);\n                err.statusCode = 500;\n                throw err;\n            }\n        }\n    },\n};\n\nasync function call_get_api(url) {\n    return await axios.get(url);\n}\n\n// export functions\nglobal.set(\"xano\", xano);\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "d154e66024c00edf",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 980,
        "y": 60,
        "wires": [
            [
                "56e29e13fe69df57"
            ]
        ]
    },
    {
        "id": "56e29e13fe69df57",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Log recentReceipt_cache",
        "func": "const cache = global.get('cache');\n\nconst receipts = cache.recentReceipts;\nnode.warn(receipts)\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "8a0a453aec856151",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "d": true,
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 960,
        "y": 640,
        "wires": [
            [
                "393ba8b840aefaca"
            ]
        ]
    },
    {
        "id": "393ba8b840aefaca",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "swap Xano_Nodered",
        "func": "const cache = global.get('cache');\nconst xano = global.get('xano');\n\n//Clear cache \ncache.recentReceipts = {};\ncache.processingSamples = {};\n\n//Swap bridge\nxano.bridge_api = false;\nxano.bridge_auth = false;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1160,
        "y": 640,
        "wires": [
            []
        ]
    },
    {
        "id": "dc109e8a7740ba59",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 980,
        "y": 100,
        "wires": [
            [
                "b73caebbb33a1cab"
            ]
        ]
    },
    {
        "id": "b73caebbb33a1cab",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Log processingSample",
        "func": "const cache = global.get('cache');\n\nconst receipts = cache.processingSamples;\nnode.warn(receipts)\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "1809df8c23f4f417",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 980,
        "y": 140,
        "wires": [
            [
                "e64848a9c21540f5"
            ]
        ]
    },
    {
        "id": "e64848a9c21540f5",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Clear Log processingSample",
        "func": "const cache = global.get('cache');\n\ndelete cache.processingSamples['eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.5zx8hkJPOaJy5GxXGS1zeGhLSGbko4G_DX-_3Z_NIAt-nVAjfP6POGYd7OM75eZZGlcQAjKM8h7ow0qZ2D8JUJIFmwf3E_9B.JOyEwwzDkP2gridTF3x3jw.5s3UElHqnvs0W09mVjkY6SKdJEeqkMr3aH2qGg7O6z-QvRadgJLh8sGb23-YwdQVMs87GgVsjX1JWiAqaaE2sXblNd_SvrcVhkP7IZzDyJKK2S59ScrpOVg8_Tr4cU9HlW_EfkawJpSUTftG_EVFlZC19EKYvGFRxTgcWScVbCr1Nc9fuyfn3G4XqsYrvOQuiiXMlT9gQv_uBZUF_Fvoz30icS7xIpfKh1FExgOpvD-5AmEwLl7llTjm8dYQHCZSfRHzSHtGFxenR71XmaWzlRrGR-cxH_b-NWbcr4dViGCNiPOGDFUWPcDn69Z8wiMGLqzCtwlW7JrYrTZHDvyPsZw9rK-Lle21ubyk7laxqs79Z56we_y0LQG584hHGwVe8ZPSTYKsiUyNw31NpmjoxMpxUe3Ea2oBxg8x5l0D44dz6wZStnb-j6DEYgWTW4PohGBZvLWKnugF5BpSZU_B3Q.SVQZiZ4zzj5xpUp_5WQ123gOOFPa3LHktuZyg_oXigk'];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "3c6319e9bc664095",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Clients",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xi2o-uvcs-ca8b.s2.xano.io/api:20C5ETE9/all_client",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 390,
        "y": 100,
        "wires": [
            [
                "0ec8938a41a5c613"
            ]
        ]
    },
    {
        "id": "2f8e81c7042cd0c0",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 100,
        "wires": [
            [
                "3c6319e9bc664095"
            ]
        ]
    },
    {
        "id": "0ec8938a41a5c613",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Client table",
        "func": "const timeStart = Date.now();\nlet clients = JSON.parse(msg.payload);\nnode.warn(`Found ${clients.length} clients to populate`);\nconst tables = global.get('tables');\nnode.warn(clients);\n\ntry {\n    for (const client of clients) {       \n        client.created_at = new Date(client.created_at).toISOString();\n\n        const newClient = await tables.Client.new(client);\n        \n  \n    }\n\n    node.warn(`Finished populating clients`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nconst timePopulate = (Date.now() - timeStart)/1000;\nnode.warn(`Duration : ${timePopulate} s`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "35197bad4cad825c",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 300,
        "wires": [
            [
                "f2db5c4946548328"
            ]
        ]
    },
    {
        "id": "f2db5c4946548328",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Receipt",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xi2o-uvcs-ca8b.s2.xano.io/api:20C5ETE9/sample_receipt",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 390,
        "y": 300,
        "wires": [
            [
                "324b7e42861a2639"
            ]
        ]
    },
    {
        "id": "324b7e42861a2639",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Receipt table",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet receipts;\n\ntry {\n    receipts = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(receipts);\n\ntry {\n    for (const receipt of receipts) {\n        receipt.created_at = new Date(receipt.created_at).toISOString();\n        if(receipt.client_id === 0) receipt.client_id = null;\n\n        const newReceipt = await tables.Receipt.new(receipt);\n    }\n\n    node.warn(`Finished populating receipts`);    \n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 300,
        "wires": [
            []
        ]
    },
    {
        "id": "0bf93ae942b542d0",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating test table",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet tests;\n\ntry {\n    tests = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(tests);\n\ntry {\n    for (const test of tests) {\n        // Chuyn i thi gian t mili-giy sang giy\n        test.created_at = new Date(test.created_at).toISOString();\n        if (test.modified_at) test.modified_at = new Date(test.modified_at).toISOString();\n        \n        if(test.dept_id === 0 ) test.dept_id = null;\n\n        if(test.protocol_id === 0) test.protocol_id = null;\n\n        if(test.modified_by_id === 0) test.modified_by_id = null;\n\n        const newtest = await tables.Test.new(test);\n    }\n\n    node.warn(`Finished populating tests`);    \n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "784043ca445a1ee6",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Test",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xn.irdop.org/api:20C5ETE9/all_lib_tests",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 380,
        "y": 380,
        "wires": [
            [
                "0bf93ae942b542d0"
            ]
        ]
    },
    {
        "id": "dc666437d3a050b6",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 380,
        "wires": [
            [
                "784043ca445a1ee6"
            ]
        ]
    },
    {
        "id": "6c4501b6dddb5058",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Sample",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xi2o-uvcs-ca8b.s2.xano.io/api:20C5ETE9/sample",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 390,
        "y": 340,
        "wires": [
            [
                "70d2564cb9e099ff"
            ]
        ]
    },
    {
        "id": "65497589c66a99f1",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 340,
        "wires": [
            [
                "6c4501b6dddb5058"
            ]
        ]
    },
    {
        "id": "70d2564cb9e099ff",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Sample table",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet samples;\n\ntry {\n    samples = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(samples);\n\ntry {\n    for (const sample of samples) {\n        // Chuyn i thi gian t mili-giy sang giy\n        if(sample.status ===\"\") sample.status = null;\n        sample.created_at = new Date(sample.created_at).toISOString();\n        if (sample.modified_at && sample.modified_at!== 0) sample.modified_at = new Date(sample.modified_at).toISOString(); \n            else sample.modified_at = null;\n        if (sample.commencement_time && sample.commencement_time!== 0) sample.commencement_time = new Date(sample.commencement_time).toISOString();\n            else sample.commencement_time = null;\n        if (sample.sample_deadline && sample.sample_deadline !== 0 ) sample.sample_deadline = new Date(sample.sample_deadline).toISOString();\n            else sample.sample_deadline = null;\n\n        if(sample.created_by_id === 0) sample.created_by_id = null;\n        if(sample.modified_by_id === 0) sample.modified_by_id = null;\n\n\n        const newsample = await tables.Sample.new(sample);\n    }\n\n    node.warn(`Finished populating samples`);    \n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "422fe7665c60df65",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Test Order table",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet testOrders;\n\nlet missRecord = [];\n\ntry {\n    testOrders = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(testOrders);\n\ntry {\n    for (const testOrder of testOrders) {\n        // Chuyn i thi gian t mili-giy sang giy\n        testOrder.created_at = new Date(testOrder.created_at).toISOString();\n        if (testOrder.result_submitted_at) testOrder.result_submitted_at = new Date(testOrder.result_submitted_at).toISOString();\n        if (testOrder.assigned_to_user_id === 0) testOrder.assigned_to_user_id = null;\n        if (testOrder.assigned_to_dept_id === 0) testOrder.assigned_to_dept_id = null;\n        if (testOrder.lib_test_id === 0) testOrder.lib_test_id = null;\n        if (testOrder.protocol_id === 0) testOrder.protocol_id = null;\n        if (testOrder.sample_id === 0) testOrder.sample_id = null;\n        if (testOrder.sample_receipt_id === 0) testOrder.sample_receipt_id = null;\n        if (testOrder.sample_receipt_id === 0) testOrder.sample_receipt_id = null;\n        if (testOrder.tested_by_user_id === 0) testOrder.tested_by_user_id = null;\n        if (testOrder.result_submitted_at === 0) testOrder.result_submitted_at = null;\n        try {\n            const newtestOrder = await tables.TestOrder.new(testOrder);\n\n        } catch (error) {\n            testOrder.protocol_id = null;\n            testOrder.lib_test_id = null;\n\n            const newtestOrder = await tables.TestOrder.new(testOrder);\n\n            continue;\n        }\n\n    }\n\n    node.warn(`Finished populating testOrders`);\n\n    node.warn(`Miss ${missRecord.length} records`);\n\n    const timePopulate = (Date.now() - timeStart) / 1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 500,
        "wires": [
            []
        ]
    },
    {
        "id": "689bb04d901e1885",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Test Order",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xi2o-uvcs-ca8b.s2.xano.io/api:20C5ETE9/all_test_order",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 400,
        "y": 500,
        "wires": [
            [
                "422fe7665c60df65"
            ]
        ]
    },
    {
        "id": "e6f0fdbc5029be92",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 500,
        "wires": [
            [
                "689bb04d901e1885"
            ]
        ]
    },
    {
        "id": "4f3a84c21b396fdb",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating User",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet users;\n\ntry {\n    users = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(users);\n\ntry {\n    for (const user of users) {\n        // Chuyn i thi gian t mili-giy sang giy\n        user.created_at = new Date(user.created_at).toISOString();\n        \n        const newuser = await tables.User.new(user);\n    }\n\n    node.warn(`Finished populating users`);\n\n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n} catch (error) {\n    node.warn(error);\n};\n\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "8059a1c9e03af413",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get User",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xi2o-uvcs-ca8b.s2.xano.io/api:20C5ETE9/user",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 380,
        "y": 140,
        "wires": [
            [
                "4f3a84c21b396fdb"
            ]
        ]
    },
    {
        "id": "991aaea937878ac1",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 140,
        "wires": [
            [
                "8059a1c9e03af413"
            ]
        ]
    },
    {
        "id": "73916e792cf222c5",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Receipt Price",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet receiptPrices;\n\ntry {\n    receiptPrices = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(receiptPrices);\n\ntry {\n    for (const receiptPrice of receiptPrices) {\n        // Chuyn i thi gian t mili-giy sang giy\n        receiptPrice.created_at = new Date(receiptPrice.created_at).toISOString();\n        if (receiptPrice.sample_receipt_id === 0) receiptPrice.sample_receipt_id = null;\n\n        try {\n            const newreceiptPrice = await tables.ReceiptPrice.new(receiptPrice);\n        } catch (error) {\n            node.warn(error);\n            continue;\n        };\n\n        // Thm khong ch\n        await new Promise(resolve => setTimeout(resolve, 50));\n    }\n\n    node.warn(`Finished populating receiptPrices`);    \n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "1de127740bca8f35",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Receipt Price",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xi2o-uvcs-ca8b.s2.xano.io//api:20C5ETE9/all_sample_receipt_prices",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 410,
        "y": 620,
        "wires": [
            [
                "73916e792cf222c5"
            ]
        ]
    },
    {
        "id": "3aacb94479e44845",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 620,
        "wires": [
            [
                "1de127740bca8f35"
            ]
        ]
    },
    {
        "id": "ea4fd56b73cc365a",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Lib Protocol table",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet lib_protocols;\n\ntry {\n    lib_protocols = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(lib_protocols);\n\ntry {\n    for (const lib_protocol of lib_protocols) {\n        // Chuyn i thi gian t mili-giy sang giy\n        lib_protocol.created_at = new Date(lib_protocol.created_at).toISOString();\n\n        //Nu modified_by = 0 th  null\n        if(lib_protocol.modified_by === 0) lib_protocol.modified_by = null;\n\n        const newLibProtocol = await tables.LibProtocol.new(lib_protocol);\n    }\n    node.warn(`Finished populating Protocols`);\n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "876275f32ebdbaea",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Protocol",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xi2o-uvcs-ca8b.s2.xano.io/api:20C5ETE9/all_lib_protocols",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 390,
        "y": 260,
        "wires": [
            [
                "ea4fd56b73cc365a"
            ]
        ]
    },
    {
        "id": "f7b4bf9ea95467a2",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 260,
        "wires": [
            [
                "876275f32ebdbaea"
            ]
        ]
    },
    {
        "id": "0e7e93b3805270a9",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Lib dept table",
        "func": "const tables = global.get('tables');\nlet libDepts;\n\nconst timeStart = Date.now();\n\ntry {\n    libDepts = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(libDepts);\n\ntry {\n    for (const libDept of libDepts) {\n        // Chuyn i thi gian t mili-giy sang giy\n        libDept.created_at = new Date(libDept.created_at).toISOString();\n\n        const newlibDept = await tables.LibDept.new(libDept);\n    }\n    node.warn(`Finished populating libDepts`);\n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "ee1370e4be40fc03",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Lib Dept",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xi2o-uvcs-ca8b.s2.xano.io/api:20C5ETE9/lib_dept",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 390,
        "y": 220,
        "wires": [
            [
                "0e7e93b3805270a9"
            ]
        ]
    },
    {
        "id": "81ec12aafc14480e",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 220,
        "wires": [
            [
                "ee1370e4be40fc03"
            ]
        ]
    },
    {
        "id": "0f250da2f6d5dcc8",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating LibLab",
        "func": "const tables = global.get('tables');\nlet libLabs;\nconst timeStart = Date.now();\n\ntry {\n    libLabs = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(libLabs);\n\ntry {\n    for (const libLab of libLabs) {\n        // Chuyn i thi gian t mili-giy sang giy\n        libLab.created_at = new Date(libLab.created_at).toISOString();\n\n        const newlibLab = await tables.LibLab.new(libLab);\n    }\n\n    node.warn(`Finished populating libLabs`);\n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "982e5d316445ea9a",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get LibLab",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xi2o-uvcs-ca8b.s2.xano.io/api:20C5ETE9/all_lib_lab",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 390,
        "y": 180,
        "wires": [
            [
                "0f250da2f6d5dcc8"
            ]
        ]
    },
    {
        "id": "c2834d268bc206f9",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 180,
        "wires": [
            [
                "982e5d316445ea9a"
            ]
        ]
    },
    {
        "id": "d3bf55f43e15e822",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Sample Prices",
        "func": "const timeStart = Date.now()\nconst tables = global.get('tables');\nlet samplePrices;\n\ntry {\n    samplePrices = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(samplePrices);\n\ntry {\n    for (const samplePrice of samplePrices) {\n        // Chuyn i thi gian t mili-giy sang giy\n        samplePrice.created_at = new Date(samplePrice.created_at).toISOString();\n        if(samplePrice.sample_id === 0) samplePrice.sample_id = null;\n        if(samplePrice.sampe_receipt_id === 0) samplePrice.sample_receipt_id = null;\n        \n        if(samplePrice.sample_id === 220) continue;\n        const newsamplePrice = await tables.SamplePrice.new(samplePrice);    \n    }\n\n    node.warn(`Finished populating samplePrices`);\n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 420,
        "wires": [
            []
        ]
    },
    {
        "id": "04eb5842da886500",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Sample Price",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xn.irdop.org/api:20C5ETE9/sample_prices",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 410,
        "y": 420,
        "wires": [
            [
                "d3bf55f43e15e822"
            ]
        ]
    },
    {
        "id": "6063e3b8dbe13fc3",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 420,
        "wires": [
            [
                "04eb5842da886500"
            ]
        ]
    },
    {
        "id": "b3863cf582695346",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Sample Report",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet sampleReports;\n\ntry {\n    sampleReports = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(sampleReports);\n\ntry {\n    for (const sampleReport of sampleReports) {\n        // Chuyn i thi gian t mili-giy sang giy\n        sampleReport.created_at = new Date(sampleReport.created_at).toISOString();\n        if (sampleReport.modified_at && sampleReport.modified_at !== 0) sampleReport.modified_at = new Date(sampleReport.modified_at).toISOString();\n        else sampleReport.modified_at = null;\n        if(sampleReport.sample_id === 2185) continue\n\n        if (sampleReport.modified_by_id === 0 || sampleReport.modified_by_id > 10000000) sampleReport.modified_by_id = null;\n        if (sampleReport.modified_prices_id === 0 || sampleReport.modified_prices_id> 10000000) sampleReport.modified_prices_id = null;\n        if (sampleReport.sample_prices_id === 0 || sampleReport.sample_prices_id > 10000000) sampleReport.sample_prices_id = null;\n        \n        const newsampleReport = await tables.SampleReport.new(sampleReport);\n    }\n\n    node.warn(`Finished populating sampleReports`);  \n      \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "b92ee793ce467c6d",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Sample Report",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xn.irdop.org/api:20C5ETE9/all_sample_report",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.qdYmE9xdRz9Cqp1sjApO8Mj7VmloFlt5ydQBC5AGkBhEelHJUEBRT8lFaC_RIx05h7u7m-nui7e7z40dSa9_jZ1qX68IIXLr.MWL8S6qcl9HQ-gxor5O2mQ.SysLhtTvQQcgTQAK1CKRHeLgrYwlQvNWloTzDGyVKKcCkCb-jDmTPtGtLEmUlM6vFcRtI1zcukq2jiyoNKTDCkzCSbQS3giMVBBQRXuCC4to0P0R5C-KQ1Hve1_XtFf-G50o1Sz2rh6iGh252tJDeihZwMimVmA-ki6iDb1dhMv1WrtNJBPq47Vpo7pTtjXpSHTVkzepQl7AAJZJIjoqkiaZI8uaOAqzZ8pLmozMvEKfFKcUw_g7P1KoYfm2bTNg55k5ahUehm75n8BrNh9D_2nG9ZqXVxLZ6QPnHYrhkvxCU8sNXHRTLFSsthU1l6y_dNhyV7JktiVqLVdK1A_gbG8QYa-RHu5Ra46xaPZ-JE44Dxcxuf3hPGCsUaQRdQrY3igtUNXhdPj0iTZD8vLy1CwWXtyCR6ezpxaqcj_ovfCGqkV9FlZ4ALIlLGt_vp_MQ6DFUqsZGVetY22Fe4BEzA.FoxMIJJ351xWaVVUk8fyBaPJ2e6s5aAzKwqQ-6cKlNw"
            }
        ],
        "x": 410,
        "y": 460,
        "wires": [
            [
                "b3863cf582695346"
            ]
        ]
    },
    {
        "id": "0477c28a2ed3f03e",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 460,
        "wires": [
            [
                "b92ee793ce467c6d"
            ]
        ]
    },
    {
        "id": "d52eff52c9843659",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating Test Report",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet testReports;\n\ntry {\n    testReports = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(testReports);\nlet missRecord = [];\n\ntry {\n    for (const testReport of testReports) {\n        // Chuyn i thi gian t mili-giy sang giy\n        testReport.created_at = new Date(testReport.created_at).toISOString();\n        if (testReport.modified_at && testReport.modified_at !== 0) testReport.modified_at = new Date(testReport.modified_at).toISOString();\n        else testReport.modified_at = null;\n        if(testReport.lab_id === 0 ) testReport.lab_id = null;\n\n        try {\n            const newtestReport = await tables.TestReport.new(testReport);\n        } catch (error) {\n            missRecord.push(testReport);\n            continue;\n        };\n\n    }\n\n    node.warn(`Finished populating testReports`);   \n    node.warn(`Miss ${missRecord.length} records`);  \n\n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "aff5a1878dacfe62",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get Test Report",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xn.irdop.org/api:20C5ETE9/all_sample_report_tests",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 400,
        "y": 660,
        "wires": [
            [
                "d52eff52c9843659"
            ]
        ]
    },
    {
        "id": "bfbea80e7382716d",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 660,
        "wires": [
            [
                "aff5a1878dacfe62"
            ]
        ]
    },
    {
        "id": "f9ab34152ad497f0",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating User Lib Role",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet userLabRoles;\n\ntry {\n    userLabRoles = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(userLabRoles);\n\ntry {\n    for (const userLabRole of userLabRoles) {\n        // Chuyn i thi gian t mili-giy sang giy\n        userLabRole.created_at = new Date(userLabRole.created_at).toISOString();\n\n        const newuserLabRole = await tables.UserLabRole.new(userLabRole);\n\n        // Thm khong ch\n        await new Promise(resolve => setTimeout(resolve, 50));\n    }\n\n    node.warn(`Finished populating userLabRoles`);    \n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "7d79ba46b5bf61f7",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get User Lab Role",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xn.irdop.org/api:20C5ETE9/user_lab_roles",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 410,
        "y": 580,
        "wires": [
            [
                "f9ab34152ad497f0"
            ]
        ]
    },
    {
        "id": "7754315b96fca4a3",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 580,
        "wires": [
            [
                "7d79ba46b5bf61f7"
            ]
        ]
    },
    {
        "id": "676d9d6efbeb3fba",
        "type": "function",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Populating LibLab",
        "func": "const timeStart = Date.now();\nconst tables = global.get('tables');\nlet userDepts;\n\ntry {\n    userDepts = JSON.parse(msg.payload);\n} catch (e) {\n    node.warn(\"Invalid JSON format\");\n    return msg;\n}\n\nnode.warn(userDepts);\n\ntry {\n    for (const userDept of userDepts) {\n        // Chuyn i thi gian t mili-giy sang giy\n        userDept.created_at = new Date(userDept.created_at).toISOString();\n\n        const newuserDept = await tables.UserDept.new(userDept);\n    }\n\n    node.warn(`Finished populating userDepts`);    \n    \n    const timePopulate = (Date.now() - timeStart)/1000;\n    node.warn(`Duration : ${timePopulate} s`);\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "f571dca59479816d",
        "type": "http request",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "Get User Dept",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://xn.irdop.org/api:20C5ETE9/user_depts",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Authorization",
                "keyValue": "",
                "valueType": "other",
                "valueValue": "Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.q2VW5Z5eSpAjnFbWs5cyLjhWosnYfEeDIzFt1SNyvdal5pQ2J1L_NCjjnNiWMGv9UBYkIQFf1GecYrBhlIeyvhbpzy4a7blK.EctxWChI5NTANtRkN8VaEw.VSNLtdpzAZifv2W0VAQTBgX2W4zElr3vPY_oQe58HmGM_dquG8A43lOOPq-PpFfC4K52GHwtFUSrrfyfCttxREmaaicZdVVRF_YZZuosezJPd2MNPMaXEkAakEaB0O20aKHLWxJe3h9Pnw7gc5fA9tUcs_EMYuwl-uEZY_Fg914SeW6uh2NEqbz7aOqlSDQT4c5qIEAUi9RgBQBLH3z5U2JETrWCAVp2ERSkw7LhvLQbSBngSQNfGvWHHdMmUTRJpQAjy1MEFkUXCfRsqQKFu6OXzYVGC4hsclPxLhG4hVLfOpSo0JLAyJ32iW0VbZwj1pcibAD2hh0iYA9b1IPbllzW4SoXY88vLmL3Ktjf5cukj8YJdaakeZZZGkje3-qO8U76IThMsCZLkJHCIgL8LsL_j1e71K1biW6D5rtfTPCHNhhIGZUeHTJU8fmGCUkBGi1Hbt5b7vU01BfNlouw8g.z2tuaWdJOqN0OSXKEwalZTNlsnSj-5Pgp199kLMIDGc"
            }
        ],
        "x": 400,
        "y": 540,
        "wires": [
            [
                "676d9d6efbeb3fba"
            ]
        ]
    },
    {
        "id": "869d0eb71c849fdd",
        "type": "inject",
        "z": "3b19f9a67be11a89",
        "g": "6279944e36da2c77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 540,
        "wires": [
            [
                "f571dca59479816d"
            ]
        ]
    },
    {
        "id": "b33a88c809d7dfd4",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get All Recent Receipt (XANO)",
        "func": "node.warn(msg);\nconst axios = global.get('axios');\n\ntry {\n    /* 1. Forward request to XANO */\n    try {\n        const xanoReq = {\n            url : \"https://xn.irdop.org/api:hrFfPpfK/receipt_list/_get/recent_receipts\", // URL ca API\n            method : \"GET\",\n            headers : {\n                \"Content-Type\": \"application/json\",\n                \"authorization\": msg.req.headers.authorization\n            },\n        }\n        const xanoRes = await axios({\n            method: xanoReq.method,\n            url: xanoReq.url,\n            headers: xanoReq.headers,\n        });\n        // return without \n        msg.payload = xanoRes.data;\n        // return msg;\n    } catch (error) {\n        // Handle errors\n        if (error.response) {\n            msg.statusCode = error.response.status;\n            msg.payload = error.response.data;\n        } else if (error.request) {\n            // no connection to xano\n            msg.statusCode = 500;\n            msg.payload = {\n                error : {\n                    message: \"No connection to XN database\",\n                    code: 500\n                }\n            }\n        } else {\n            // Something happened in setting up the request that triggered an Error\n            msg.statusCode = 500;\n            msg.payload = {\n                error : {\n                    message: \"Unexpected error\",\n                    code: 500\n                }\n            }\n            node.warn(\"Unexpected error @ forwarding Xano request for /recent_receipts API endpoint\")\n        }\n        return msg;\n    }\n\n    return msg;\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;   // Default Internal Server Error\n    msg.payload = error.message;                // Error message\n    return msg;\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 140,
        "wires": [
            [
                "9f49f384954a660c"
            ]
        ]
    },
    {
        "id": "4064c40a44d53526",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1150,
        "y": 140,
        "wires": []
    },
    {
        "id": "db09ac97d896844f",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "API RECENT_RECEIPTS",
        "url": "/__api:hrFfPpfK/receipt_list/_get/recent_receipts",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 140,
        "wires": [
            [
                "9f49f384954a660c"
            ]
        ]
    },
    {
        "id": "80864df0e24a0f23",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "API GET RECEIPT BY SAMPLE_ID",
        "url": "/__api:hrFfPpfK/sample_detail/_get/sample/:sample_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 220,
        "y": 180,
        "wires": [
            [
                "3e70395521109352"
            ]
        ]
    },
    {
        "id": "b2ab025f0662937f",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Recent Receipt By SampleID (NODERED)",
        "func": "try {\n    const axios = global.get('axios');\n\n    //Call check auth API\n    const authRes = await axios({\n        method: \"GET\",\n        url: \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        }\n    });\n\n    /* 1. Authentication */\n    if (authRes >= 400 ) {   // Auth rejected by Xano\n        const err = new Error;\n        err.payload = authRes.data;  // Error message by Xano\n        err.statusCode = authRes.statusCode;       // Enforcing 401\n        throw err;\n    }\n\n    /* 2. Main Logic */\n    const { Receipt } = global.get('tables');           // Get Library\n    /**\n     * Receipt.recentReceipts() => return list recent receipts\n     * Receipt.recentReceipts({receipt_id: Number}) => return detail Receipt by receipt_id\n     * Receipt.recentReceipts({sample_id: Number}) => return detail Receipt by sample.sample_receipt_id\n     */\n    \n    // msg.req.params : {sample_id: params.sample_id}\n    const recentReceipts = await Receipt.recentReceipts(msg.req.params);       \n    node.warn(recentReceipts[0]);\n    \n    // msg.payload = recentReceipts\n    return msg;\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;   // Default Internal Server Error\n    msg.payload = error.message;                // Error message\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 180,
        "wires": [
            [
                "f39544220d8486be"
            ]
        ]
    },
    {
        "id": "04d951a659feb84a",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "API GET RECEIPT BY RECEIPT_ID",
        "url": "_/api:hrFfPpfK/receipt_detail/_get/receipt/:receipt_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 220,
        "y": 220,
        "wires": [
            [
                "0dae4bc5b866ba78"
            ]
        ]
    },
    {
        "id": "98cbfac8213259b5",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Recent Receipt By ReceiptID (NODERED)",
        "func": "try {\n    const axios = global.get('axios');\n\n    //Call check auth API\n    const authRes = await axios({\n        method: \"GET\",\n        url: \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        }\n    });\n\n    /* 1. Authentication */\n    if (authRes >= 400 ) {   // Auth rejected by Xano\n        const err = new Error;\n        err.payload = authRes.data;  // Error message by Xano\n        err.statusCode = authRes.statusCode;       // Enforcing 401\n        throw err;\n    }\n\n    /* 2. Main Logic */\n    const { Receipt } = global.get('tables');           // Get Library\n    /**\n     * Receipt.recentReceipts() => return list recent receipts\n     * Receipt.recentReceipts({receipt_id: Number}) => return detail Receipt by receipt_id\n     * Receipt.recentReceipts({sample_id: Number}) => return detail Receipt by sample.sample_receipt_id\n     */\n    \n    // msg.req.params : {receipt_id: params.receipt_id}\n    const recentReceipts = await Receipt.recentReceipts(msg.req.params);       \n    node.warn(recentReceipts[0]);\n    \n    // msg.payload = recentReceipts\n    return msg;\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;   // Default Internal Server Error\n    msg.payload = error.message;                // Error message\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 220,
        "wires": [
            [
                "8a773f6151557090"
            ]
        ]
    },
    {
        "id": "b95d1e90260f7f3a",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "API NEW RECEIPT",
        "url": "/new_receipt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 600,
        "wires": [
            [
                "180ee19af01a8013"
            ]
        ]
    },
    {
        "id": "40a89dc6e9cf1716",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "NEW RECEIPT",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n    try {\n        msg.payload = await tables.Receipt.new(msg.req.body);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 600,
        "wires": [
            [
                "9bc9b1182fbc0723"
            ]
        ]
    },
    {
        "id": "9bc9b1182fbc0723",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 600,
        "wires": []
    },
    {
        "id": "63988b85e29c5d8d",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "API NEW CLIENT",
        "url": "/new_client",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 640,
        "wires": [
            [
                "4bb0ebc71c4626ae"
            ]
        ]
    },
    {
        "id": "8f9abe643d6230e0",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "NEW CLIENT",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        msg.payload = await tables.Client.new(msg.req.body);\n        node.warn(JSON.parse(JSON.stringify(msg.payload)));\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 640,
        "wires": [
            [
                "be04b5ad297d726f"
            ]
        ]
    },
    {
        "id": "be04b5ad297d726f",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 640,
        "wires": []
    },
    {
        "id": "0f9120d84b12ded0",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "API NEW RECEIPT PRICE",
        "url": "/new_receipt_price",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 680,
        "wires": [
            [
                "1fe325820ebffb6f"
            ]
        ]
    },
    {
        "id": "10ba5665c41039a6",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "NEW RECEIPT PRICE",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        msg.payload = await tables.ReceiptPrice.new(msg.req.body);\n        node.warn(JSON.parse(JSON.stringify(msg.payload)));\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 680,
        "wires": [
            [
                "266d506455956098"
            ]
        ]
    },
    {
        "id": "266d506455956098",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 680,
        "wires": []
    },
    {
        "id": "45015072c2e4f050",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "API NEW SAMPLE",
        "url": "/new_sample",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 720,
        "wires": [
            [
                "1807f2950052995e"
            ]
        ]
    },
    {
        "id": "29edd99d5611d6d4",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "NEW SAMPLE",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        msg.payload = await tables.Sample.new(msg.req.body);\n        node.warn(JSON.parse(JSON.stringify(msg.payload)));\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 720,
        "wires": [
            [
                "39eba60a795e2f1a"
            ]
        ]
    },
    {
        "id": "39eba60a795e2f1a",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 720,
        "wires": []
    },
    {
        "id": "2cb7d199c66116c3",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "API NEW TEST ORDER",
        "url": "/new_test_order",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 760,
        "wires": [
            [
                "5319907d595c741f"
            ]
        ]
    },
    {
        "id": "e55e2d06b698d4be",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "NEW TEST ORDER",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        msg.payload = await tables.TestOrder.new(msg.req.body);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 760,
        "wires": [
            [
                "1976e499c64fd5ac"
            ]
        ]
    },
    {
        "id": "1976e499c64fd5ac",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 760,
        "wires": []
    },
    {
        "id": "b7302009055a4662",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "API NEW SAMPLE PRICE",
        "url": "/new_sample_price",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 800,
        "wires": [
            [
                "726dfa9ff66f9335"
            ]
        ]
    },
    {
        "id": "618e59aa269e2ee6",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "NEW SAMPLE PRICE",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        msg.payload = await tables.SamplePrice.new(msg.req.body);\n        node.warn(JSON.parse(JSON.stringify(msg.payload)));\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 800,
        "wires": [
            [
                "5fe23c197a07d03d"
            ]
        ]
    },
    {
        "id": "5fe23c197a07d03d",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 800,
        "wires": []
    },
    {
        "id": "88c2f4086108a3ba",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "API NEW PROTOCOL",
        "url": "/new_protocol",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 840,
        "wires": [
            [
                "498da67479a8223b"
            ]
        ]
    },
    {
        "id": "a6d6a440fb0fe680",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "NEW PROTOCOL",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        msg.payload = await tables.LibProtocol.new(msg.req.body);\n        node.warn(JSON.parse(JSON.stringify(msg.payload)));\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 840,
        "wires": [
            [
                "bd508f639bc54b5b"
            ]
        ]
    },
    {
        "id": "bd508f639bc54b5b",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 840,
        "wires": []
    },
    {
        "id": "b44516ce4e0dcf5b",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "API UPDATE RECEIPT",
        "url": "/update_receipt/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1360,
        "y": 120,
        "wires": [
            [
                "5c7488c5b54210fa"
            ]
        ]
    },
    {
        "id": "1d4bab6811cbe5a6",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "EDIT RECEIPT",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n   const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        const instance = new tables.Receipt(parseInt(msg.req.params.id));\n        node.warn({instance});\n        msg.payload = await instance.set(msg.req.body);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2020,
        "y": 120,
        "wires": [
            [
                "c9337d4167faf15f"
            ]
        ]
    },
    {
        "id": "c9337d4167faf15f",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 120,
        "wires": []
    },
    {
        "id": "5e058ac9ef83cad6",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "API UPDATE PROTOCOL",
        "url": "/update_protocol/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1370,
        "y": 320,
        "wires": [
            [
                "5ccdfdde1ca97c53"
            ]
        ]
    },
    {
        "id": "7a5534ae08bd0762",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "EDIT PROTOCOL",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        const instance = new tables.LibProtocol(parseInt(msg.req.params.id));\n        node.warn({ instance });\n        msg.payload = await instance.set(msg.req.body);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2030,
        "y": 320,
        "wires": [
            [
                "688bf453afadcef3"
            ]
        ]
    },
    {
        "id": "688bf453afadcef3",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 320,
        "wires": []
    },
    {
        "id": "cdfc9b132e9e5e57",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "API UPDATE CLIENT",
        "url": "/update_client/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1360,
        "y": 280,
        "wires": [
            [
                "173d7eea94be9a62"
            ]
        ]
    },
    {
        "id": "08919acebc7bba71",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "EDIT CLIENT",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        const instance = new tables.Client(parseInt(msg.req.params.id));\n        node.warn({instance});\n        msg.payload = await instance.set(msg.req.body);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2020,
        "y": 280,
        "wires": [
            [
                "18de389cdca2cf80"
            ]
        ]
    },
    {
        "id": "18de389cdca2cf80",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 280,
        "wires": []
    },
    {
        "id": "e170918e7f5dbc58",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "API UPDATE RECEIPT PRICE",
        "url": "/update_receipt_price/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1390,
        "y": 240,
        "wires": [
            [
                "df7a4ee26b223100"
            ]
        ]
    },
    {
        "id": "99d665f0443c73d7",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "EDIT RECEIPT PRICE",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        const instance = new tables.ReceiptPrice(parseInt(msg.req.params.id));\n        node.warn({instance});\n        msg.payload = await instance.set(msg.req.body);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2040,
        "y": 240,
        "wires": [
            [
                "d347cc3c685b9566"
            ]
        ]
    },
    {
        "id": "d347cc3c685b9566",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 240,
        "wires": []
    },
    {
        "id": "79e74c69e3450b5a",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "API UPDATE TEST ORDER",
        "url": "/update_test_order/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1380,
        "y": 200,
        "wires": [
            [
                "edd0a1ac31b4087e"
            ]
        ]
    },
    {
        "id": "6f196ff5fc7fe4eb",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "EDIT TEST ORDER",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        const instance = new tables.TestOrder(parseInt(msg.req.params.id));\n        node.warn({ instance });\n        msg.payload = await instance.set(msg.req.body);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2040,
        "y": 200,
        "wires": [
            [
                "7c7cce005aa64951"
            ]
        ]
    },
    {
        "id": "7c7cce005aa64951",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 200,
        "wires": []
    },
    {
        "id": "dec0e2d7c04d9be0",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "API UPDATE SAMPLE",
        "url": "/update_sample/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1360,
        "y": 160,
        "wires": [
            [
                "9ad0e4463f21488f"
            ]
        ]
    },
    {
        "id": "3f64bebf8610ebf4",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "EDIT SAMPLE",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        const instance = new tables.Sample(parseInt(msg.req.params.id));\n        node.warn({instance});\n        msg.payload = await instance.set(msg.req.body);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2020,
        "y": 160,
        "wires": [
            [
                "8e2ef0315a96399e"
            ]
        ]
    },
    {
        "id": "8e2ef0315a96399e",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 160,
        "wires": []
    },
    {
        "id": "2339173ac480ce8a",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "API DELETE RECEIPT",
        "url": "/delete_receipt/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1360,
        "y": 540,
        "wires": [
            [
                "4d598865f45dba95"
            ]
        ]
    },
    {
        "id": "936a97a69f991ef2",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "DELETE RECEIPT",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const tables = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        const instance = new tables.Receipt(parseInt(msg.req.params.id));\n        msg.payload = await instance.del();\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2030,
        "y": 540,
        "wires": [
            [
                "dca361faf165c89e"
            ]
        ]
    },
    {
        "id": "dca361faf165c89e",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 540,
        "wires": []
    },
    {
        "id": "ac38a7f370289a70",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "API DELETE PROTOCOL",
        "url": "/delete_protocol/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1370,
        "y": 740,
        "wires": [
            [
                "f20f15658ab659f4"
            ]
        ]
    },
    {
        "id": "fd751ce4c28d9af5",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "DELETE PROTOCOL",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const tables = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        const instance = new tables.LibProtocol(parseInt(msg.req.params.id));\n        msg.payload = await instance.del();\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2040,
        "y": 740,
        "wires": [
            [
                "e91780233d69133f"
            ]
        ]
    },
    {
        "id": "e91780233d69133f",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 740,
        "wires": []
    },
    {
        "id": "02e4a9849fc1cce0",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "API UPDATE CLIENT",
        "url": "/delete_client/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1360,
        "y": 700,
        "wires": [
            [
                "dc8980003b75434a"
            ]
        ]
    },
    {
        "id": "d2423d0ea8a95d93",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "DELETE CLIENT",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const tables = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        const instance = new tables.Client(parseInt(msg.req.params.id));\n        msg.payload = await instance.del();\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2030,
        "y": 700,
        "wires": [
            [
                "bb16c58c90f01267"
            ]
        ]
    },
    {
        "id": "bb16c58c90f01267",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 700,
        "wires": []
    },
    {
        "id": "67fe2bd643ac2699",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "API DELETE RECEIPT PRICE",
        "url": "/delete_receipt_price/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1390,
        "y": 660,
        "wires": [
            [
                "dc00edbc1d6b60d6"
            ]
        ]
    },
    {
        "id": "e3c448a7cbb59b70",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "DELETE RECEIPT PRICE",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const tables = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        const instance = new tables.ReceiptPrice(parseInt(msg.req.params.id));\n        msg.payload = await instance.del();\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    }; \n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2060,
        "y": 660,
        "wires": [
            [
                "b79be0ea0d27758c"
            ]
        ]
    },
    {
        "id": "b79be0ea0d27758c",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 660,
        "wires": []
    },
    {
        "id": "ba10d56d12e1b578",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "API DELETE TEST ORDER",
        "url": "/delete_test_order/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1380,
        "y": 620,
        "wires": [
            [
                "12d845eb17999df7"
            ]
        ]
    },
    {
        "id": "9ef318e5bce73751",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "DELETE TEST ORDER",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const tables = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        const instance = new tables.TestOrder(parseInt(msg.req.params.id));\n        msg.payload = await instance.del();\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2050,
        "y": 620,
        "wires": [
            [
                "a1348c1128b1869e"
            ]
        ]
    },
    {
        "id": "a1348c1128b1869e",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 620,
        "wires": []
    },
    {
        "id": "c7eff8dab8a89e10",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "API DELETE SAMPLE",
        "url": "/delete_sample/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1360,
        "y": 580,
        "wires": [
            [
                "f6a4089b673a0ac4"
            ]
        ]
    },
    {
        "id": "0231068bedb8c4a5",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "DELETE SAMPLE",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        const instance = new tables.Sample(parseInt(msg.req.params.id));\n        msg.payload = await instance.del();\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2030,
        "y": 580,
        "wires": [
            [
                "73060267c865188a"
            ]
        ]
    },
    {
        "id": "73060267c865188a",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 580,
        "wires": []
    },
    {
        "id": "1dbbc1343366061c",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 360,
        "wires": []
    },
    {
        "id": "e056cbde63513d5e",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "EDIT TEST",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        const instance = new tables.Test(parseInt(msg.req.params.id));\n        node.warn({instance});\n        msg.payload = await instance.set(msg.req.body);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2010,
        "y": 360,
        "wires": [
            [
                "1dbbc1343366061c"
            ]
        ]
    },
    {
        "id": "dc084f8c4a46667c",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "API UPDATE TEST",
        "url": "/update_test/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1350,
        "y": 360,
        "wires": [
            [
                "c294c6107e202a98"
            ]
        ]
    },
    {
        "id": "2d9c5cb53d5128b6",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "DELETE TEST",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const tables = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        const instance = new tables.Test(parseInt(msg.req.params.id));\n        msg.payload = await instance.del();\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2020,
        "y": 780,
        "wires": [
            [
                "d02b0b8806e83641"
            ]
        ]
    },
    {
        "id": "d04be732f33bd157",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "API DELETE TEST",
        "url": "/delete_test/:id",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1350,
        "y": 780,
        "wires": [
            [
                "1a04ed24f6cc6744"
            ]
        ]
    },
    {
        "id": "d02b0b8806e83641",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 780,
        "wires": []
    },
    {
        "id": "a57ba12f9544130b",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 880,
        "wires": []
    },
    {
        "id": "c24017ec7b7e7ef2",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "NEW TEST",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    try {\n        msg.payload = await tables.Test.new(msg.req.body);\n        node.warn(JSON.parse(JSON.stringify(msg.payload)));\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 880,
        "wires": [
            [
                "a57ba12f9544130b"
            ]
        ]
    },
    {
        "id": "8b8d6d6c6541565a",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "API NEW TEST",
        "url": "/new_test",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 880,
        "wires": [
            [
                "9ec3457ba543d418"
            ]
        ]
    },
    {
        "id": "f0e75a4f004d5f1f",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 920,
        "wires": []
    },
    {
        "id": "466ba6a8521b0173",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "NEW REPORT",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    const { test_data, report_data } = msg.req.body;\n\n    // Khi to payload vi cc i tng mu\n    msg.payload = { test_report: [], sample_report: {} };\n\n    try {\n        if (test_data !== null && report_data !== null) {\n            // Kim tra s tn ti ca mu (sample)\n            if (report_data.sample_id !== null) {\n                const instance = new tables.Sample(report_data.sample_id);\n                if (await instance.get() === null) throw new Error('Sample khng tn ti');\n\n                // Thm vo CSDL\n                const addSampleReport = await tables.SampleReport.new(report_data);\n                node.warn(JSON.parse(JSON.stringify(addSampleReport)));\n                msg.payload.sample_report = report_data;\n            } else {\n                throw new Error('Sample ID l bt buc');\n            }\n\n            // Kim tra v thm d liu Test\n            if (Array.isArray(test_data)) {\n                for (const test of test_data) {\n                    if (test.test_order_id !== null) {\n                        const instance = new tables.TestOrder(test.test_order_id);\n                        if (await instance.get() === null) throw new Error('Test order khng tn ti');\n\n                        // Thm vo CSDL\n                        const addTestReport = await tables.TestReport.new(test);\n                        node.warn(JSON.parse(JSON.stringify(addTestReport)));\n                        msg.payload.test_report.push(test.test_order_id);\n                    } else {\n                        throw new Error('Test order ID l bt buc');\n                    }\n                }\n            } else {\n                throw new Error('test_data phi l mt mng khng rng cha cc i tng test order');\n            }\n\n        } else {\n            throw new Error('test_data v report_data u trng');\n        }\n\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 920,
        "wires": [
            [
                "f0e75a4f004d5f1f"
            ]
        ]
    },
    {
        "id": "d7e438f2818583dc",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "API NEW REPORT",
        "url": "/new_report",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 920,
        "wires": [
            [
                "ae7bc59d16d0fdaf"
            ]
        ]
    },
    {
        "id": "f78c27419ea047a0",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2250,
        "y": 400,
        "wires": []
    },
    {
        "id": "d9fba55b92a15b0a",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "REPUBLISH REPORT",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    node.warn(msg.req.body);\n\n    const {report_id, test_data, report_data } = msg.req.body;\n\n    // Khi to payload vi cc i tng mu\n    msg.payload = { test_report: [], sample_report: {} };\n\n    try {\n        if (test_data !== null && report_data !== null && report_id !== null) {\n            // Kim tra tn ti ca report\n            const instanceReport = new tables.SampleReport(report_id);\n            if(await instanceReport.get() === null) throw new Error('Report khng tn ti');\n            \n            // Kim tra s tn ti ca mu (sample)\n            if (report_data.sample_id !== null) {\n                const instance = new tables.Sample(report_data.sample_id);\n                if (await instance.get() === null) throw new Error('Sample khng tn ti');\n\n                // Update CSDL\n                const updateSampleReport = await instanceReport.set(report_data);\n                node.warn(JSON.parse(JSON.stringify(updateSampleReport)));\n                msg.payload.sample_report = report_data;\n            } else {\n                throw new Error('Sample ID l bt buc');\n            }\n\n            // Kim tra v thm d liu Test\n            if (Array.isArray(test_data)) {\n                for (const test of test_data) {\n                    // Kim tra tn ti ca report\n                    const instanceReport = new tables.TestReport(test.id);\n                    if (await instanceReport.get() === null) throw new Error('Test report khng tn ti');\n\n                    if (test.test_order_id !== null) {\n                        const instance = new tables.TestOrder(test.test_order_id);\n                        if (await instance.get() === null) throw new Error('Test order khng tn ti');\n\n                        // Update CSDL\n                        const setTestReport = await instanceReport.set(test);\n                        node.warn(JSON.parse(JSON.stringify(setTestReport)));\n                        msg.payload.test_report.push(test.id);\n                    } else {\n                        throw new Error('Test order ID l bt buc');\n                    }\n                }\n            } else {\n                throw new Error('test_data phi l mt mng khng rng cha cc i tng test order');\n            }\n\n        } else {\n            throw new Error('test_data v report_data u trng');\n        }\n\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2040,
        "y": 400,
        "wires": [
            [
                "f78c27419ea047a0"
            ]
        ]
    },
    {
        "id": "85b3df574eb3ea5f",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "API UPDATE REPORT",
        "url": "/update_report",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1360,
        "y": 400,
        "wires": [
            [
                "c4deafec07e8c394"
            ]
        ]
    },
    {
        "id": "7ac2b878b5e6dada",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "GET DETAIL_SAMPLE",
        "url": "/__api:LUoti0fR/ppt_editor/_get/sample/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "0883d98739d01269",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Detail Sample (NODERED)",
        "func": "try {\n    const axios = global.get('axios');\n\n    //Call check auth API\n    const authRes = await axios({\n        method: \"GET\",\n        url: \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        }\n    });\n\n    /* 1. Authentication */\n    if (authRes >= 400 ) {   // Auth rejected by Xano\n        const err = new Error;\n        err.payload = authRes.data;  // Error message by Xano\n        err.statusCode = authRes.statusCode;       // Enforcing 401\n        throw err;\n    }\n\n    /* 2. Main Logic */\n    const { Sample } = global.get('tables');           // Get Library\n    /**\n     * Sample.get(id) => return detail sample (includes create_by, test_orders, sample_prices, report )\n     */\n    \n    // input: id Number ( msg.req.params.id to Int )\n    const sample = await Sample.get(parseInt(msg.req.params.id));\n    // node.warn(sample);\n    \n    msg.payload = sample\n    return msg;\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;   // Default Internal Server Error\n    msg.payload = error.message;                // Error message\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 260,
        "wires": [
            [
                "1b858089d3952c94"
            ]
        ]
    },
    {
        "id": "d2ba316030500a68",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Detail Sample Report",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n  const table = global.get('tables');\n  node.warn(msg.req.params);\n  \n  try {\n      msg.payload = await table.SampleReport.fromSample(parseInt(msg.req.params.id));\n      node.warn(msg.payload);\n  } catch (error) {\n    node.warn(error);  \n  };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 300,
        "wires": [
            [
                "8b185a9b70fd48a6"
            ]
        ]
    },
    {
        "id": "61133677afef0b39",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "GET SAMPLE REPORT",
        "url": "/published_editor/_get_/sample_report/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 300,
        "wires": [
            [
                "45ac30c0effd0152"
            ]
        ]
    },
    {
        "id": "b4432e4647c01c2b",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "SEARCH CLIENT",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const table = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        msg.payload = await table.Client.searchClients(msg.req.params.search_q);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    }; \n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 1040,
        "wires": [
            [
                "897dbc479548c0f5"
            ]
        ]
    },
    {
        "id": "29dd40b4d7e0107e",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "API SEARCH CLIENT",
        "url": "/search/client/:search_q",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 1040,
        "wires": [
            [
                "c4202d2dfae9348e"
            ]
        ]
    },
    {
        "id": "897dbc479548c0f5",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 1040,
        "wires": []
    },
    {
        "id": "f39544220d8486be",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1150,
        "y": 180,
        "wires": []
    },
    {
        "id": "8a773f6151557090",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1150,
        "y": 220,
        "wires": []
    },
    {
        "id": "1b858089d3952c94",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1150,
        "y": 260,
        "wires": []
    },
    {
        "id": "8b185a9b70fd48a6",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 300,
        "wires": []
    },
    {
        "id": "52903accd4bc89dc",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "SEARCH RECEIPT",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const table = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        msg.payload = await table.Receipt.searchReceipts(msg.req.params.search_q);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 1080,
        "wires": [
            [
                "7f986d88b2a40fe8"
            ]
        ]
    },
    {
        "id": "91f156626870b43e",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "API SEARCH RECEIPT",
        "url": "/search/receipt/:search_q",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 1080,
        "wires": [
            [
                "7f98e111c988c39d"
            ]
        ]
    },
    {
        "id": "7f986d88b2a40fe8",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 1080,
        "wires": []
    },
    {
        "id": "e826f0647edf5a19",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "SEARCH TEST",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const table = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        msg.payload = await table.Test.searchTests(msg.req.params.search_q);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 1120,
        "wires": [
            [
                "2198b7da1905cdac"
            ]
        ]
    },
    {
        "id": "36b458d5e01b5403",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "API SEARCH TESTS",
        "url": "/search/lib_tests/:search_q",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 1120,
        "wires": [
            [
                "86bcfc5d027318c6"
            ]
        ]
    },
    {
        "id": "2198b7da1905cdac",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 1120,
        "wires": []
    },
    {
        "id": "0aff145959dd50bb",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "SEARCH PROTOCOL",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const table = global.get('tables');\n    node.warn(msg.req.params);\n\n    try {\n        msg.payload = await table.LibProtocol.searchProtocols(msg.req.params.search_q);\n        node.warn(msg.payload);\n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1160,
        "wires": [
            [
                "a4618a08f6727d63"
            ]
        ]
    },
    {
        "id": "b9c4e6f1aef3206c",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "API SEARCH PROTOCOL",
        "url": "/search/protocol/:search_q",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 1160,
        "wires": [
            [
                "77db71f819795db4"
            ]
        ]
    },
    {
        "id": "a4618a08f6727d63",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 1160,
        "wires": []
    },
    {
        "id": "bca9372ffa1b023c",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "GET BULK RECEIPT",
        "url": "/get_bulk_receipts",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 340,
        "wires": [
            [
                "a73cdf140457f4be"
            ]
        ]
    },
    {
        "id": "d59ee337f9ab37cb",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Bulk Receipts",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n    const listIds = JSON.parse(JSON.stringify(msg.req.body.receipt_ids));  // m bo ly gi tr ng t req.body\n\n    try {\n        node.warn(listIds); // Hin th listIds  kim tra u vo\n\n        // Khi to msg.payload nu cha tn ti\n        if (!Array.isArray(msg.payload)) {\n            msg.payload = [];\n        }\n\n        if (Array.isArray(listIds)) {\n            for (const id of listIds) {\n                // S dng 'await' trong mt hm async, cn chuyn sang async function nu cha\n                const receipt = await tables.Receipt.recentReceipts({receipt_id:id});\n                msg.payload.push(receipt);\n            }\n        }\n\n        node.warn(msg.payload); // Hin th msg.payload  kim tra kt qu\n    } catch (error) {\n        node.warn(error); // Hin th li nu c\n    }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 340,
        "wires": [
            [
                "9627c1cf4a4705d7"
            ]
        ]
    },
    {
        "id": "9627c1cf4a4705d7",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 340,
        "wires": []
    },
    {
        "id": "9cdb69be95b74456",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Assign dept list",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n\n    try {\n        const result = await tables.LibLab.get_assign_dept_list();\n        msg.payload =  result;\n        node.warn(result); \n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 380,
        "wires": [
            [
                "89f334513d8a7aed"
            ]
        ]
    },
    {
        "id": "b79cca0ee4983469",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "GET ASSIGN DEPT LIST",
        "url": "/get_assign_dept_list",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 380,
        "wires": [
            [
                "169c04a123d19263"
            ]
        ]
    },
    {
        "id": "89f334513d8a7aed",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 380,
        "wires": []
    },
    {
        "id": "866bd3c2bcb204ef",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Protocol",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n\n    try {\n        const instace = new tables.LibProtocol(parseInt(msg.req.params.id));\n        await instace.get();\n        const result = JSON.parse(JSON.stringify(instace));\n        msg.payload = result;\n        node.warn(result); \n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 420,
        "wires": [
            [
                "a00bb57686b43652"
            ]
        ]
    },
    {
        "id": "330c225a9b475ed1",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "GET PROTOCOL",
        "url": "/get_protocol/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 420,
        "wires": [
            [
                "a2f27f11f0b1c6be"
            ]
        ]
    },
    {
        "id": "a00bb57686b43652",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 420,
        "wires": []
    },
    {
        "id": "288510282f69d5b1",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Test",
        "func": "node.warn(msg);\n\nif (msg.statusCode === 401) {\n    msg.payload = JSON.parse(msg.payload);\n} else {\n    const tables = global.get('tables');\n\n    try {\n        const instace = new tables.Test(parseInt(msg.req.params.id));\n        await instace.get();\n        const result = JSON.parse(JSON.stringify(instace));\n        msg.payload = result;\n        node.warn(result); \n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 840,
        "y": 460,
        "wires": [
            [
                "161a93311580789c"
            ]
        ]
    },
    {
        "id": "2ddb9dff9ac99ee6",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "GET TEST",
        "url": "/get_test/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 460,
        "wires": [
            [
                "6718453f8429033a"
            ]
        ]
    },
    {
        "id": "161a93311580789c",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 460,
        "wires": []
    },
    {
        "id": "8750262fcb1b0607",
        "type": "function",
        "z": "b9028a431261c8bd",
        "name": "Verify Token",
        "func": "const token = msg.headers.authorization\n\n// split: header, payload, v signature\nconst parts = token.split('.');\n\nif (parts.length !== 3) {\n    throw new Error('Invalid JWT token');\n}\n\n// Base64URL to JSON\nconst base64urlDecode = (base64url) => {\n    return Buffer.from(base64url, 'base64')\n        .toString('utf8');\n};\n\n//decode\nconst decodedHeader = JSON.parse(base64urlDecode(parts[0]));\nconst decodedPayload = JSON.parse(base64urlDecode(parts[1]));\nconst decodedSignature = parts[2];\n\n\nif (decodedPayload.expiration > Date.now()){\n    const date = new Date(decodedPayload.expiration).toLocaleString();\n    // decodedPayload.expiration = date;\n    msg.payload = decodedPayload;\n}else {\n    msg.payload = 'Invalid Token';\n}\n\nconst tables = global.get('tables');\nconst user = new tables.User(decodedPayload.user.id);\nawait user.authenticate();\n\n\nnode.warn(msg.payload);\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 1240,
        "wires": [
            []
        ]
    },
    {
        "id": "3e70395521109352",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Recent Receipt By SampleID (XANO)",
        "func": "node.warn(msg);\nconst axios = global.get('axios');\n\ntry {\n    /* 1. Forward request to XANO */\n    try {\n        const xanoReq = {\n            url : \"https://xn.irdop.org/api:hrFfPpfK/sample_detail/_get/sample/\" + msg.req.params.sample_id, // URL ca API\n            method : \"GET\",\n            headers : {\n                \"Content-Type\": \"application/json\",\n                \"authorization\": msg.req.headers.authorization\n            },\n        }\n        const xanoRes = await axios({\n            method: xanoReq.method,\n            url: xanoReq.url,\n            headers: xanoReq.headers,\n        });\n        // return without \n        msg.payload = xanoRes.data;\n        // return msg;\n    } catch (error) {\n        // Handle errors\n        if (error.response) {\n            msg.statusCode = error.response.status;\n            msg.payload = error.response.data;\n        } else if (error.request) {\n            // no connection to xano\n            msg.statusCode = 500;\n            msg.payload = {\n                error : {\n                    message: \"No connection to XN database\",\n                    code: 500\n                }\n            }\n        } else {\n            // Something happened in setting up the request that triggered an Error\n            msg.statusCode = 500;\n            msg.payload = {\n                error : {\n                    message: \"Unexpected error\",\n                    code: 500\n                }\n            }\n            node.warn(\"Unexpected error @ forwarding Xano request for /recent_receipts API endpoint\")\n        }\n        return msg;\n    }\n\n    return msg;\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;   // Default Internal Server Error\n    msg.payload = error.message;                // Error message\n    return msg;\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 180,
        "wires": [
            [
                "b2ab025f0662937f"
            ]
        ]
    },
    {
        "id": "0931d21a7b4a4c80",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 300,
        "wires": [
            [
                "d2ba316030500a68"
            ]
        ]
    },
    {
        "id": "45ac30c0effd0152",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 300,
        "wires": [
            [
                "0931d21a7b4a4c80"
            ]
        ]
    },
    {
        "id": "862eea9415dbd9f4",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 340,
        "wires": [
            [
                "d59ee337f9ab37cb"
            ]
        ]
    },
    {
        "id": "a73cdf140457f4be",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 340,
        "wires": [
            [
                "862eea9415dbd9f4"
            ]
        ]
    },
    {
        "id": "de4b3a866a8e7494",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 380,
        "wires": [
            [
                "9cdb69be95b74456"
            ]
        ]
    },
    {
        "id": "169c04a123d19263",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 380,
        "wires": [
            [
                "de4b3a866a8e7494"
            ]
        ]
    },
    {
        "id": "a2a1ada42ebcf374",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 420,
        "wires": [
            [
                "866bd3c2bcb204ef"
            ]
        ]
    },
    {
        "id": "a2f27f11f0b1c6be",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 420,
        "wires": [
            [
                "a2a1ada42ebcf374"
            ]
        ]
    },
    {
        "id": "bea632b38357d612",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 460,
        "wires": [
            [
                "288510282f69d5b1"
            ]
        ]
    },
    {
        "id": "6718453f8429033a",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 460,
        "wires": [
            [
                "bea632b38357d612"
            ]
        ]
    },
    {
        "id": "180ee19af01a8013",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 600,
        "wires": [
            [
                "2f9c6e2c722f0eca"
            ]
        ]
    },
    {
        "id": "2f9c6e2c722f0eca",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 600,
        "wires": [
            [
                "40a89dc6e9cf1716"
            ]
        ]
    },
    {
        "id": "4bb0ebc71c4626ae",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 640,
        "wires": [
            [
                "3bc3ade665fd95a1"
            ]
        ]
    },
    {
        "id": "3bc3ade665fd95a1",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 640,
        "wires": [
            [
                "8f9abe643d6230e0"
            ]
        ]
    },
    {
        "id": "1fe325820ebffb6f",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 680,
        "wires": [
            [
                "bbeb14bffbca71fb"
            ]
        ]
    },
    {
        "id": "bbeb14bffbca71fb",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 680,
        "wires": [
            [
                "10ba5665c41039a6"
            ]
        ]
    },
    {
        "id": "1807f2950052995e",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 720,
        "wires": [
            [
                "e0d0a4a9fb0e96ba"
            ]
        ]
    },
    {
        "id": "e0d0a4a9fb0e96ba",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 720,
        "wires": [
            [
                "29edd99d5611d6d4"
            ]
        ]
    },
    {
        "id": "5319907d595c741f",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 760,
        "wires": [
            [
                "bab4b2c89e96e7e2"
            ]
        ]
    },
    {
        "id": "bab4b2c89e96e7e2",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 760,
        "wires": [
            [
                "e55e2d06b698d4be"
            ]
        ]
    },
    {
        "id": "726dfa9ff66f9335",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 800,
        "wires": [
            [
                "1a972f172c4e19b2"
            ]
        ]
    },
    {
        "id": "1a972f172c4e19b2",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 800,
        "wires": [
            [
                "618e59aa269e2ee6"
            ]
        ]
    },
    {
        "id": "498da67479a8223b",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 840,
        "wires": [
            [
                "a2b8702f23e75ba1"
            ]
        ]
    },
    {
        "id": "a2b8702f23e75ba1",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 840,
        "wires": [
            [
                "a6d6a440fb0fe680"
            ]
        ]
    },
    {
        "id": "9ec3457ba543d418",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 880,
        "wires": [
            [
                "968b8efce82c5727"
            ]
        ]
    },
    {
        "id": "968b8efce82c5727",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 880,
        "wires": [
            [
                "c24017ec7b7e7ef2"
            ]
        ]
    },
    {
        "id": "ae7bc59d16d0fdaf",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 920,
        "wires": [
            [
                "285c4739dc7930ac"
            ]
        ]
    },
    {
        "id": "285c4739dc7930ac",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "e956e789109d8613",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 920,
        "wires": [
            [
                "466ba6a8521b0173"
            ]
        ]
    },
    {
        "id": "5c7488c5b54210fa",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 120,
        "wires": [
            [
                "804d7591b1e06067"
            ]
        ]
    },
    {
        "id": "804d7591b1e06067",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 120,
        "wires": [
            [
                "1d4bab6811cbe5a6"
            ]
        ]
    },
    {
        "id": "9ad0e4463f21488f",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 160,
        "wires": [
            [
                "eb11da62e9f52618"
            ]
        ]
    },
    {
        "id": "eb11da62e9f52618",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 160,
        "wires": [
            [
                "3f64bebf8610ebf4"
            ]
        ]
    },
    {
        "id": "edd0a1ac31b4087e",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 200,
        "wires": [
            [
                "1dc9ba5674c471ce"
            ]
        ]
    },
    {
        "id": "1dc9ba5674c471ce",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 200,
        "wires": [
            [
                "6f196ff5fc7fe4eb"
            ]
        ]
    },
    {
        "id": "df7a4ee26b223100",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 240,
        "wires": [
            [
                "9a89cb5ef8db6c07"
            ]
        ]
    },
    {
        "id": "9a89cb5ef8db6c07",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 240,
        "wires": [
            [
                "99d665f0443c73d7"
            ]
        ]
    },
    {
        "id": "173d7eea94be9a62",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 280,
        "wires": [
            [
                "283db352e4a59a69"
            ]
        ]
    },
    {
        "id": "283db352e4a59a69",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 280,
        "wires": [
            [
                "08919acebc7bba71"
            ]
        ]
    },
    {
        "id": "5ccdfdde1ca97c53",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 320,
        "wires": [
            [
                "d3226963e335a503"
            ]
        ]
    },
    {
        "id": "d3226963e335a503",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 320,
        "wires": [
            [
                "7a5534ae08bd0762"
            ]
        ]
    },
    {
        "id": "c294c6107e202a98",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 360,
        "wires": [
            [
                "2d9879d148e475be"
            ]
        ]
    },
    {
        "id": "2d9879d148e475be",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 360,
        "wires": [
            [
                "e056cbde63513d5e"
            ]
        ]
    },
    {
        "id": "c4deafec07e8c394",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 400,
        "wires": [
            [
                "b950eb01c040c9ef"
            ]
        ]
    },
    {
        "id": "b950eb01c040c9ef",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "0a854dfffe5aa1e7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 400,
        "wires": [
            [
                "d9fba55b92a15b0a"
            ]
        ]
    },
    {
        "id": "4d598865f45dba95",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 540,
        "wires": [
            [
                "bb33aac87489b347"
            ]
        ]
    },
    {
        "id": "bb33aac87489b347",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 540,
        "wires": [
            [
                "936a97a69f991ef2"
            ]
        ]
    },
    {
        "id": "f6a4089b673a0ac4",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 580,
        "wires": [
            [
                "ee08da16a0c3b673"
            ]
        ]
    },
    {
        "id": "ee08da16a0c3b673",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 580,
        "wires": [
            [
                "0231068bedb8c4a5"
            ]
        ]
    },
    {
        "id": "12d845eb17999df7",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 620,
        "wires": [
            [
                "59816f1d47d056c1"
            ]
        ]
    },
    {
        "id": "59816f1d47d056c1",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 620,
        "wires": [
            [
                "9ef318e5bce73751"
            ]
        ]
    },
    {
        "id": "dc00edbc1d6b60d6",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 660,
        "wires": [
            [
                "88569d79d47273ba"
            ]
        ]
    },
    {
        "id": "88569d79d47273ba",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 660,
        "wires": [
            [
                "e3c448a7cbb59b70"
            ]
        ]
    },
    {
        "id": "dc8980003b75434a",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 700,
        "wires": [
            [
                "58a7773599e18b9f"
            ]
        ]
    },
    {
        "id": "58a7773599e18b9f",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 700,
        "wires": [
            [
                "d2423d0ea8a95d93"
            ]
        ]
    },
    {
        "id": "f20f15658ab659f4",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 740,
        "wires": [
            [
                "5050e6676e5fb3d0"
            ]
        ]
    },
    {
        "id": "5050e6676e5fb3d0",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 740,
        "wires": [
            [
                "fd751ce4c28d9af5"
            ]
        ]
    },
    {
        "id": "1a04ed24f6cc6744",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 780,
        "wires": [
            [
                "94277d28497a6667"
            ]
        ]
    },
    {
        "id": "94277d28497a6667",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "f2fcd8507fa996af",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1830,
        "y": 780,
        "wires": [
            [
                "2d9c5cb53d5128b6"
            ]
        ]
    },
    {
        "id": "c4202d2dfae9348e",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 1040,
        "wires": [
            [
                "7a70110d7f0dc399"
            ]
        ]
    },
    {
        "id": "7a70110d7f0dc399",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 1040,
        "wires": [
            [
                "b4432e4647c01c2b"
            ]
        ]
    },
    {
        "id": "7f98e111c988c39d",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 1080,
        "wires": [
            [
                "0acf9b908c1d63bd"
            ]
        ]
    },
    {
        "id": "0acf9b908c1d63bd",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 1080,
        "wires": [
            [
                "52903accd4bc89dc"
            ]
        ]
    },
    {
        "id": "86bcfc5d027318c6",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 1120,
        "wires": [
            [
                "594dae7fdb0a89b3"
            ]
        ]
    },
    {
        "id": "594dae7fdb0a89b3",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 1120,
        "wires": [
            [
                "e826f0647edf5a19"
            ]
        ]
    },
    {
        "id": "77db71f819795db4",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 1160,
        "wires": [
            [
                "4ee0681f5ff263de"
            ]
        ]
    },
    {
        "id": "4ee0681f5ff263de",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "2ed4e9fed9718eaf",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 1160,
        "wires": [
            [
                "0aff145959dd50bb"
            ]
        ]
    },
    {
        "id": "eaff877ae2f522c1",
        "type": "inject",
        "z": "b9028a431261c8bd",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 1240,
        "wires": [
            [
                "166b364281f764e8"
            ]
        ]
    },
    {
        "id": "166b364281f764e8",
        "type": "function",
        "z": "b9028a431261c8bd",
        "name": "login",
        "func": "const tables = global.get('tables');\n\ntry{\n    const email = \"trantu02.efw@gmail.com\";\n    const password = \"123abcd\";\n\n    const login = await tables.User.login(email,password);\n\n    node.warn(login);\n    \n    msg.headers = {\n        \"Content-Type\": \"application/json\",\n        \"authorization\": login.token\n    };\n        \n}catch(error){\n    node.warn(error);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 1240,
        "wires": [
            [
                "8750262fcb1b0607"
            ]
        ]
    },
    {
        "id": "e9b9294645378dfa",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 500,
        "wires": [
            [
                "70de676005121b16"
            ]
        ]
    },
    {
        "id": "88e91b3e8e0ed5bf",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "GET PROCESSING SAMPLE",
        "url": "/get_processing_sample",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 500,
        "wires": [
            [
                "e9b9294645378dfa"
            ]
        ]
    },
    {
        "id": "70de676005121b16",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 650,
        "y": 500,
        "wires": [
            [
                "40af4e7cfc184a2e"
            ]
        ]
    },
    {
        "id": "40af4e7cfc184a2e",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Processing Sample",
        "func": "node.warn(msg);\n\nif(msg.statusCode === 401){\n    msg.payload = JSON.parse(msg.payload);\n}else{\n    const tables = global.get('tables');\n\n    try {\n        const result = await tables.Sample.getProcessings();\n        msg.payload =  result;\n        node.warn(result); \n    } catch (error) {\n        node.warn(error);\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 500,
        "wires": [
            [
                "d261b8c9eb4eab4d"
            ]
        ]
    },
    {
        "id": "d261b8c9eb4eab4d",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 500,
        "wires": []
    },
    {
        "id": "9f49f384954a660c",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get All Recent Receipt (NODERED)",
        "func": "try {\n    const axios = global.get('axios');\n\n    //Call check auth API\n    const authRes = await axios({\n        method: \"GET\",\n        url: \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        }\n    });\n\n    /* 1. Authentication */\n    if (authRes >= 400 ) {   // Auth rejected by Xano\n        const err = new Error;\n        err.payload = authRes.data;  // Error message by Xano\n        err.statusCode = authRes.statusCode;       // Enforcing 401\n        throw err;\n    }\n\n    /* 2. Main Logic */\n    const { Receipt } = global.get('tables');           // Get Library\n    /**\n     * Receipt.recentReceipts() => return list recent receipts\n     * Receipt.recentReceipts({receipt_id: Number}) => return detail Receipt by receipt_id\n     * Receipt.recentReceipts({sample_id: Number}) => return detail Receipt by sample.sample_receipt_id\n     */\n    \n    const recentReceipts = await Receipt.recentReceipts();       \n    node.warn(recentReceipts);\n    \n    msg.payload = recentReceipts\n    return msg;\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;   // Default Internal Server Error\n    msg.payload = error.message;                // Error message\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 140,
        "wires": [
            [
                "4064c40a44d53526"
            ]
        ]
    },
    {
        "id": "0dae4bc5b866ba78",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Recent Receipt By ReceiptID (XANO)",
        "func": "node.warn(msg);\nconst axios = global.get('axios');\n\ntry {\n    /* 1. Forward request to XANO */\n    try {\n        const xanoReq = {\n            url : \"https://xn.irdop.org/api:hrFfPpfK/receipt_detail/_get/receipt/\" + msg.req.params.receipt_id, // URL ca API\n            method : \"GET\",\n            headers : {\n                \"Content-Type\": \"application/json\",\n                \"authorization\": msg.req.headers.authorization\n            },\n        }\n        const xanoRes = await axios({\n            method: xanoReq.method,\n            url: xanoReq.url,\n            headers: xanoReq.headers,\n        });\n        // return without \n        msg.payload = xanoRes.data;\n        // return msg;\n    } catch (error) {\n        // Handle errors\n        if (error.response) {\n            msg.statusCode = error.response.status;\n            msg.payload = error.response.data;\n        } else if (error.request) {\n            // no connection to xano\n            msg.statusCode = 500;\n            msg.payload = {\n                error : {\n                    message: \"No connection to XN database\",\n                    code: 500\n                }\n            }\n        } else {\n            // Something happened in setting up the request that triggered an Error\n            msg.statusCode = 500;\n            msg.payload = {\n                error : {\n                    message: \"Unexpected error\",\n                    code: 500\n                }\n            }\n            node.warn(\"Unexpected error @ forwarding Xano request for /recent_receipts API endpoint\")\n        }\n        return msg;\n    }\n\n    return msg;\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;   // Default Internal Server Error\n    msg.payload = error.message;                // Error message\n    return msg;\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 220,
        "wires": [
            [
                "98cbfac8213259b5"
            ]
        ]
    },
    {
        "id": "19621298ec0e60f2",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Get Detail Sample (XANO)",
        "func": "node.warn(msg);\nconst axios = global.get('axios');\n\ntry {\n    /* 1. Forward request to XANO */\n    try {\n        const xanoReq = {\n            url: \"https://xn.irdop.org/api:LUoti0fR/ppt_editor/_get/sample/\" + msg.req.params.id, // URL ca API\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"authorization\": msg.req.headers.authorization\n            },\n        }\n        const xanoRes = await axios({\n            method: xanoReq.method,\n            url: xanoReq.url,\n            headers: xanoReq.headers,\n        });\n        // return without \n        msg.payload = xanoRes.data;\n        // return msg;\n    } catch (error) {\n        // Handle errors\n        if (error.response) {\n            msg.statusCode = error.response.status;\n            msg.payload = error.response.data;\n        } else if (error.request) {\n            // no connection to xano\n            msg.statusCode = 500;\n            msg.payload = {\n                error: {\n                    message: \"No connection to XN database\",\n                    code: 500\n                }\n            }\n        } else {\n            // Something happened in setting up the request that triggered an Error\n            msg.statusCode = 500;\n            msg.payload = {\n                error: {\n                    message: \"Unexpected error\",\n                    code: 500\n                }\n            }\n            node.warn(\"Unexpected error @ forwarding Xano request for /recent_receipts API endpoint\")\n        }\n        return msg;\n    }\n\n    return msg;\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;   // Default Internal Server Error\n    msg.payload = error.message;                // Error message\n    return msg;\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "8ca2368efbf7f6fc",
        "type": "http in",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "auth_me",
        "url": "/api:e2HKBcnJ/auth/me_employee",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 60,
        "wires": [
            [
                "f33fc3082accd167"
            ]
        ]
    },
    {
        "id": "b807bb2f43fcbf69",
        "type": "function",
        "z": "b9028a431261c8bd",
        "name": "Call AuthMe",
        "func": "try {\n    const axios = global.get('axios');\n\n    //Call check auth API\n    const authRes = await axios({\n        method: \"GET\",\n        url: \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        }\n    });\n    msg.payload = authRes;\n\n    return msg;\n\n}catch(error){\n    node.warn(error);\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 40,
        "wires": [
            [
                "f077dc4d810a9d7d"
            ]
        ]
    },
    {
        "id": "f077dc4d810a9d7d",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 590,
        "y": 40,
        "wires": []
    },
    {
        "id": "f33fc3082accd167",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "Call AuthMe",
        "func": "\nmsg.url = \"https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee\"; // URL ca API\nmsg.method = \"GET\";\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"authorization\": msg.req.headers.authorization\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 80,
        "wires": [
            [
                "15bdbe38cdbed656"
            ]
        ]
    },
    {
        "id": "15bdbe38cdbed656",
        "type": "http request",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 570,
        "y": 80,
        "wires": [
            [
                "37e6357ee56f358d"
            ]
        ]
    },
    {
        "id": "32237266132f9dd7",
        "type": "http response",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 850,
        "y": 80,
        "wires": []
    },
    {
        "id": "37e6357ee56f358d",
        "type": "function",
        "z": "b9028a431261c8bd",
        "g": "41b667f64e4a22d7",
        "name": "function 3",
        "func": "msg.payload = JSON.parse(msg.payload);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 80,
        "wires": [
            [
                "32237266132f9dd7"
            ]
        ]
    },
    {
        "id": "1cb34f3ccb1d836b",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "g": "a428cef3584244ff",
        "name": "post new receit",
        "url": "/new_receipt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 180,
        "wires": [
            [
                "47f3cb2d817de769"
            ]
        ]
    },
    {
        "id": "47f3cb2d817de769",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "newReceipt",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { Receipt } = global.get(\"tables\");\n\ntry {\n    let receipt;            // Storing Created Receipt Object\n\n    /** 1. AUTHENTICATE */\n    if (xano.bridge_api) {\n        // This block is intentionally left blank\n        // If bridge_api is true, Authentication is alreadt done in Xano\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. CREATE RECORD */\n    if (xano.bridge_api) {  // Forward to xano\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            authorization: msg.req.headers.authorization,\n        };\n        const xanoResponse = await xano.post_create_receipt(\n            headers,\n            msg.req.body,\n        );\n        receipt = xanoResponse.data;\n    }\n    else {                  // USE Node-RED engine\n        // TODO: Auth\n        const newReceipt = msg.req.params.new_receipt;\n        // newReceipt = new Receipt.create(newReceipt)\n        // Post to Xano ... \n    }\n\n    /** 3. SET CACHE */\n    if (                    // Kiem tra neu new receipt chua them vao cache\n        receipt &&                                                          // receipt must exist to be added to cache\n        cache.recentReceipts &&                                             // cache must exist\n        cache.recentReceipts.value &&                                       // cache must have a value\n        (Date.now() - cache.recentReceipts.cached_at) < 4 * 60 * 1000 &&    // this cache must still be valid\n        cache.recentReceipts.value[0] &&                                    // there must be at least one receipt in the cache\n        cache.recentReceipts.value[0].receipt_uid !== receipt.receipt_uid   // The first receipt in cache is not the same as the new receipt\n    ) {\n        cache.recentReceipts.cached_at = Date.now();\n        cache.recentReceipts.value = [receipt, ...cache.recentReceipts.value];   // Add new receipt to the beginning of the array\n    }\n\n    /** 4. RETURN TO CLIENT */\n    msg.payload = receipt;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Create receipt error: \" + error);\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 180,
        "wires": [
            [
                "4440c61fceb80da0"
            ]
        ]
    },
    {
        "id": "4440c61fceb80da0",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 690,
        "y": 180,
        "wires": []
    },
    {
        "id": "a0ecf94ea2cb05c1",
        "type": "http in",
        "z": "46183d332de8b18f",
        "name": "post new sample",
        "url": "/new_sample",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 880,
        "y": 180,
        "wires": [
            [
                "3edb570284f771a3"
            ]
        ]
    },
    {
        "id": "3edb570284f771a3",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "New Sample",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { Sample } = global.get(\"tables\");\n\ntry {\n    let sample;\n\n\n    /** 1. AUTHENTICATE */\n    if (xano.bridge_api) {\n        // This block is intentionally left blank\n        // If bridge_api is true, Authentication is alreadt done in Xano\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. CREATE RECORD */\n    if (xano.bridge_api) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            authorization: msg.req.headers.authorization,\n        };\n        const xanoResponse = await xano.post_create_sample(\n            headers,\n            msg.req.body,\n        );\n        sample = xanoResponse.data;\n    } else {    // TODO: Auth, Red table,... forward to xano ,...\n        sample = await Sample.new(msg.req.body.new_sample);\n    }\n\n    /** 3. SET CACHE IF EXIST*/\n    const expireTime = 4 * 60 * 1000; // 4 minutes\n    if (\n        cache.recentReceipts &&\n        cache.recentReceipts.value &&\n        Date.now() - cache.recentReceipts.cached_at < expireTime\n    ) {\n        const receipt_idx = cache.recentReceipts.value.findIndex((receipt) => receipt.id === sample.sample_receipt_id);\n        if (receipt_idx !== -1) {   // only update if target receipt is in cache\n            cache.recentReceipts.value[receipt_idx].samples.unshift(sample);\n            cache.recentReceipts.cached_at = Date.now();\n        }\n    }\n\n    /** 4. RETURN TO CLIENT */\n    msg.payload = sample;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Create Sample error: \" + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1090,
        "y": 180,
        "wires": [
            [
                "8825701f46bed688"
            ]
        ]
    },
    {
        "id": "8825701f46bed688",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1390,
        "y": 180,
        "wires": []
    },
    {
        "id": "5d6051887d23491b",
        "type": "http in",
        "z": "46183d332de8b18f",
        "name": "post new test",
        "url": "/new_tests",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 870,
        "y": 220,
        "wires": [
            [
                "f05bdc909167b761"
            ]
        ]
    },
    {
        "id": "f05bdc909167b761",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "New Tests From Sample",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { TestOrder } = global.get(\"tables\");\n\ntry {\n    let test;\n\n    /** 1. CREATE RECORD */\n    if (xano.bridge_api) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            authorization: msg.req.headers.authorization,\n        };\n        const xanoResponse = await xano.post_sample_add_tests(\n            headers,\n            msg.req.body,\n        );\n        test = xanoResponse.data;\n    } else {\n        // USE Red DB\n        //msg.req.body: receipt_id Number, sample_id Number, tests Array<Test {object}>\n        // matching lib_test_id\n    }\n\n    /** 2. SET CACHE IF EXIST*/\n    if (cache.recentReceipts && cache.recentReceipts.value) {\n        const receipt_idx = cache.recentReceipts.value.findIndex((receipt) => receipt.id === test.sample.sample_receipt_id);\n        if (receipt_idx !== -1) {   // only update if target receipt is in cache\n            const sample_idx = cache.recentReceipts.value[receipt_idx].samples.findIndex((sample) => sample.id === test.sample_id);\n            if (sample_idx !== -1) {   // only update if target sample is in cache\n                cache.recentReceipts.value[receipt_idx].samples[sample_idx] = [test, ...cache.recentReceipts.value[receipt_idx].samples];\n            }\n        }\n    }\n\n    msg.payload = test;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Add test orders error: \" + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 220,
        "wires": [
            [
                "f37928b7cb2b2ed1"
            ]
        ]
    },
    {
        "id": "f37928b7cb2b2ed1",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1390,
        "y": 220,
        "wires": []
    },
    {
        "id": "f57454ef879ae3c5",
        "type": "http in",
        "z": "46183d332de8b18f",
        "name": "post del tests",
        "url": "/delete_tests",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 870,
        "y": 340,
        "wires": [
            [
                "6878f1a486c9b760"
            ]
        ]
    },
    {
        "id": "6878f1a486c9b760",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "Delete tests from sample",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\n\ntry {\n    let tests;\n\n    /** 1. CREATE RECORD */\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"authorization\": msg.req.headers.authorization\n    }\n\n    if (xano.bridge_api) {      // USE XANO BRIDGE\n        /** 1. Send and receive Xano Request */\n        const xanoResponse = await xano.post_create_receipt(headers, msg.params.body);\n        tests = xanoResponse.data;\n    }\n    else {                      // USE Red DB\n        // TODO: \n    }\n\n    const recentReceipts_cache = cache.recentReceipts;\n\n    /** 2. SET CACHE IF EXIST*/\n    if (tests.status === 200) {\n        const expireTime = 4 * 60 * 1000; // 4 minutes\n        if (\n            recentReceipts_cache &&\n            Date.now() - recentReceipts_cache.cached_at < expireTime\n        ) {\n            // SET VALUE\n            const index = cache.recentReceipts.value.findIndex((receipt) => receipt.id === msg.req.body.receipt_id);\n            let newCacheValue = recentReceipts_cache.value;\n            if (index !== -1) {\n                newCacheValue[index] = tests.receipt;\n                cache.recentReceipts = {\n                    value: newCacheValue,\n                    cached_at: Date.now(),\n                };\n            }\n        }\n    } else {\n        throw new Error(\"Xano Auth API returned non-200 status\");\n    }\n\n    msg.payload = tests;\n    return msg;\n} catch (error) {\n    node.warn(\"Delete tests from sample: \" + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 340,
        "wires": [
            [
                "ab39f1dd0b94bb74"
            ]
        ]
    },
    {
        "id": "ab39f1dd0b94bb74",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1390,
        "y": 340,
        "wires": []
    },
    {
        "id": "e076c647d56e2f1f",
        "type": "http in",
        "z": "46183d332de8b18f",
        "name": "post del sample",
        "url": "/delete_sample",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 880,
        "y": 300,
        "wires": [
            [
                "46fea14699ef1847"
            ]
        ]
    },
    {
        "id": "46fea14699ef1847",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "Delete Sample",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\n\ntry {\n    let sample;\n\n    /** 1. CREATE RECORD */\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"authorization\": msg.req.headers.authorization\n    }\n\n    if (xano.bridge_api) {      // USE XANO BRIDGE\n        /** 1. Send and receive Xano Request */\n        const xanoResponse = await xano.post_delete_sample(\n            headers,\n            msg.req.body,\n        );\n        sample = xanoResponse.data;\n    }\n    else {                      // USE Red DB\n        // TODO: \n    }\n\n    const recentReceipts_cache = cache.recentReceipts;\n\n    /** 2. SET CACHE IF EXIST*/\n\n    if (sample.status === 200) {\n        const expireTime = 4 * 60 * 1000; // 4 minutes\n        if (\n            recentReceipts_cache &&\n            Date.now() - recentReceipts_cache.cached_at < expireTime\n        ) {\n            const index = cache.recentReceipts.value.findIndex((receipt) => receipt.id === sample.id);\n            node.warn(index);\n            let newCacheValue = recentReceipts_cache.value;\n            if (index !== -1) {\n                newCacheValue[index] = sample;\n                cache.recentReceipts = {\n                    value: newCacheValue,\n                    cached_at: Date.now(),\n                };\n            }\n\n            node.warn(cache.recentReceipts.value);\n        }\n    } else {\n        throw new Error(\"Xano Auth API returned non-200 status\");\n    }\n\n    msg.payload = sample;\n    return msg;\n} catch (error) {\n    node.warn(\"Delete sample: \" + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 300,
        "wires": [
            [
                "ec26d24551a1aef0"
            ]
        ]
    },
    {
        "id": "ec26d24551a1aef0",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1390,
        "y": 300,
        "wires": []
    },
    {
        "id": "13104256e551823a",
        "type": "comment",
        "z": "46183d332de8b18f",
        "name": "Readme",
        "info": "2024-11-24 Update:\nxanoLayer: \nImprove xano api try-catch axios block (correct message for client browsers)\n\nOverhaul logic of API NODES:\n- GET: getRecentReceipt\n- GET: getProcessingSample\n- POST: new receipt\n- POST: new sample\n\nNew APIs:\n- Submit result: Update cache on processingSamples for all users",
        "x": 140,
        "y": 60,
        "wires": []
    },
    {
        "id": "d351b04153bfba19",
        "type": "http in",
        "z": "46183d332de8b18f",
        "g": "3b5fddf13427ab4a",
        "name": "POST: Submit test result",
        "url": "/api:eHOTU1fm/POST/_edit/submit_result",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 520,
        "wires": [
            [
                "b8c068dee7f01d2a"
            ]
        ]
    },
    {
        "id": "b8c068dee7f01d2a",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "3b5fddf13427ab4a",
        "name": "Submit test result",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { Receipt } = global.get(\"tables\");\nnode.warn('API HIT: A new test result just submitted');\n/**\n * @param {Object} msg - The message object containing the request data\n * @param {Object} msg.req.body - The request body containing test results\n * @param {Object} msg.req.body.result_submit - The test result data\n * @returns {Promise<{test_order, protocol}|Error>} - A promise that resolves with the test result response or an error\n */\n\ntry {\n    let result_submit;        // Storing requested test result\n    let test_return;          // result return to client\n\n    /** 1. AUTHENTICATE */\n    if (xano.bridge_auth) {         // Forward to XN server\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        };\n        const authResponse = await xano.auth_me_employee(headers);\n    }\n    else {                          // Use Node-RED engine\n        // TODO: RED auth\n    }\n\n    /** 2. SUBMIT TEST RESULT */\n    if (xano.bridge_api) {         // Forward to XN server\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        };\n        const xanoResponse = await xano.post_submit_test_result(headers, msg.req.body);\n        test_return = xanoResponse.data;\n    }\n    else {                          // Use Node-RED engine\n        // TODO: RED submit test result\n    }\n\n    node.warn(test_return);\n    /** 3. IF submission success, update cache for all userToken  */\n    if (test_return && cache.processingSamples) {\n        for (let signature of Object.values(cache.processingSamples)) {\n            if(signature?.value?.samples){\n                for (let sample of signature.value.samples) {   // always try to update even to expired cache\n                    for (let test of sample.test_orders) {\n                        if (test.id === test_return.test_order.id) {\n                            test = test_return;     // update test result\n                        }\n                    }\n                }\n            }else{\n                node.warn(\"Test isn't cached on processing Samples\");\n            }\n\n\n        }\n    }\n\n    /** 4. RETURN TO CLIENT */\n    msg.payload = test_return;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Create receipt error: \" + error);\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 520,
        "wires": [
            [
                "8d198522e922ef0d"
            ]
        ]
    },
    {
        "id": "8d198522e922ef0d",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "3b5fddf13427ab4a",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 690,
        "y": 520,
        "wires": []
    },
    {
        "id": "c9dd0bee078610dd",
        "type": "http in",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "GET: recent_receipts",
        "url": "/api:hrFfPpfK/receipt_list/_get/recent_receipts",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 140,
        "wires": [
            [
                "11bbf920bc70be60"
            ]
        ]
    },
    {
        "id": "11bbf920bc70be60",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "getRecentReceipt",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\n// Recent Receipt Cache is updating, wait till it done\nwhile(xano.flag === true){\n    await new Promise( wait => setTimeout(wait, 1000)) // 1s\n}\n\ntry {\n    let recentReceipts;                 // Return value for msg.payload\n    const expireTime = 4 * 60 * 1000;   // 4 minutes cache expiration time\n\n    /** 1. AUTH */\n    if (xano.bridge_auth) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        };\n        const authResponse = await xano.auth_me_employee(headers);\n    }\n    else {\n        // TODO: RED auth\n    }\n\n\n    /** 2. TRY CACHE */\n    if ( cache.recentReceipts &&\n        cache.recentReceipts.value &&\n        Date.now() - cache.recentReceipts.cached_at < expireTime ) {\n            node.warn('getRecentReceipts: Cache hit');\n            recentReceipts = cache.recentReceipts.value;\n    }\n\n    /** 3. CACHE MISS, get latest data */\n    else {\n        // setflag true\n        xano.flag = true;\n        node.warn('getRecentReceipts: Cache miss');\n        if (xano.bridge_api) {      // GET from xano\n            const headers = {\n                \"Content-Type\": \"application/json\",\n                \"authorization\": msg.req.headers.authorization\n            }\n            const xanoResponse = await xano.get_recent_receipts(headers);\n            if (xanoResponse.status === 200) {\n                recentReceipts = xanoResponse.data;\n            }\n        }\n        else {                      // RED DB access\n            recentReceipts = await Receipt.recentReceipts();\n        }\n\n        if (recentReceipts) {       // Cache the result\n            cache.recentReceipts = {\n                value: recentReceipts,\n                cached_at: Date.now()\n            };\n        }\n        node.warn('getRecentReceipts: Cache Filled');\n        xano.flag = false;\n    }\n\n    /** 4. RETURN */\n    msg.payload = recentReceipts;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn('Recent receipt error: ' + error);\n    const errStack = error.stack;\n    node.warn(errStack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 140,
        "wires": [
            [
                "5ee6e7e6112b7d57"
            ]
        ]
    },
    {
        "id": "5ee6e7e6112b7d57",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 690,
        "y": 140,
        "wires": []
    },
    {
        "id": "07a1f2e0af111f21",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "g": "a428cef3584244ff",
        "name": "GET: sample_detail",
        "url": "/api:hrFfPpfK/sample_detail/_get/sample/:sample_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 360,
        "wires": [
            [
                "090ebfb08a8ab273"
            ]
        ]
    },
    {
        "id": "090ebfb08a8ab273",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "getDetailSample",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\ntry {\n    /** 1. Try cache */\n    const detailSample_cache = cache.detailSample;\n    const expireTime = 4 * 60 * 1000; // 4 minutes\n    if (detailSample_cache && Date.now() - detailSample_cache.cached_at < expireTime) {\n        /** 1.1 Check auth */\n        if (xano.bridge_auth) {\n            const authResponse = await xano.auth_me_employee(msg.req.headers);\n            if (authResponse.status === 200) {\n                msg.payload = detailSample_cache.value;\n                node.warn(\"Detail Sample: get cache\");\n                return msg;\n            }\n        }\n        else {\n            // TODO: RED auth\n        }\n    }\n\n    // clear cache\n    cache.detailSample = undefined;\n\n    /** 2. Get latest data */\n    let sample;\n\n    if (xano.bridge_api) {      // Bridge Xano\n        node.warn(msg.req.headers);\n        const xanoResponse = await xano.get_detail_sample(msg.req.params,msg.req.headers);\n        if (xanoResponse.status === 200) {\n            sample = xanoResponse.data;\n            cache.detailSample = {\n                value: sample,\n                cached_at: Date.now()\n            };\n            node.warn(\"Detail sample: set cache\");\n        }\n        else {\n            throw new Error('Xano Auth API returned non-200 status');\n        }\n        \n    } else {\n        // Direct RED database access\n        // receipts = await Receipt.detailSample();\n    }\n\n    cache.detailSample = {\n        value: sample,\n        cached_at: Date.now()\n    };\n    msg.payload = sample;\n    return msg;\n\n} catch (error) {\n    node.warn('Recent receipt error: ' + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 360,
        "wires": [
            [
                "060cdca3bfae5f5b"
            ]
        ]
    },
    {
        "id": "060cdca3bfae5f5b",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 690,
        "y": 360,
        "wires": []
    },
    {
        "id": "99cd3462bc22c5a8",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "g": "a428cef3584244ff",
        "name": "GET: receipt_detail",
        "url": "/api:hrFfPpfK/receipt_detail/_get/receipt/:receipt_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 220,
        "wires": [
            [
                "2cb72e179fa185f8"
            ]
        ]
    },
    {
        "id": "2cb72e179fa185f8",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "getReceiptDetail",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\ntry {\n    /** 1. Try cache */\n    const detailReceipt_cache = cache.detailReceipt;\n    const expireTime = 4 * 60 * 1000; // 4 minutes\n    if (detailReceipt_cache && Date.now() - detailReceipt_cache.cached_at < expireTime) {\n        /** 1.1 Check auth */\n        if (xano.bridge_auth) {\n            const authResponse = await xano.auth_me_employee(msg.req.headers);\n            if (authResponse.status === 200) {\n                msg.payload = detailReceipt_cache.value;\n                node.warn(\"Detail Receipt: get cache\");\n                return msg;\n            }\n        }\n        else {\n            // TODO: RED auth\n        }\n    }\n\n    // clear cache\n    cache.detailReceipt = undefined;\n\n    /** 2. Get latest data */\n    let receipt;\n\n    if (xano.bridge_api) {      // Bridge Xano\n        node.warn(msg.req.headers);\n        const xanoResponse = await xano.get_detail_receipt(msg.req.params,msg.req.headers);\n        if (xanoResponse.status === 200) {\n            receipt = xanoResponse.data;\n            cache.detailReceipt = {\n                value: receipt,\n                cached_at: Date.now()\n            };\n            node.warn(\"Detail Receipt: set cache\");\n        }\n        else {\n            throw new Error('Xano Auth API returned non-200 status');\n        }\n        \n    } else {\n        // Direct RED database access\n        // receipts = await Receipt.detailReceipt();\n    }\n\n    cache.detailReceipt = {\n        value: receipt,\n        cached_at: Date.now()\n    };\n    msg.payload = receipt;\n    return msg;\n\n} catch (error) {\n    node.warn('Recent receipt error: ' + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 220,
        "wires": [
            [
                "bbe9b9eb9dd66dc6"
            ]
        ]
    },
    {
        "id": "bbe9b9eb9dd66dc6",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 690,
        "y": 220,
        "wires": []
    },
    {
        "id": "8d7268b919feebd5",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "getProcessingSample",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\n// PRECAUTION: cache mechanism is not thread-safe and may cause race condition\n// PRECAUTION: processingSamples uses authToken as signature key.\n\ntry {\n    let processingSamples;  // Return value for msg.payload\n\n    /** 1. AUTHENTICATION */\n    if (xano.bridge_auth) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        };\n        const authResponse = await xano.auth_me_employee(headers);\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. Try cache */\n    const userToken = msg.req.headers.authorization.split(' ')[1];\n    const expireTime = 4 * 60 * 1000; // 4 minutes\n\n    // FIND CACHE FOR THIS USER TOKEN\n    if (cache.processingSamples &&\n        userToken &&\n        cache.processingSamples[userToken] &&\n        cache.processingSamples[userToken].value &&\n        Date.now() - cache.processingSamples[userToken].cached_at < expireTime\n    ) {\n        node.warn('getProcessingSample: Cache Hit');\n        processingSamples = cache.processingSamples[userToken].value;\n    }\n\n    // FOUND NO CACHE FOR THIS USER TOKEN\n    else {\n        node.warn('getProcessingSample: Cache Miss');\n        // CREATE NEW CACHE\n        if (!cache.processingSamples) cache.processingSamples = {};\n        cache.processingSamples[userToken] = {};\n\n        // GET LATEST DATA FROM XANO BRIDGE API\n        if (xano.bridge_api) {\n            const headers = {\n                accept: 'application/json',\n                authorization: msg.req.headers.authorization,\n            };\n\n            // SEND XANO REQUEST\n            const xanoResponse = await xano.get_processing_samples(headers);\n            if (xanoResponse.status === 200) {\n                processingSamples = xanoResponse.data;\n            }\n        }\n\n        // GET LATEST DATA FROM RED AUTH API\n        else {\n            // TODO: RED auth\n        }\n\n        // SET CACHE\n        cache.processingSamples[userToken] = {\n            value: processingSamples,\n            cached_at: Date.now()\n        };\n        node.warn('getProcessingSample: Cache Filled')\n    }\n\n    msg.payload = processingSamples;\n    msg.statusCode = 200;\n    return msg;\n\n} catch (error) {\n    node.warn('Recent receipt error: ' + error);\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 400,
        "wires": [
            [
                "fb3a0e2a0a704a0d"
            ]
        ]
    },
    {
        "id": "ad7bd9e2daa32fef",
        "type": "http in",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "GET: processing_samples",
        "url": "/api:FzsHe1z4/sample_mgr/get_processing_samples",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 400,
        "wires": [
            [
                "8d7268b919feebd5"
            ]
        ]
    },
    {
        "id": "fb3a0e2a0a704a0d",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 690,
        "y": 400,
        "wires": []
    },
    {
        "id": "0f49becad244f26a",
        "type": "comment",
        "z": "46183d332de8b18f",
        "name": "Client Production Notes",
        "info": "Client Production note:\n\n1. Change Get Recent to Red API\n2. Change Get Processing to Red API\n3. Change Submit Result to Red API",
        "x": 360,
        "y": 60,
        "wires": []
    },
    {
        "id": "1ef57e1e3ad923f3",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "g": "a428cef3584244ff",
        "name": "post new receit",
        "url": "/new_receipt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 260,
        "wires": [
            [
                "89a8e8326f42fe01"
            ]
        ]
    },
    {
        "id": "89a8e8326f42fe01",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "updateReceipt",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { Receipt } = global.get(\"tables\");\n\ntry {\n    let receipt;            // Storing Created Receipt Object\n\n    /** 1. AUTHENTICATE */\n    if (xano.bridge_api) {\n        // This block is intentionally left blank\n        // If bridge_api is true, Authentication is alreadt done in Xano\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. CREATE RECORD */\n    if (xano.bridge_api) {  // Forward to xano\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            authorization: msg.req.headers.authorization,\n        };\n        const xanoResponse = await xano.post_create_receipt(\n            headers,\n            msg.req.body,\n        );\n        receipt = xanoResponse.data;\n    }\n    else {                  // USE Node-RED engine\n        // TODO: Auth\n        const newReceipt = msg.req.params.new_receipt;\n        // newReceipt = new Receipt.create(newReceipt)\n        // Post to Xano ... \n    }\n\n    /** 3. SET CACHE */\n    if (                    // Kiem tra neu new receipt chua them vao cache\n        receipt &&                                                          // receipt must exist to be added to cache\n        cache.recentReceipts &&                                             // cache must exist\n        cache.recentReceipts.value &&                                       // cache must have a value\n        (Date.now() - cache.recentReceipts.cached_at) < 4 * 60 * 1000 &&    // this cache must still be valid\n        cache.recentReceipts.value[0] &&                                    // there must be at least one receipt in the cache\n        cache.recentReceipts.value[0].receipt_uid !== receipt.receipt_uid   // The first receipt in cache is not the same as the new receipt\n    ) {\n        cache.recentReceipts.cached_at = Date.now();\n        cache.recentReceipts.value = [receipt, ...cache.recentReceipts.value];   // Add new receipt to the beginning of the array\n    }\n\n    /** 4. RETURN TO CLIENT */\n    msg.payload = receipt;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Create receipt error: \" + error);\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 260,
        "wires": [
            [
                "2654e3fc0cab17e1"
            ]
        ]
    },
    {
        "id": "2654e3fc0cab17e1",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "a428cef3584244ff",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 690,
        "y": 260,
        "wires": []
    }
]