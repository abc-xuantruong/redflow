[
    {
        "id": "f3deaa9ef8948c89",
        "type": "tab",
        "label": "Main",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7c3157bf68c1b848",
        "type": "tab",
        "label": "S3 Up Links",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b5db9eb4f8a97ec0",
        "type": "group",
        "z": "f3deaa9ef8948c89",
        "name": "S3 Notifications",
        "style": {
            "label": true
        },
        "nodes": [
            "0730a908731fd351",
            "936ab34d061b13bd",
            "ae2ad0ce0408670d",
            "f058ed39b81ee1c5",
            "70c321c215674dc8",
            "e90275fd1d80699e"
        ],
        "x": 774,
        "y": 639,
        "w": 562,
        "h": 122
    },
    {
        "id": "4e2aeff839f1c074",
        "type": "telegram client config",
        "botname": "IRDOP Internal Service",
        "verboselogging": false,
        "loginmode": "bot",
        "useproxy": false,
        "usewss": false,
        "devicemodel": "",
        "systemversion": "",
        "appversion": "",
        "host": "",
        "sockstype": "5",
        "port": "6667",
        "username": "anonymous",
        "password": "",
        "secret": "",
        "mtproxy": false,
        "timeout": "2"
    },
    {
        "id": "acac4ace959569ed",
        "type": "telegram client config",
        "botname": "oa_zalo_bot",
        "verboselogging": false,
        "loginmode": "bot",
        "useproxy": false,
        "usewss": false,
        "devicemodel": "",
        "systemversion": "",
        "appversion": "",
        "host": "",
        "sockstype": "5",
        "port": "6667",
        "username": "anonymous",
        "password": "",
        "secret": "",
        "mtproxy": false,
        "timeout": "2"
    },
    {
        "id": "39d97d88c2550518",
        "type": "global-config",
        "name": "global-config",
        "env": [
            {
                "name": "dbConfig",
                "value": "{\"LIMS-IRDOP-PRD\":{\"database\":\"LIMS\",\"user\":\"postgres\",\"host\":\"red.irdop.org\",\"pw\":\"sleeve-unison-rendition\",\"port\":5432},\"LIMS-IRDOP-DEV\":{\"database\":\"LIMS-DEV\",\"user\":\"postgres\",\"host\":\"red.irdop.org\",\"pw\":\"sleeve-unison-rendition\",\"port\":5432}}",
                "type": "json"
            },
            {
                "name": "s3Config",
                "value": "{\"LIMS-IRDOP-DEV\":{\"endPoint\":\"s3.irdop.org\",\"port\":443,\"useSSL\":true,\"accessKey\":\"rNItZci16fmAVcb9HA2e\",\"secretKey\":\"GD1hNEGOteycopeFIDWqPItFoULeJvGkX52LMBdt\",\"bucket\":\"irdop-dev\"},\"LIMS-IRDOP-PRD\":{\"endPoint\":\"s3.irdop.org\",\"port\":443,\"useSSL\":true,\"accessKey\":\"KH0I7XQM9XrN5bwaeX7d\",\"secretKey\":\"ZrWVaLJKCieBcj5L90BynImIKDSeNrTr4M0yOtOd\",\"bucket\":\"irdop\"}}",
                "type": "json"
            }
        ]
    },
    {
        "id": "5713a18fe4b90d79",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "START",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.001",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 60,
        "wires": [
            [
                "e529ddc66ccceda4"
            ]
        ]
    },
    {
        "id": "35818376b74b9267",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "entity.js",
        "func": "node.status({ fill: 'yellow', shape: 'dot', text: '...' });\nconst { trackPerformance, cError, handleError, permissionMap } = global.get('utilities.js');\nconst dataService = global.get('data-service.js');\nconst { createCache, CacheWorld } = global.get('cache.js');\nconst { ObjectConnection, DataConnection } = global.get('repo.js');\n\nclass Session {\n    #headers = {};\n    #info = {};\n    #discovery = {};\n    s3 = {}; // ObjectStore client\n    db = {}; // Database client\n\n    constructor(info, headers) {\n        if (!info) throw new cError(500, 'Session Info is required');\n        this.className = this.constructor.name;\n        this.#info = { ...info, className: this.className };\n        this.#headers = headers;\n\n        // Pg Client\n        const dbConfig = env.get('dbConfig')[this.appUID];\n        this.db = new DataConnection(dbConfig, this);\n\n        // S3 Client cho Session entity\n        const s3Config = env.get('s3Config')[this.appUID]; // s3 config theo appUID\n        this.s3 = new ObjectConnection(s3Config, this); // Lưu client vào session\n\n    }\n\n    // Identity\n    get info() {\n        return this.#info;\n    }\n    get identityUID() {\n        return this.#info.identityUID;\n    }\n    get user() {\n        return this.#discovery?.User;\n    }\n    get email() {\n        return this.#discovery?.User?.email;\n    }\n    get identityName() {\n        return this.#discovery?.User?.identityName;\n    }\n    get role() {\n        return this.#info.role;\n    }\n\n    // Auth & access\n    get token() {\n        return this.sessionUID;\n    }\n    get sessionUID() {\n        return this.#info.sessionUID;\n    }\n    get headers() {\n        return this.#headers;\n    }\n    get appUID() {\n        return this.#info.appUID;\n    }\n    set headers(headers) {\n        this.#headers = headers;\n    }\n\n    // Repo\n    get accessKey() {\n        return this.#info.accessKey;\n    }\n\n    async getUser() {\n        // Lấy userInfo của session này\n        try {\n            const user = await dataService.getUser(this);\n            if (user) this.#discovery['User'] = user;\n            return user;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    serialize() {\n        // toJSON\n        return {\n            ...this.info,\n            ...Object.fromEntries(\n                Object.entries(this.#discovery).map(([key, value]) => [\n                    key,\n                    value && typeof value.serialize === 'function' ? value.serialize() : value,\n                ]),\n            ),\n            className: this.className,\n        };\n    }\n}\n\nclass Entity {\n    #discovery = {};\n    #info = {};\n    #session = {};\n\n    constructor(info, session) {\n        if (!info) throw new cError(500, 'Info is required');\n        this.#info = info;\n        this.#session = session;\n        this.className = this.constructor.name;\n    }\n\n    get session() {\n        return this.#session;\n    }\n    get info() {\n        return { ...this.#info, className: this.className };\n    }\n    get discovery() {\n        return this.#discovery;\n    }\n\n    newDiscovery(discovery = {}) {\n        if (discovery) {\n            Object.entries(discovery).forEach(([key, value]) => {\n                if (value && typeof value === 'object' && !Array.isArray(value)) {\n                    this.#discovery[key] = value;\n                } else {\n                    this.#discovery[key] = value;\n                }\n            });\n        }\n    }\n\n    serialize() {\n        // convert object gồm cả info đã mở rộng từ newDiscovery\n        return {\n            ...this.info,\n            ...Object.fromEntries(\n                Object.entries(this.#discovery).map(([key, value]) => [\n                    key,\n                    value && typeof value.serialize === 'function' ? value.serialize() : value,\n                ]),\n            ),\n        };\n    }\n\n    // PERMISSION (DRAFT)\n    getPermissionFor(action) { }\n\n    addLog(logType, logTime, logForEntity, fnName, data) {\n        const options = {\n            logType: logType || '', // event/scheduled | auto/manual |\n            logObject: logForEntity || '', // Sử dụng thiết bị, theo dõi môi trường, nhật ký hệ thống, nhật ký thử nghiệm, nhật ký người dùng, nhật ký mẫu,\n            logNotion: '', // error, warning, info\n            timestamp: logTime || Date.now(),\n            systemLog: {\n                entity: this.className,\n                fnName: fnName || '',\n                timestamp: Date.now(),\n                sessionUID: this.session.sessionUID,\n                appUID: this.session.appUID,\n                accessKey: this.session.accessKey,\n                identityUID: this.session.identityUID,\n            },\n            description: data.description || '',\n        };\n\n        const doneBy = `thực hiện bởi ${this.session.identityName || this.session.identityUID}`;\n    } // TODO\n    addAudit(actionType, timestamp, fnName, description) { } // TODO\n}\n\n// IDENTITY\nclass User extends Entity {\n    constructor(info, session) {\n        super(info, session);\n\n        // Tạo getter từ info object\n        Object.keys(info).forEach((key) => {\n            if (key !== 'className') {\n                Object.defineProperty(this, key, {\n                    get: () => this.info[key],\n                    enumerable: true,\n                    configurable: true,\n                });\n            }\n        });\n        this.className = 'User';\n    }\n\n    get relation() {\n        return this.discovery?.relations;\n    }\n\n    async editInfo(newInfo) {\n        if (newInfo) {\n            // query/ post / access\n        }\n        return new User(this.info, this.session);\n    }\n\n    async newRelation(relation) {\n        if (relation?.appUID) {\n            // query/ post / access return {}\n            this.newDiscovery({ relations: await this.getRelation() });\n        }\n        // relations = [\n        //     {\n        //         appUID: 'LIMS-IRDOP-DEV',\n        //         disabled: false,\n        //         staff: true,\n        //         staff_technician: true,\n        //     }, {\n        //         appUID: 'LIMS-IRDOP-DEV',\n        //         disabled: false,\n        //         staff: true,\n        //         staff_technician: true,\n        //     },\n        // ]\n    }\n\n    async getRelationList() { }\n\n    async getRelation(appUID) { }\n\n    // CHECK Permission\n    canEdit() { }\n}\n\nclass Equipment extends Entity {\n    //... Equipment compliance with ISO 17025\n}\n\nclass Bot extends Entity {\n    //... for trained AI agent identity\n}\n\n\n// LAB WORKLOAD\nclass Analysis extends Entity {\n    sampleUID = '';\n    receiptUID = '';\n    constructor(info, session) {\n        super(info, session);\n    }\n\n    async uploadFile({ fileType, sourceType, reviewedByUID, signedByUID, uploadedByUID, createdByUID }) {\n        // Accept file to this analysis\n    }\n}\n\n\n// FILES & STORAGE\nclass File extends Entity {\n    #info = {};\n    uploadedByUID = '';           // identityUID\n\n    constructor(info, session) {\n        super(info, session);\n    }\n\n}\n\nclass AnalysisFile extends File {\n    fileType = ''; // RawData, PreparedReport, Calculation, ...\n    sourceType = ''; // MachineGenerated, HumanPrepared\n    TestSignedAt = ''; // timestamp\n    TestSignedNote = ''; // string\n    TestSignedResult = ''; // string\n\n\n\n    constructor(info, session) {\n        super(info, session);\n    }\n\n    async newTestFile(options = {}) {\n\n    }\n}\n\nclass PreparedReport extends File {\n\n}\n\nclass Calculation extends File {\n\n}\n\nclass Permission {\n    #session = {};\n    receipt = [];\n    sample = [];\n    analysis = [];\n    parameter = [];\n    client = [];\n    protocol = [];\n    document = [];\n    material = [];\n    inventory = [];\n\n    constructor(session) {\n        this.#session = session;\n        node.warn(session);\n        this.#initializePermissions();\n        this.className = 'Permission';\n    }\n    #initializePermissions() {\n        const { role } = this.#session;\n        const roles = Object.keys(role).filter((key) => role[key] === true);\n        const isSuperAdmin = roles.includes('staffSuperAdmin');\n\n        // Kiểm tra session có hợp lệ không (dựa trên sessionExpiry và sessionStatus)\n        const now = new Date();\n        const expiry = new Date(this.#session.sessionExpiry);\n        if (this.#session.sessionStatus !== 'active' || now > expiry) {\n            return; // Session không hợp lệ, giữ tất cả quyền là mảng rỗng\n        }\n\n        // Nếu là staffSuperAdmin, tất cả quyền là true\n        if (isSuperAdmin) {\n            this.receipt = ['create', 'read', 'update', 'delete'];\n            this.sample = ['create', 'read', 'update', 'delete'];\n            this.analysis = ['create', 'read', 'update', 'delete'];\n            this.parameter = ['create', 'read', 'update', 'delete'];\n            this.client = ['create', 'read', 'update', 'delete'];\n            this.protocol = ['create', 'read', 'update', 'delete'];\n            this.document = ['create', 'read', 'update', 'delete'];\n            this.material = ['create', 'read', 'update', 'delete'];\n            this.inventory = ['create', 'read', 'update', 'delete'];\n            return;\n        }\n\n        const isAdmin = roles.includes('staffAdmin');\n        const applicableRoles = roles.filter((r) => r !== 'staffAdmin' && r !== 'staffSuperAdmin');\n\n        // Gán quyền từ permissionMap\n        for (const targetType of Object.keys(this)) {\n            if (Array.isArray(this[targetType])) {\n                let basePermissions = [];\n                for (const role of applicableRoles) {\n                    if (permissionMap[targetType] && permissionMap[targetType][role]) {\n                        basePermissions = [...new Set([...basePermissions, ...permissionMap[targetType][role]])];\n                    }\n                }\n                this[targetType] = basePermissions;\n                if (isAdmin && basePermissions.length > 0) {\n                    this[targetType] = ['create', 'read', 'update', 'delete'];\n                }\n            }\n        }\n    }\n    get permission() {\n        return this.discovery?.Permission;\n    }\n\n    hasPermission(targetType, targetEvent) {\n        const permissions = this[targetType.toLowerCase()];\n        if (!permissions || permissions.length === 0) throw new cError(403, 'Permission denied');\n        if (permissions.includes(targetEvent.toLowerCase())) {\n            return true;\n        } else {\n            throw new cError(403, `Permission denied for ${targetEvent} on ${targetType}`);\n        }\n    }\n}\n\n// TODO CLASS: Analysis, Sample, Receipt\n// TODO CLASS: File (with fileInfo {...})6\n// TODO CLASS: Log      (actionType on any entity)\n// TODO CLASS: Audit    (actionType on any entity)\n\nglobal.set('entity.js', { Session, User, Permission });\nnode.status({ fill: 'green', shape: 'dot', text: 'OK' });\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 180,
        "wires": [
            [
                "1921ea2569c8fb02",
                "c3a6768321b9b8ce"
            ]
        ]
    },
    {
        "id": "1921ea2569c8fb02",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "data-service",
        "func": "node.status({ fill: 'yellow', shape: 'dot', text: '...' });\nconst { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst { convertCamelCase, convertSnakeCase } = global.get('utilities.js');\nconst { Session, User, Permission } = global.get('entity.js');\nconst { createCache } = global.get('cache.js');\nconst axios = global.get('axios');\nconst { Pool } = pg;\n\n// DECLARE CACHES\nconst sessionCache = createCache('Session', 120 * 60 * 1000);        // 2 hour\nconst userCache = createCache('User', 60 * 60 * 1000);        // 1 hour\nconst analysisCache = createCache('Analysis', 60 * 60 * 1000);        // 1 hour\nconst sampleCache = createCache('Sample', 60 * 60 * 1000);        // 1 hour\nconst receiptCache = createCache('Receipt', 60 * 60 * 1000);        // 1 hour\nconst permissionCache = createCache('Permission', 60 * 60 * 1000);        // 1 hour\n\n// SESSION & USER main functions\nasync function getSession(req) {\n    // Validate và lấy ra appUID + sessionUID + accessKey(nếu có)\n    const { headers } = req;\n    node.warn(headers);\n    let appUID = headers?.['x-fh-app-uid'];\n    if (!appUID) throw new cError(400, \"Please provide appUID\")\n    if (!headers?.['authorization']) throw new cError(401, \"Please login to continue\")\n    const sessionUID = headers?.['authorization'].split(' ')[1] || headers?.['Authorization'].split(' ')[1];\n    const accessKey = headers?.['x-fh-access-key'] || env.get('s3Config')[appUID];    // USER or SERVER KEY\n\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `Session:${sessionUID}`;      // Định danh cache\n        let cachedSession = sessionCache.get(cacheKey);   // Tìm cache\n        if (cachedSession) {\n            node.warn(`Cached session found`);\n            if (cachedSession.appUID === appUID) return cachedSession;           // Trả về cache (nếu có)\n            else throw new cError(403, \"Wrong application request header\")\n        }\n\n        // CONSTRUCT SESSION CLASS\n        const endpoint = \"https://pink.irdop.org/ab4dg2/auth/me\";\n        const headers = {\n            \"Content-Type\": `application/json`,\n            \"Authorization\": `Bearer ${sessionUID}`,    // từ user request\n            \"x-fh-app-uid\": appUID,                     // từ user request\n            \"x-fh-access-key\": accessKey,               // từ user request hoặc server setting\n        };\n\n        // GET SESSION INFO\n        const response = await axios.post(endpoint, {}, { headers });\n        const sessionInfo = convertCamelCase(response?.data);\n\n        if (!sessionInfo) throw new cError(401, 'Please login to continue');\n\n        // CONSTRUCT SESSION\n        const session = new Session(sessionInfo, headers);\n        await session.getUser();    // Preload user info\n        // await session.getDb()       // Không cần connect() cho client mà pool tự sắp xếp client\n\n        // SET CACHE & RETURN\n        return sessionCache.set(cacheKey, session);\n    } catch (error) {\n        handleError(error, 'data-service.js.getSession');\n        throw error;\n    } finally {\n        trackPerformance('data-service.js.getSession', startTime);\n    }\n}\nasync function loginUser(req) {\n    const { body, headers } = req;\n    const { email, password } = body;\n    const startTime = Date.now();\n    try {\n        const appUID = headers?.['x-fh-app-uid'];\n        if (!email) throw new cError(400, \"Please provide email\");\n        if (!password) throw new cError(400, \"Please provide password\");\n        if (!appUID) throw new cError(400, \"No application is provided for your login session\");\n\n        node.warn(123123);\n        // GET SESSION\n        const response = await axios.post('https://pink.irdop.org/gre134e/auth/login', { email, password }, {\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'x-fh-app-uid': appUID\n            }\n        });\n\n        // RESPONSE\n        const sessionInfo = convertCamelCase(response?.data);\n        if (!sessionInfo) throw new cError(401, 'Failed to validate your credentials');\n\n        // CREATE SESSION ENTITY\n        const session = new Session(sessionInfo, headers);\n        await session.getUser();    // Preload user info\n        // await session.getDb();      // Preload Database Pool\n        const cacheKey = `Session:${session.token}`;\n        sessionCache.set(cacheKey, session);\n        return session;\n    } catch (error) {\n        handleError(error, `data-service.js.loginUser [${email}]`);\n        throw error;\n    } finally {\n        trackPerformance(`data-service.js.loginUser [${email}]`, startTime, true);\n    }\n}\nasync function getUser(session) {\n    // Validate và lấy ra identityUID + email\n    if (typeof session !== 'object') throw new cError(400, 'session input must be an object');\n    const { identityUID, email } = session;\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `User:${identityUID}`;    // Định danh cache\n        const userInfo = userCache.get(cacheKey) ? userCache.get(cacheKey) : async () => {\n            // GET USER INFO\n            const endpoint = \"https://pink.irdop.org/ab4dg2/get/iden\";\n            const body = { identity_uid: identityUID, email: email };\n            const headers = session.headers;\n            const response = await axios.post(endpoint, body, { headers });\n            const userInfo = convertCamelCase(response?.data);         // convert to camelCase format\n            if (!userInfo) throw new cError(404, 'User not found');\n\n            // Set cache & return\n            return userCache.set(cacheKey, userInfo);\n        }\n\n        // CREATE USER ENTITY\n        const user = new User(userInfo, session);\n        return user;\n    } catch (error) {\n        node.warn({ error });\n        handleError(error, 'data-service.js.getUser');\n        throw error;\n    } finally {\n        trackPerformance('data-service.js.getUser', startTime, true);\n    }\n}\nasync function getUserByInfo(identity, session) {\n    const startTime = Date.now();\n    try {\n        const { identityUID, email } = identity;\n        if (!identityUID && !email) throw new cError(400, \"Please provide identityUID or email\");\n\n        // TRY CACHE\n        const cacheKey = `User:${identityUID || email}`;   // Định danh cache\n        const cachedUser = userCache.get(cacheKey);          // Tìm cache\n        if (cachedUser) return cachedUser;                  // Trả về cache nếu có\n\n        // SEND REQUEST\n        const endpoint = \"https://pink.irdop.org/ab4dg2/get/iden\";\n        const body = { identity_uid: identityUID, email };\n        const headers = { ...session.headers };\n        const response = await axios.post(endpoint, body, { headers });\n\n        // CONVERT TO CAMEL CASE\n        const userInfo = convertCamelCase(response?.data);\n        if (!userInfo) throw new cError(404, 'User not found');\n\n        // RETURN USER ENTITY & CACHE\n        const user = new User(userInfo, session);\n        userCache.set(cacheKey, user);\n        return user;\n    } catch (error) {\n        handleError(error, 'data-service.js.getUser');\n        throw error;\n    } finally {\n        trackPerformance('getUser', startTime, true);\n    }\n\n}\nasync function newUser(req, session) {\n    const { identityName, email } = req?.body;\n    // Với user phải có identityName và email (Bot/Server thì không cần)\n    if (!identityName) throw new cError(400, \"Please provide identity name\");\n    if (!email) throw new cError(400, \"Please provide email\");\n\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `User:${identityName}:${email}`;    // Định danh cache\n        const cachedUser = userCache.get(cacheKey);   // Tìm cache\n        if (cachedUser) throw new cError(400, 'User already exists'); // User đã tồn tại\n\n        // PREPARE RELATIONS\n        const { relations } = req.body;     // Lấy relations từ POST request\n        if (Array.isArray(relations) && relations.length > 0) {\n            // Format relations to match the API\n            relations.forEach(relation => {\n                return {\n                    relation_name: session.appUID, // gán appUID cho relation_name\n                    ...relation\n                };\n            });\n        }\n\n        // POST NEW USER\n        const newUser = await axios.post('https://pink.irdop.org/ab4dg2/insert/iden', {\n            identity_name: identityName,                // Bắt buộc\n            email: email,                               // Bắt buộc\n            password: req.body.password,\n            identity_contact: req.body.identityContact || {},\n            telegram_peer: req.body.telegramPeer || {},\n            zalo_user_id: req.body.zaloUserId || \"\",\n            relations: relations || [],\n        }, {\n            headers: {\n                ...session.headers,            // session built-in headers\n            }\n        });\n\n        const userInfo = convertCamelCase(newUser?.data);\n        // Failed to create user\n        if (!userInfo) throw new cError(400, 'Failed to create a new user');\n\n        // CREATE USER ENTITY\n        const user = new User(userInfo, session);\n        userCache.set(cacheKey, user);   // Cache user\n        return user;\n    } catch (error) {\n        handleError(error, 'newUser');\n        throw error;\n    } finally {\n        trackPerformance(`newUser [${identityName} - ${email}]`, startTime, true);\n    }\n}\n\n// S3\n\nasync function checkPermission(session, targetType, targetEvent) {\n    const startTime = Date.now();\n    try {\n        //TRY CACHE\n        const cacheKey = `Permission:${session.sessionUID}`;    // Định danh cache\n        const cachedPermission = permissionCache.get(cacheKey);   // Tìm cache\n        if (cachedPermission) return cachedPermission.hasPermission(targetType, targetEvent);          // Trả về cache nếu có\n\n        //CONSTRUCT PERMISSION CLASS\n        const permission = new Permission(session);\n        const hasPermission = permission.hasPermission(targetType, targetEvent);\n\n        //SET CACHE & RETURN\n        permissionCache.set(cacheKey, permission);\n        return hasPermission;\n    } catch (error) {\n        node.warn({ error });\n        handleError(error, 'data-service.js.getUser');\n        throw error;\n    } finally {\n        trackPerformance('data-service.js.getUser', startTime, true);\n    }\n}\n\n// SAMPLE & ANALYSIS\n\n// TODO: GET analysis, sample, receipt\n// TODO: GET fileUpLink, fileInfo, fileDownLink\n\nglobal.set('data-service.js', {\n    getSession,\n    getUser,\n    getUserByInfo,\n    loginUser,\n    newUser,\n    checkPermission\n})\nnode.status({ fill: 'green', shape: 'dot', text: 'OK' });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "pg",
                "module": "pg"
            }
        ],
        "x": 730,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "26e4fd86f86ad619",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "auth session",
        "func": "const { getSession } = global.get(\"data-service.js\");\n// GET: https://red.irdop.org/v1/auth/session\nnode.warn({msg})\ntry {\n    // GET SESSION & USER\n    const { req } = msg;\n    const session = await getSession(req);\n    const user = session.user ? await session.getUser() : null;\n\n    // PREPARE RESPONSE\n    if (user) {\n        msg.statusCode = 200;\n        msg.payload = {\n            session: session.serialize(),\n            type: \"AuthSuccess\",\n        };\n    } else {\n        msg.statusCode = 401;\n        msg.payload = { message: 'Session is expired. Please login to continue' };\n    }\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred' };\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\nreturn msg;\n\n/** RESPONSE BODY:\n * {\n *   session: {\n *      ...sessionInfo,\n *      user: {\n *          ...userInfo,\n *          className: \"User\"\n *      }\n *      className: \"Session\"\n *   }\n *   type: \"Auth\"\n * }\n */\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 340,
        "wires": [
            [
                "14cfa6918c935777"
            ]
        ]
    },
    {
        "id": "e529ddc66ccceda4",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "cache",
        "func": "node.status({fill: 'yellow', shape: 'dot', text: '...'});\n\nconst CacheWorld = {}; // global.get('CacheWorld') || {}; <--- dòng code comment này làm leak context giữa các deploy (??)\nglobal.set('CacheWorld', CacheWorld);\n\n\nfunction createCache(cacheName, ttl = 6 * 60 * 1000) {\n    // Validate inputs\n    if (CacheWorld[cacheName]) {\n        node.warn(`[ CAUTION ] Cache name \"${cacheName}\" already exists. Use a different name if intended.`);\n        return CacheWorld[cacheName];\n    }\n    if (typeof ttl !== 'number' || ttl < 0) {\n        throw new Error('Invalid TTL value. It must be a positive number.');\n    }\n    if (!cacheName || typeof cacheName !== 'string') {\n        throw new Error('Cache name is required and must be a string.');\n    }\n\n    const store = new Map();\n    const cache = {\n        ttl,\n        get(key) {\n            const entry = store.get(key);\n            if (!entry) return null;\n            if (this.ttl > 0 && Date.now() - entry.timestamp > this.ttl) {\n                node.warn(`Cache entry \"${key}\" has expired. Cleaning up...`);\n                store.delete(key);\n                return null;\n            }\n            return entry.value;\n        },\n        set(key, value) {\n            store.set(key, { value, timestamp: Date.now() });\n            return value;\n        },\n        has(key) {\n            return store.has(key);\n        },\n        size() {\n            return store.size;\n        },\n        keys() {\n            return Array.from(store.keys());\n        },\n        delete(key) {\n            const entry = store.get(key);\n            if (!entry) return false;\n            if (entry.value && typeof entry.value.clear === 'function') {\n                entry.value.clear();\n            }\n            store.delete(key);\n            return true;\n        },\n        clear() {\n            for (const [, entry] of store) {\n                if (entry.value && typeof entry.value.clear === 'function') {\n                    entry.value.clear();\n                }\n            }\n            store.clear();\n            return true;\n        },\n        getAll() {\n            return Object.fromEntries(Array.from(store, ([key, entry]) => [key, entry.value]));\n        },\n        entries() {\n            return Array.from(store.entries());\n        },\n    };\n\n    CacheWorld[cacheName] = cache;\n    return cache;\n}\n\nfunction getCache(cacheName) {\n    return CacheWorld?.[cacheName];\n}\n\n// CACHE CLEANER\nconst cleaner = setInterval(() => {\n    let totalCleaned = 0;\n    let memoryCleaned = 0;\n    let nameCleaned = [];\n\n    for (const cacheName in CacheWorld) {\n        const cache = CacheWorld[cacheName];\n        if (!cache || cache.size() === 0) continue;\n\n        for (const [key, entry] of cache.entries()) {\n            try {\n                const cacheTTL = cache.ttl || 0;\n                if (cacheTTL > 0 && entry.timestamp + cacheTTL < Date.now()) {\n                    // Clean nested caches if they exist\n                    if (entry.value && typeof entry.value.clear === 'function') {\n                        entry.value.clear();\n                    }\n\n                    // Estimate memory cleaned (rough approximation)\n                    memoryCleaned += JSON.stringify(entry.value).length || 0;\n\n                    // Delete expired entry\n                    cache.delete(key);\n                    totalCleaned++;\n                    nameCleaned.push(key);\n                }\n            } catch (error) {\n                node.error(`Error cleaning cache entry: ${key} in ${cacheName}`, error);\n            }\n        }\n\n        // Remove empty caches from CacheWorld\n        if (cache.size() === 0) {\n            delete CacheWorld[cacheName];\n        }\n    }\n\n    if (totalCleaned > 0) {\n        node.warn(`Cache cleaner removed ${totalCleaned} entries from ${Object.keys(CacheWorld).length} caches. Memory cleaned: ${memoryCleaned} bytes. Cache names: ${nameCleaned.join(', ')}`);\n    }\n}, 5 * 60 * 1000); // every 5 minutes\n\n\nglobal.set('cache.js', {\n    createCache,\n    getCache,\n    CacheWorld,\n});\n\nnode.warn('Cache cleaner is scheduled');\nnode.status({fill: 'green', shape: 'dot', text: 'OK'});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 170,
        "y": 100,
        "wires": [
            [
                "6cace463e1b92b68"
            ]
        ]
    },
    {
        "id": "6cace463e1b92b68",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "utilities",
        "func": "node.status({fill: 'yellow', shape: 'dot', text: '...'});\nconst { createCache } = global.get('cache.js');\nconst performanceData = createCache('performanceData', 0); // No expiration\nconst axios = global.get('axios');\n\nclass cError extends Error {\n    constructor(statusCode, properties, rethrow = true) {\n        if (typeof properties === 'string') {\n            properties = { message: properties, statusCode, rethrow };\n        }\n        else if (typeof properties === 'object') {\n            properties = {\n                message: properties.message || 'An error occurred',\n                statusCode: properties.statusCode || properties.code || 500,\n                rethrow: rethrow || properties.rethrow || false,\n            };\n        }\n        else {\n            properties = { message: 'An error occurred', statusCode, rethrow };\n        }\n        super(properties.message);\n\n        // Capture the stack trace\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, cError);\n        }\n        this.statusCode = statusCode || 500;\n        this.catchCount = 0;\n    }\n}\n\nfunction handleError(error, functionName, rethrow = false) {\n    if (error.catchCount++ === 0) {\n        node.warn(`${error.message} (caused at ${functionName})\\n${error.stack}`);\n    }\n    return error;\n}\n\nfunction trackPerformance(functionName, startTime, isSuccess = true) {\n    const elapsedTime = Date.now() - startTime;\n    const currentData = performanceData.get(functionName) || { count: 0, totalTime: 0, successCount: 0, errorCount: 0 };\n    currentData.count += 1;\n    currentData.totalTime += elapsedTime;\n    if (isSuccess) {\n        currentData.successCount += 1;\n    } else {\n        currentData.errorCount += 1;\n    }\n    performanceData.set(functionName, currentData);\n    return currentData;\n}\n\nfunction printPerformanceData() {\n    const data = performanceData.getAll();\n    let message = 'Performance Data:\\n';\n    let messageList = [];\n    for (const [functionName, { count, totalTime, successCount, errorCount }] of Object.entries(data)) {\n        const averageTime = totalTime / count;\n        messageList.push(`Function: ${functionName}, Calls: ${count}, Total Time: ${totalTime}ms, Average Time: ${averageTime.toFixed(2)}ms, Success: ${successCount}, Errors: ${errorCount}\\n`);\n    }\n    if (messageList.length > 0)\n        message += messageList.join('');\n    else\n        message += 'No data.';\n    node.warn(message);\n}\n\nasync function testPoolConnection(pool) {\n    try {\n        await pool.query('SELECT 1');\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function getColumnValues(tableName, pool, data) {\n    try {\n        const result = await pool.query(\n            `SELECT column_name FROM information_schema.columns WHERE table_name = $1`,\n            [tableName]\n        );\n        const allColumns = result.rows.map(row => row.column_name);\n\n        const columns = [];\n        const values = [];\n        for (const column of allColumns) {\n            if (data.hasOwnProperty(column)) {\n                columns.push(column);\n                values.push(data[column]);\n            }\n        }\n\n        return { columns, values };\n    } catch (error) {\n        handleError('file-access.getColumnValues', error, true);\n    }\n}\n\nfunction convertSnakeCase(input) {\n    // if (typeof input === 'string') {\n    //     // Check if the string is already in snake_case\n    //     if (!/[A-Z]/.test(input)) {\n    //         return input; // Return as-is if no uppercase letters are found\n    //     }\n    //     // Convert camelCase string to snake_case\n    //     return input.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()\n    //         .replace(/(?<![a-z])UID(?![a-z])/g, '_uid'); // Special case for UID, ensuring it's not part of a larger word\n    // } else \n    if (typeof input === 'object' && input !== null) {\n        if (Array.isArray(input)) {\n            // If it's an array, recursively process each element\n            return input.map(item => convertSnakeCase(item));\n        } else {\n            // If it's an object, process each key and value\n            return Object.keys(input).reduce((acc, key) => {\n                const snakeKey = key.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()\n                    .replace(/(?<![a-z])UID(?![a-z])/g, '_uid'); // Special case for UID, ensuring it's not part of a larger word\n                acc[snakeKey] = convertSnakeCase(input[key]);\n                return acc;\n            }, {});\n        }\n    }\n    // Return other data types as-is\n    return input;\n}\n\nfunction convertCamelCase(input) {\n    // if (typeof input === 'string') {\n    //     // Handle special case for _uid first\n    //     input = input.replace(/_uid/g, 'UID');\n\n    //     // Check if the string is already in camelCase\n    //     if (!/_/.test(input) || input.length > 3 && input?.slice(0,3) === 'sx_') {\n    //         return input; // Return as-is if no underscores are found\n    //     }\n\n    //     // Convert snake_case string to camelCase\n    //     return input.replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n    // } else \n    if (typeof input === 'object' && input !== null) {\n        if (Array.isArray(input)) {\n            // If it's an array, recursively process each element\n            return input.map(item => convertCamelCase(item));\n        } else {\n            // If it's an object, process each key and value\n            return Object.keys(input).reduce((acc, key) => {\n                const camelKey = key.replace(/_uid/g, 'UID')\n                    .replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n                acc[camelKey] = convertCamelCase(input[key]);\n                return acc;\n            }, {});\n        }\n    }\n    // Return other data types as-is\n    return input;\n}\nconst permissionMap = {\n    receipt: {\n        collaborator: ['read'],\n        staffCustomerService: ['read', 'create', 'update'],\n        staffSampleManager: ['read', 'create', 'update'],\n        staffTechnical: [],\n        staffAccountant: ['create', 'update'],\n        staffAdmin: ['read', 'create', 'update', 'delete'],\n        staffSuperAdmin: ['read', 'create', 'update', 'delete'],\n    },\n    sample: {\n        collaborator: ['read'],\n        staffCustomerService: ['read', 'create', 'update'],\n        staffSampleManager: ['read', 'create', 'update'],\n        staffTechnical: [],\n        staffAccountant: ['read'],\n        staffAdmin: ['read', 'create', 'update', 'delete'],\n        staffSuperAdmin: ['read', 'create', 'update', 'delete'],\n    },\n    analysis: {\n        collaborator: ['read'],\n        staffCustomerService: ['read'],\n        staffSampleManager: ['read', 'create', 'update'],\n        staffTechnical: ['read', 'create', 'update'],\n        staffAccountant: ['read'],\n        staffAdmin: ['read', 'create', 'update', 'delete'],\n        staffSuperAdmin: ['read', 'create', 'update', 'delete'],\n    },\n    parameter: {\n        collaborator: ['read'],\n        staffCustomerService: ['read', 'create', 'update'],\n        staffSampleManager: ['read', 'create', 'update'],\n        staffTechnical: ['read', 'create', 'update'],\n        staffAccountant: ['read', 'create', 'update'],\n        staffAdmin: ['read', 'create', 'update', 'delete'],\n        staffSuperAdmin: ['read', 'create', 'update', 'delete'],\n    },\n    client: {\n        collaborator: ['read'],\n        staffCustomerService: ['read', 'create', 'update'],\n        staffSampleManager: ['read', 'create', 'update'],\n        staffTechnical: ['read', 'create', 'update'],\n        staffAccountant: ['read', 'create', 'update'],\n        staffAdmin: ['read', 'create', 'update', 'delete'],\n        staffSuperAdmin: ['read', 'create', 'update', 'delete'],\n    },\n    protocol: {\n        collaborator: [],\n        staffCustomerService: ['read', 'create', 'update'],\n        staffSampleManager: ['read', 'create', 'update'],\n        staffTechnical: ['read'],\n        staffAccountant: ['read', 'create', 'update'],\n        staffAdmin: ['read', 'create', 'update', 'delete'],\n        staffSuperAdmin: ['read', 'create', 'update', 'delete'],\n    },\n    document: {\n        collaborator: ['read'],\n        staffCustomerService: ['read', 'create', 'update'],\n        staffSampleManager: ['read', 'create', 'update', 'delete'], // Có m từ bảng\n        staffTechnical: ['read', 'create', 'update'],\n        staffAccountant: ['read', 'create', 'update'],\n        staffAdmin: ['read', 'create', 'update', 'delete'],\n        staffSuperAdmin: ['read', 'create', 'update', 'delete'],\n    },\n    material: {\n        collaborator: [],\n        staffCustomerService: [],\n        staffSampleManager: ['read'],\n        staffTechnical: ['read', 'create', 'update'],\n        staffAccountant: ['read', 'create', 'update'],\n        staffAdmin: ['read', 'create', 'update', 'delete'],\n        staffSuperAdmin: ['read', 'create', 'update', 'delete'],\n    },\n    inventory: {\n        collaborator: [],\n        staffCustomerService: [],\n        staffSampleManager: ['read'],\n        staffTechnical: ['read', 'create', 'update'],\n        staffAccountant: ['read', 'create', 'update'],\n        staffAdmin: ['read', 'create', 'update', 'delete'],\n        staffSuperAdmin: ['read', 'create', 'update', 'delete'],\n    },\n};\n\nglobal.set('utilities.js', {\n    handleError,\n    trackPerformance,\n    printPerformanceData,\n    cError,\n    testPoolConnection,\n    getColumnValues,\n    convertSnakeCase,\n    convertCamelCase,\n    permissionMap\n});\n\n\n\nnode.status({fill: 'green', shape: 'dot', text: 'OK'});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 260,
        "y": 140,
        "wires": [
            [
                "bf234ff85f0c2f41"
            ]
        ]
    },
    {
        "id": "7e61714455d1fd33",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "Login User",
        "func": "const { loginUser } = global.get('data-service.js');\n// endpoint: https://red.irdop.org/v1/auth/login\n\n// RESPONSE { session: { ... }, type: 'LoginSuccess' }\n//\n\ntry {\n    const { req } = msg;\n    const session = await loginUser(req);\n\n    if (session?.info) {\n        msg.statusCode = 200;\n        msg.payload = {\n            session: session.serialize(),\n            type: 'LoginSuccess',\n        };\n    } else {\n        msg.statusCode = 403;\n        msg.payload = { message: 'Access denied' };\n    }\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;\n    msg.payload = { message: error.message };\n    node.error(error);\n}\n\nreturn msg;\n\n\n// // Test input\n// const req = {};\n// req.headers = {\n//     'Content-Type': 'application/json',\n//     'Accept': 'application/json',\n//     'x-fh-app-uid': 'LIMS-IRDOP-PRD',\n// }\n// req.body = {\n//     email: 'abc@xuantruong.xyz',\n//     password: 'xt012j',\n// };",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 380,
        "wires": [
            [
                "5dd6f391b1630e96"
            ]
        ]
    },
    {
        "id": "01e6f89d395c8166",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/auth/login",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 380,
        "wires": [
            [
                "7e61714455d1fd33"
            ]
        ]
    },
    {
        "id": "5dd6f391b1630e96",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 380,
        "wires": []
    },
    {
        "id": "9c20c2e033e39f7e",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/auth/session",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 340,
        "wires": [
            [
                "26e4fd86f86ad619"
            ]
        ]
    },
    {
        "id": "14cfa6918c935777",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 340,
        "wires": []
    },
    {
        "id": "34a32b0c48f415b2",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "New User",
        "func": "const { loginUser } = global.get('data-service.js');\n// endpoint: https://red.irdop.org/v1/auth/login\n\n// RESPONSE { session: { ... }, type: 'LoginSuccess' }\n//\n\ntry {\n    const { req } = msg;\n    const session = await loginUser(req);\n\n    if (session?.info) {\n        msg.statusCode = 200;\n        msg.payload = {\n            session: session.serialize(),\n            type: 'LoginSuccess',\n        };\n    } else {\n        msg.statusCode = 403;\n        msg.payload = { message: 'Access denied' };\n    }\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;\n    msg.payload = { message: error.message };\n    node.error(error);\n}\n\nreturn msg;\n\n\n// // Test input\n// const req = {};\n// req.headers = {\n//     'Content-Type': 'application/json',\n//     'Accept': 'application/json',\n//     'x-fh-app-uid': 'LIMS-IRDOP-PRD',\n// }\n// req.params = {\n//     email: 'abc@xuantruong.xyz',\n//     password: 'xt012j',\n// };",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 500,
        "wires": [
            [
                "75c54f96498fed4f"
            ]
        ]
    },
    {
        "id": "624483601a2c0a6c",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/user/new",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 500,
        "wires": [
            [
                "34a32b0c48f415b2"
            ]
        ]
    },
    {
        "id": "75c54f96498fed4f",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 500,
        "wires": []
    },
    {
        "id": "36f2943ff908aed4",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 965,
        "y": 180,
        "wires": [
            [
                "a9a92aabb3b0b68a"
            ]
        ],
        "l": false
    },
    {
        "id": "a9a92aabb3b0b68a",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "Print Performance Data",
        "func": "const { printPerformanceData } = global.get('utilities.js');\nprintPerformanceData();\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "5b12f9edbda9b6bd",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "Get User Info",
        "func": "// url: https://red.irdop.org/v1/user/info\n// method: POST\nconst { cError } = global.get('utilities.js');\nconst { getSession, getUserByInfo } = global.get('data-service.js');\nnode.warn('GET USER INFO');\ntry {\n    const { req } = msg;\n    const session = await getSession(req);\n    if (!session) throw new cError(401, 'Session is expired. Please login to continue');\n\n    const { params } = req;\n    if (!params) throw new cError(400, 'Bad request. A query is required');\n    if (!params.identityUID && !params.email) throw new cError(400, 'An email or identity is required');\n\n    const user = await getUserByInfo(params, session);\n    if (user) {\n        msg.statusCode = 200;\n        msg.payload = {\n            user: user.serialize(),\n            type: \"UserInfo\",\n        };\n\n    } else {\n        msg.statusCode = 404;\n        msg.payload = { message: 'User not found' };\n    }\n\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred' };\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 420,
        "wires": [
            [
                "3734c6c883f592d4"
            ]
        ]
    },
    {
        "id": "c81954ca1fe00eb2",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/user/info/:identityUID",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 420,
        "wires": [
            [
                "5b12f9edbda9b6bd"
            ]
        ]
    },
    {
        "id": "3734c6c883f592d4",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 420,
        "wires": []
    },
    {
        "id": "403ce01496e111e6",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 3100,
        "y": 80,
        "wires": [
            [
                "da4b71158770682e"
            ]
        ]
    },
    {
        "id": "9a0e363b9d06a71d",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "function 14",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3250,
        "y": 200,
        "wires": [
            [
                "b6fb6469bec408a3"
            ]
        ]
    },
    {
        "id": "8eaadab6625cf21e",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/kkj",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 3060,
        "y": 200,
        "wires": [
            [
                "9a0e363b9d06a71d"
            ]
        ]
    },
    {
        "id": "b6fb6469bec408a3",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 3430,
        "y": 220,
        "wires": []
    },
    {
        "id": "da4b71158770682e",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "function 15",
        "func": "node.warn({msg})\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3250,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "040785e928e90fa2",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 295,
        "y": 180,
        "wires": [
            [
                "bf234ff85f0c2f41"
            ]
        ],
        "l": false
    },
    {
        "id": "c3a6768321b9b8ce",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "document.js",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "ad02195183ff5441",
        "type": "comment",
        "z": "f3deaa9ef8948c89",
        "name": "SQL SCHEMA",
        "info": "\nDROP TABLE IF EXISTS \"S3Object\";\nDROP TABLE IF EXISTS \"S3PresignedObject\";\nCREATE TABLE \"S3PresignedObject\" (\n        \"presignedObjectUID\"    TEXT PRIMARY KEY,\n        \"method\"                TEXT, -- [GET, PUT, POST, DELETE]\n        \"url\"                   TEXT NOT NULL,  -- s3.irdop.org\n        \"expiry\"                INTEGER,\n        \"appUID\"                TEXT,\n        \"identityUID\"           TEXT,\n        \"createdAt\"             TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n        -- target object info\n        \"fileUID\"               TEXT,\n        \"bucketName\"            TEXT,\n        \"objectName\"            TEXT,\n        \"reqParams\"             JSONB,\n        \"requestDate\"           TIMESTAMPTZ,\n        \n        -- file metadata\n        \"metadata\"              JSONB NOT NULL DEFAULT '{}'::jsonb\n);\n\nCREATE TABLE \"S3Object\" (\n        \"fileUID\"           TEXT PRIMARY KEY,\n        \"createdAt\"         TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        \"deletedAt\"         TIMESTAMPTZ,\n        \"identityUID\"       TEXT,\n        \"appUID\"            TEXT,\n\n        -- s3 info\n        \"bucketName\" TEXT NOT NULL,\n        \"objectName\" TEXT NOT NULL,\n        \"versionID\"  TEXT,\n        \"eTag\"       TEXT,\n\n        -- file origin info\n        \"fileInfo\"          JSONB NOT NULL DEFAULT '{}'::jsonb,     -- {fileName, fileMime, fileSize, }\n\n        -- Table foreign key [UID]\n        \"foreignKeys\"       TEXT[],\n        \"fileGroupUID\"      TEXT,\n\n        -- who did what\n        \"createdByUID\"      TEXT,   -- Who composed the file\n        \"uploadedByUID\"     TEXT,   -- Who uploaded the file\n        \"reviewedByUID\"     TEXT,   -- Who reviewed the file\n        \"signedByUID\"       TEXT,   -- Who signed the file\n        \"uploadDescription\" TEXT,   -- ghi chú lúc upload\n\n        \"fileCategory\"      TEXT[], -- [RawData, PreparedReport, Calculation, Quote, PGM, BBBG, SampleImage ...]\n        \"isAutoGen\"         BOOLEAN -- true || false\n);\n\nCREATE TABLE \"File\" (\n    \"title\" TEXT,         -- title / short description\n    \"fullText\" TEXT,      -- extracted full text or content description\n)",
        "x": 720,
        "y": 60,
        "wires": []
    },
    {
        "id": "0730a908731fd351",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "",
        "url": "/v1/s3hook/notification",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 920,
        "y": 680,
        "wires": [
            [
                "936ab34d061b13bd"
            ]
        ],
        "icon": "node-red/leveldb.svg"
    },
    {
        "id": "936ab34d061b13bd",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "s3 events",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 680,
        "wires": [
            [
                "ae2ad0ce0408670d"
            ]
        ]
    },
    {
        "id": "ae2ad0ce0408670d",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1260,
        "y": 680,
        "wires": []
    },
    {
        "id": "f058ed39b81ee1c5",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "",
        "url": "/v1/s3hook/log",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 890,
        "y": 720,
        "wires": [
            [
                "70c321c215674dc8"
            ]
        ],
        "icon": "node-red/leveldb.svg"
    },
    {
        "id": "70c321c215674dc8",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "s3 logs",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 720,
        "wires": [
            [
                "e90275fd1d80699e"
            ]
        ]
    },
    {
        "id": "e90275fd1d80699e",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1260,
        "y": 720,
        "wires": []
    },
    {
        "id": "d8be0870257285dd",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "test db connection",
        "func": "const { getSession } = global.get(\"data-service.js\");\ntry {\n        // GET SESSION & USER\n        // const { req } = msg;\n\n        const req = {};\n        req.headers = {};\n        req.headers.authorization = \"Bearer sx_e629674c31374cd5be1170d41bed6cbc2261343aa1f04a12bf5258a6bf14bbed2ab75e256a424eb88c2d3e878416\"\n        req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-PRD\";\n\n        const session = await getSession(req);\n\n        // PREPARE RESPONSE\n        if (session?.db) {\n                const result = await session.db.query(`SELECT table_name\n                        FROM information_schema.tables\n                        WHERE table_schema = 'public';`);\n                node.warn({ result });\n        } else {\n                msg.statusCode = 401;\n                msg.payload = { message: 'Session is expired. Please login to continue' };\n        }\n} catch (error) {\n        if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n                msg.statusCode = error.statusCode;\n                msg.payload = { message: error.message || 'Client error occurred' };\n        } else {\n                msg.statusCode = 500;\n                msg.payload = { message: 'Internal server error' };\n                node.error(error);\n        }\n}\nreturn msg;\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "2e4cee91be44662f",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "Test DB Connection",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 965,
        "y": 60,
        "wires": [
            [
                "d8be0870257285dd"
            ]
        ],
        "l": false
    },
    {
        "id": "9ef8f6de866a4816",
        "type": "comment",
        "z": "f3deaa9ef8948c89",
        "name": "Updates",
        "info": "Hàm getSession() sẽ trả vể Session Class và gọi sẵn:\n- getUser() // Lấy user info\n- getDb()   // lấy Database connection\n(data-service.js dòng 52-53);\n\n\nĐỔI TÊN các Class: (Cho dễ gọi)\n- s3Client -> ObjectConnection\n- dbClient -> DataConnection\n(xem repo.js)\n\nTHÊM CHỨC NĂNG: database connection cho mỗi Session \n(xem entity.js)\n\nappUID và Database name\nLIMS-IRDOP-DEV -> LIMS-DEV\nLIMS-IRDOP-PRD -> LIMS",
        "x": 700,
        "y": 100,
        "wires": []
    },
    {
        "id": "074bd4c2694edae1",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "test genFileUID",
        "func": "const { getSession } = global.get(\"data-service.js\");\ntry {\n        // GET SESSION & USER\n        // const { req } = msg;\n\n        const req = {};\n        req.headers = {};\n        req.headers.authorization = \"Bearer sx_e629674c31374cd5be1170d41bed6cbc2261343aa1f04a12bf5258a6bf14bbed2ab75e256a424eb88c2d3e878416\"\n        req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-PRD\";\n\n        const session = await getSession(req);\n\n        // PREPARE RESPONSE\n        if (session?.db) {\n                const result = await session.s3.genFileUID()\n                node.warn({ result });\n        } else {\n                msg.statusCode = 401;\n                msg.payload = { message: 'Session is expired. Please login to continue' };\n        }\n} catch (error) {\n        if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n                msg.statusCode = error.statusCode;\n                msg.payload = { message: error.message || 'Client error occurred' };\n        } else {\n                msg.statusCode = 500;\n                msg.payload = { message: 'Internal server error' };\n                node.error(error);\n        }\n}\nreturn msg;\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "4acf0f74ec0e3a50",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "genFileUID",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 965,
        "y": 100,
        "wires": [
            [
                "074bd4c2694edae1"
            ]
        ],
        "l": false
    },
    {
        "id": "2b520f5b9538e2c3",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "test bucketList",
        "func": "const { getSession } = global.get(\"data-service.js\");\ntry {\n        // GET SESSION & USER\n        // const { req } = msg;\n\n        const req = {};\n        req.headers = {};\n        req.headers.authorization = \"Bearer sx_e629674c31374cd5be1170d41bed6cbc2261343aa1f04a12bf5258a6bf14bbed2ab75e256a424eb88c2d3e878416\"\n        req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";\n\n        const session = await getSession(req);\n        node.warn({session});\n\n        // PREPARE RESPONSE\n        if (session?.s3) {\n                const result = await session.s3.listBuckets()\n                node.warn({ result });\n        } else {\n                msg.statusCode = 401;\n                msg.payload = { message: 'Session is expired. Please login to continue' };\n        }\n} catch (error) {\n        node.warn(error.stack);\n        if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n                msg.statusCode = error.statusCode;\n                msg.payload = { message: error.message || 'Client error occurred' };\n        } else {\n                msg.statusCode = 500;\n                msg.payload = { message: 'Internal server error' };\n                node.error(error);\n        }\n}\nreturn msg;\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "7755f4982ffaf2a3",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "Test DB Connection",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 965,
        "y": 140,
        "wires": [
            [
                "2b520f5b9538e2c3"
            ]
        ],
        "l": false
    },
    {
        "id": "bf234ff85f0c2f41",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "repo.js",
        "func": "const { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst { createCache, getCache } = global.get('cache.js');\nconst { Client } = minio;\nconst { Pool } = pg;\nconst { v4: uuidv4 } = uuid  // required('uuid');\n\nconst columnCache = createCache(\"ColumnCache\", 60 * 60 * 1000) || getCache(\"ColumnCache\");\n\nclass ObjectConnection extends Client {\n    #db;                // DataConnection instance ie. db.query()\n    #defaultBucket;     // Default bucket name\n    #session;           // Session instance\n    client;\n\n    constructor(options, session) {\n        super(options);\n        this.#session = session;\n        this.#db = session.db;\n        this.#defaultBucket = options.bucket;\n        if (!this.#defaultBucket) throw new cError(400, `[ Error ] invalid minio client config for ${options?.endPoint}`)\n    }\n\n    get identityUID() { return this.#session.identityUID; }\n    get identityName() { return this.#session.identityName; }\n    get defaultBucket() { return this.#defaultBucket; }\n\n\n    async newUpLink({ metadata, objectPath, expiry = 604800, reqParams, requestDate }) {\n        const startTime = Date.now()\n        if (!objectPath) throw new cError(400, `[ Error ] objectPath is required`);\n        try {\n            // TẠO URL\n            const fileUID = this.genFileUID();\n            const objectName = `${objectPath}/${fileUID}`;\n            const url = await this.presignedUrl(\"PUT\", this.defaultBucket, objectName, expiry, reqParams, requestDate);\n\n            // TẠO PRESSIGN RECORD\n            const options = {\n                presignedObjectUID: uuidv4(),\n                method: \"PUT\",\n                url,\n                expiry,\n                createdAt: new Date(),\n                appUID: this.#session.appUID,\n                identityUID: this.identityUID,\n                fileUID,\n                bucketName: this.defaultBucket,\n                objectName,\n                reqParams,\n                requestDate,\n                metadata: JSON.stringify(metadata),\n            }\n\n            // SEND QUERY\n            const { columns, values } = await this.#db.getColumnValues(\"S3PresignedObject\", options);\n            const query = {\n                text: `INSERT INTO \"S3PresignedObject\" (${this.#db.quotedColumns(columns)}) VALUES (${values.map((_, i) => `$${i + 1}`).join(',')}) RETURNING *`,\n                values: values\n            };\n            const result = await this.#db.query(query.text, query.values);\n\n            // RETURN RESULT\n            if (result) return result?.rows[0];\n            throw new cError(500, `Failed to create an uplink`);\n        } catch (error) {\n            handleError('ObjectConnection.newUpLink', error);\n            return null;\n        } finally {\n            trackPerformance(\"ObjectConnection.newUpLink\", startTime);\n        }\n    }\n\n    async getDownLink(fileInfo, objectName, expiry = 604800, reqParams, requestDate) {\n        const startTime = Date.now()\n        let isSuccess = true\n        try {\n            const url = await this.presignedUrl(\"GET\", this.defaultBucket, objectName, expiry, reqParams, requestDate);\n            // TODO: Insert to presign table\n            const result = await this.insertPresignRecord({\n                objectName,\n                url,\n                expiry,\n                reqParams,\n                requestDate\n            })\n            return { url }      // return inserted record\n        } catch (error) {\n            isSuccess = false\n            handleError();      // sử dụng handle Error\n            return null;\n        } finally {\n            trackPerformance(\"ObjectConnection.getDownLink\", startTime, isSuccess);\n        }\n    }\n\n    async onUploadComplete(options) {\n        // TODO: Chuyển record từ bảng PresignedUrl sang bảng objectStorage\n    }\n    async onUploadFailure(options) {\n        // TODO: Đánh dấu record failed\n    }\n\n    genFileUID() {\n        // generateing file_25acd0e9b90298a using uuid v4\n        return `file_${(new Date().getFullYear() + '').slice(-2)}${uuidv4().replace(/-/g, '').slice(0, 12)}`;\n    }\n}\n\n\nclass DataConnection extends Pool {\n    #config;\n    #session;\n    #Pool;\n\n    constructor(config, session) {\n        config.password = config.pw;\n        super(config);\n        this.#config = config;\n        this.#session = session;\n    }\n\n    get dbName() { return this.#config?.name }\n    get identityUID() { return this.#session?.identityUID }\n    get defaultBucket() { return this.#session?.s3Bucket }\n\n    async getColumnValues(tableName, data) {   // Khớp data elements với columns field. Trả vể { columns, values }\n        try {\n            // Retrieve columns from the database\n            const cacheKey = `${this.dbName}:${tableName}`;\n            const cachedColumns = columnCache.get(cacheKey);\n            const allColumns = cachedColumns || (await this.query(\n                `SELECT column_name FROM information_schema.columns WHERE table_name = $1`,\n                [tableName]\n            )).rows.map(row => row.column_name);\n\n            if (!cachedColumns) columnCache.set(cacheKey, allColumns);\n\n            // Filter data to match columns while maintain element's order\n            const columns = [];\n            const values = [];\n            for (const column of allColumns) {\n                if (data.hasOwnProperty(column)) {\n                    columns.push(column);\n                    values.push(data[column]);\n                }\n            }\n            node.warn({ columns, values });\n            return { columns, values };\n        } catch (error) {\n            handleError('file-access.getColumnValues', error, true);\n        }\n    }\n\n    quotedColumns(columns) {\n        return columns.map(column => `\"${column}\"`).join(',');\n    }\n\n    async testConnection() {\n        node.warn(`[ DataConnection ] Testing connection to ${this.dbName} database`);\n        try { return await this.query(`SELECT 1`) || false; }\n        catch (error) { return false; }\n    }\n}\n\n\nglobal.set('repo.js', {\n    ObjectConnection,\n    DataConnection\n});\n\nnode.status({ fill: 'green', shape: 'dot', text: 'OK' });\nreturn msg",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "minio",
                "module": "minio"
            },
            {
                "var": "pg",
                "module": "pg"
            },
            {
                "var": "uuid",
                "module": "uuid"
            }
        ],
        "x": 410,
        "y": 180,
        "wires": [
            [
                "35818376b74b9267"
            ]
        ]
    },
    {
        "id": "712ed8ca184f71cd",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/auth/permission",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 560,
        "wires": [
            [
                "c13cd0690cc33a81"
            ]
        ]
    },
    {
        "id": "c13cd0690cc33a81",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "permission",
        "func": "const { getSession,checkPermission } = global.get(\"data-service.js\");\n\ntry {\n    //Check session\n    const { req } = msg;\n    const session = await getSession(req);\n    const user = session.user ? await session.getUser() : null;\n\n    if (user) {\n        const sessionData = session.serialize();\n        const {targetType, eventType} = req.body;\n        const permission = await checkPermission(sessionData,targetType,eventType);\n        if(permission){\n            msg.statusCode = 200;\n            msg.payload = { hasPermission: true};\n        }else{\n            // msg.statusCode = 403;\n            msg.payload = {\n                statusCode:403,\n                message: 'You do not have permission to perform this action' ,\n                hasPermission:false\n                };\n        }\n    } else {\n        msg.statusCode = 401;\n        msg.payload = { message: 'Session is expired. Please login to continue' };\n    }\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred', statusCode: error.statusCode };\n        node.warn({msg});\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\n\nnode.warn(msg.payload);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 560,
        "wires": [
            [
                "5d38d9151dc78116"
            ]
        ]
    },
    {
        "id": "5d38d9151dc78116",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 560,
        "wires": []
    },
    {
        "id": "75a70de085e5c33e",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/file/uplink/lab/activities",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 910,
        "y": 340,
        "wires": [
            [
                "943431eeed7d69b9"
            ]
        ]
    },
    {
        "id": "943431eeed7d69b9",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "new analysis file",
        "func": "// /v1/file/uplink/analysis\n\nconst { cError } = global.get('utilities.js');\nconst { getSession } = global.get('data-service.js');\nconst { File } = global.get('entity.js');\nconst { req, res } = msg;\n\ntry {\n    // LẤY SESSION\n    const session = await getSession(req);\n    if (!session) throw new cError(401, 'Please login to continue');\n\n    node.warn({ session });\n\n    // // LẤY S3 CLIENT\n    const s3 = session.s3;\n\n    if (!s3) throw new cError(500, 'Failed to create an uplink');\n\n    // TẠO PRESIGNED OBJECT\n    const presignedObject = await s3.newUpLink({\n        metadata: {\n            fileInfo: req.params.fileInfo || {}, // {fileName, fileMime, fileSize, }\n            fileCategory: req.params.fileCategory || [], // [RawData, PreparedReport, Calculation, Quote, PGM, BBBG, SampleImage ...]\n            foreignKeys: req.params.foreignKeys || [], // [UID, UID, ...]\n            fileGroupUID: req.params.fileGroupUID || '',\n            createdByUID: req.params.createdByUID || '',\n            uploadedByUID: req.params.uploadedByUID || '',\n            reviewedByUID: req.params.reviewedByUID || '',\n            signedByUID: req.params.signedByUID || '',\n            uploadDescription: req.params.uploadDescription || '',     // TEXT\n            isAutoGen: req.params.isAutoGen || false,          // BOOLEAN\n        },\n        expiry: req.params.expiry || 604800,\n        appUID: session.appUID,\n        identityUID: session.identityUID,\n        bucketName: session.s3Bucket,\n        objectPath: `activities/lab`,\n        reqParams: null,\n        requestDate: null,\n    });\n\n    if (!presignedObject) throw new cError(500, 'Failed to create an uplink');\n\n    msg.payload = presignedObject;\n    msg.statusCode = 200;\n    return msg;\n\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred' };\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1220,
        "y": 340,
        "wires": [
            [
                "253bf74eeb9b3460"
            ]
        ]
    },
    {
        "id": "253bf74eeb9b3460",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1430,
        "y": 340,
        "wires": []
    },
    {
        "id": "1587ad7768e305d8",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/file/downlink",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 880,
        "y": 500,
        "wires": [
            [
                "c29b9ebad61c8a54"
            ]
        ]
    },
    {
        "id": "c29b9ebad61c8a54",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "get downlink",
        "func": "const { getSession,checkPermission } = global.get(\"data-service.js\");\n\ntry {\n    //Check session\n    const { req } = msg;\n    const session = await getSession(req);\n    const user = session.user ? await session.getUser() : null;\n\n    if (user) {\n        const sessionData = session.serialize();\n        const {targetType, eventType} = req.body;\n        const permission = await checkPermission(sessionData,targetType,eventType);\n        if(permission){\n            msg.statusCode = 200;\n            msg.payload = { hasPermission: true};\n        }else{\n            // msg.statusCode = 403;\n            msg.payload = {\n                statusCode:403,\n                message: 'You do not have permission to perform this action' ,\n                hasPermission:false\n                };\n        }\n    } else {\n        msg.statusCode = 401;\n        msg.payload = { message: 'Session is expired. Please login to continue' };\n    }\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred', statusCode: error.statusCode };\n        node.warn({msg});\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\n\nnode.warn(msg.payload);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1210,
        "y": 500,
        "wires": [
            [
                "13c6f87da8249ca2"
            ]
        ]
    },
    {
        "id": "13c6f87da8249ca2",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1430,
        "y": 500,
        "wires": []
    },
    {
        "id": "5d4bc91b8fb66c67",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/file/info",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 860,
        "y": 540,
        "wires": [
            [
                "b89ec3d8b06d84ed"
            ]
        ]
    },
    {
        "id": "b89ec3d8b06d84ed",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "object info",
        "func": "// get object info \n// can include thumbnail size request ",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1210,
        "y": 540,
        "wires": [
            [
                "3be12f28bfe1ed35"
            ]
        ]
    },
    {
        "id": "3be12f28bfe1ed35",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1430,
        "y": 540,
        "wires": []
    },
    {
        "id": "941652e0ad95ba8b",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/file/replacelink",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 880,
        "y": 460,
        "wires": [
            [
                "e269a0b67cc450f9"
            ]
        ]
    },
    {
        "id": "e269a0b67cc450f9",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "new replace link",
        "func": "const { getSession,checkPermission } = global.get(\"data-service.js\");\n\ntry {\n    //Check session\n    const { req } = msg;\n    const session = await getSession(req);\n    const user = session.user ? await session.getUser() : null;\n\n    if (user) {\n        const sessionData = session.serialize();\n        const {targetType, eventType} = req.body;\n        const permission = await checkPermission(sessionData,targetType,eventType);\n        if(permission){\n            msg.statusCode = 200;\n            msg.payload = { hasPermission: true};\n        }else{\n            // msg.statusCode = 403;\n            msg.payload = {\n                statusCode:403,\n                message: 'You do not have permission to perform this action' ,\n                hasPermission:false\n                };\n        }\n    } else {\n        msg.statusCode = 401;\n        msg.payload = { message: 'Session is expired. Please login to continue' };\n    }\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred', statusCode: error.statusCode };\n        node.warn({msg});\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\n\nnode.warn(msg.payload);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1220,
        "y": 460,
        "wires": [
            [
                "d0b014feb9930547"
            ]
        ]
    },
    {
        "id": "d0b014feb9930547",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1430,
        "y": 460,
        "wires": []
    },
    {
        "id": "dd18aa6ca672ed6a",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/file/uplink/image/sample/activities",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 940,
        "y": 380,
        "wires": [
            [
                "c87432613ffb7891"
            ]
        ]
    },
    {
        "id": "c87432613ffb7891",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "new sample image",
        "func": "const { getSession,checkPermission } = global.get(\"data-service.js\");\n\ntry {\n    //Check session\n    const { req } = msg;\n    const session = await getSession(req);\n    const user = session.user ? await session.getUser() : null;\n\n    if (user) {\n        const sessionData = session.serialize();\n        const {targetType, eventType} = req.body;\n        const permission = await checkPermission(sessionData,targetType,eventType);\n        if(permission){\n            msg.statusCode = 200;\n            msg.payload = { hasPermission: true};\n        }else{\n            // msg.statusCode = 403;\n            msg.payload = {\n                statusCode:403,\n                message: 'You do not have permission to perform this action' ,\n                hasPermission:false\n                };\n        }\n    } else {\n        msg.statusCode = 401;\n        msg.payload = { message: 'Session is expired. Please login to continue' };\n    }\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred', statusCode: error.statusCode };\n        node.warn({msg});\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\n\nnode.warn(msg.payload);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1230,
        "y": 380,
        "wires": [
            [
                "f54ac9e8eb84cafd"
            ]
        ]
    },
    {
        "id": "f54ac9e8eb84cafd",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1430,
        "y": 380,
        "wires": []
    },
    {
        "id": "e1d4521322d9f362",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/file/uplink/upload_complete",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 920,
        "y": 580,
        "wires": [
            [
                "94d31d27dc1eb26d"
            ]
        ]
    },
    {
        "id": "94d31d27dc1eb26d",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "on complete",
        "func": "const { getSession,checkPermission } = global.get(\"data-service.js\");\n\ntry {\n    //Check session\n    const { req } = msg;\n    const session = await getSession(req);\n    const user = session.user ? await session.getUser() : null;\n\n    if (user) {\n        const sessionData = session.serialize();\n        const {targetType, eventType} = req.body;\n        const permission = await checkPermission(sessionData,targetType,eventType);\n        if(permission){\n            msg.statusCode = 200;\n            msg.payload = { hasPermission: true};\n        }else{\n            // msg.statusCode = 403;\n            msg.payload = {\n                statusCode:403,\n                message: 'You do not have permission to perform this action' ,\n                hasPermission:false\n                };\n        }\n    } else {\n        msg.statusCode = 401;\n        msg.payload = { message: 'Session is expired. Please login to continue' };\n    }\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred', statusCode: error.statusCode };\n        node.warn({msg});\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\n\nnode.warn(msg.payload);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1210,
        "y": 580,
        "wires": [
            [
                "58b8db6ccd911763"
            ]
        ]
    },
    {
        "id": "58b8db6ccd911763",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1430,
        "y": 580,
        "wires": []
    }
]