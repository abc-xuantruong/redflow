[
    {
        "id": "f3deaa9ef8948c89",
        "type": "tab",
        "label": "Main",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7c3157bf68c1b848",
        "type": "tab",
        "label": "DASHBOARD",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b5db9eb4f8a97ec0",
        "type": "group",
        "z": "f3deaa9ef8948c89",
        "name": "S3 Notifications",
        "style": {
            "label": true
        },
        "nodes": [
            "0730a908731fd351",
            "936ab34d061b13bd",
            "ae2ad0ce0408670d",
            "f058ed39b81ee1c5",
            "70c321c215674dc8",
            "e90275fd1d80699e"
        ],
        "x": 774,
        "y": 379,
        "w": 562,
        "h": 122
    },
    {
        "id": "4e2aeff839f1c074",
        "type": "telegram client config",
        "botname": "IRDOP Internal Service",
        "verboselogging": false,
        "loginmode": "bot",
        "useproxy": false,
        "usewss": false,
        "devicemodel": "",
        "systemversion": "",
        "appversion": "",
        "host": "",
        "sockstype": "5",
        "port": "6667",
        "username": "anonymous",
        "password": "",
        "secret": "",
        "mtproxy": false,
        "timeout": "2"
    },
    {
        "id": "acac4ace959569ed",
        "type": "telegram client config",
        "botname": "oa_zalo_bot",
        "verboselogging": false,
        "loginmode": "bot",
        "useproxy": false,
        "usewss": false,
        "devicemodel": "",
        "systemversion": "",
        "appversion": "",
        "host": "",
        "sockstype": "5",
        "port": "6667",
        "username": "anonymous",
        "password": "",
        "secret": "",
        "mtproxy": false,
        "timeout": "2"
    },
    {
        "id": "39d97d88c2550518",
        "type": "global-config",
        "name": "global-config",
        "env": [
            {
                "name": "dbConfig",
                "value": "{\"LIMS-IRDOP-PRD\":{\"database\":\"LIMS\",\"user\":\"postgres\",\"host\":\"red.irdop.org\",\"pw\":\"exploring-dynasty-system\",\"port\":5432},\"LIMS-IRDOP-DEV\":{\"database\":\"LIMS-DEV\",\"user\":\"postgres\",\"host\":\"red.irdop.org\",\"pw\":\"exploring-dynasty-system\",\"port\":5432}}",
                "type": "json"
            },
            {
                "name": "s3Config",
                "value": "{\"LIMS-IRDOP-DEV\":{\"endPoint\":\"s3.irdop.org\",\"port\":443,\"useSSL\":true,\"accessKey\":\"rNItZci16fmAVcb9HA2e\",\"secretKey\":\"GD1hNEGOteycopeFIDWqPItFoULeJvGkX52LMBdt\",\"bucket\":\"irdop-dev\"},\"LIMS-IRDOP-PRD\":{\"endPoint\":\"s3.irdop.org\",\"port\":443,\"useSSL\":true,\"accessKey\":\"KH0I7XQM9XrN5bwaeX7d\",\"secretKey\":\"ZrWVaLJKCieBcj5L90BynImIKDSeNrTr4M0yOtOd\",\"bucket\":\"irdop\"}}",
                "type": "json"
            },
            {
                "name": "dbConfig:LIMS-IRDOP-DEV",
                "value": "{\"name\":\"lims-dev\",\"user\":\"postgres\",\"host\":\"postgres-db\",\"pw\":\"exploring-dynasty-system\",\"port\":5432}",
                "type": "str"
            }
        ]
    },
    {
        "id": "5713a18fe4b90d79",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "START",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.001",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 60,
        "wires": [
            [
                "e529ddc66ccceda4"
            ]
        ]
    },
    {
        "id": "35818376b74b9267",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "entity.js",
        "func": "node.status({ fill: 'yellow', shape: 'dot', text: '...' });\nconst { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst dataService = global.get('data-service.js');\nconst { createCache, CacheWorld } = global.get('cache.js');\nconst { ObjectConnection, DataConnection } = global.get('repo.js');\n\nclass Session {\n    #headers = {};\n    #info = {};\n    #discovery = {};\n    s3 = {};   // ObjectStore client\n    db = {};   // Database client\n\n    constructor(info, headers) {\n        if (!info) throw new cError(500, 'Session Info is required');\n        this.className = this.constructor.name;\n        this.#info = { ...info, className: this.className };\n        this.#headers = headers;\n\n        // S3 Client cho Session entity\n        const s3Options = env.get('s3Config')[this.appUID];         // s3 config theo appUID \n        this.s3 = new ObjectConnection(s3Options, this);         // Lưu client vào session\n        node.warn({ s3: this.s3 });\n    }\n\n    // Identity\n    get info() { return this.#info }\n    get identityUID() { return this.#info.identityUID; }\n    get user() { return this.#discovery?.User; }\n    get email() { return this.#discovery?.User?.email; }\n    get identityName() { return this.#discovery?.User?.identityName; }\n    get role() { return this.#info.role; }\n\n    // Auth & access\n    get token() { return this.sessionUID; }\n    get sessionUID() { return this.#info.sessionUID; }\n    get headers() { return this.#headers; }\n    get appUID() { return this.#info.appUID; }\n    set headers(headers) { this.#headers = headers; }\n\n    // Repo\n    get accessKey() { return this.#info.accessKey; }\n\n    async getUser() {       // Lấy userInfo của session này\n        try {\n            const user = await dataService.getUser(this);\n            if (user) this.#discovery['User'] = user;\n            return user;\n        } catch (error) { return null; }\n    }\n\n    async getDb() {         // Establish database connection\n        const startTime = Date.now();     // Track Performance\n        let isSuccess = true;           // Track Performance\n        try {\n            const dbConfig = env.get('dbConfig')[this.appUID];\n            this.db = new DataConnection(dbConfig, this);\n           node.warn({ key:await this.db.query(`SELECT table_name\n            FROM information_schema.tables\n            WHERE table_schema = 'public';`)})\n            //await this.db.connect();\n            return this.db;\n        } catch (error) {\n            isSuccess = false;\n            handleError(error, 'repo.js.Session.getDB()');\n        } finally {\n            trackPerformance(\"repo.js.Session.getDB()\", startTime, isSuccess);\n        }\n    }\n\n    serialize() {           // toJSON \n        return {\n            ...this.info,\n            ...Object.fromEntries(\n                Object.entries(this.#discovery).map(([key, value]) => [\n                    key,\n                    value && typeof value.serialize === 'function' ? value.serialize() : value,\n                ]),\n            ),\n            className: this.className,\n        };\n    }\n}\n\nclass Entity {\n    #discovery = {};\n    #info = {};\n    #session = {};\n\n    constructor(info, session) {\n        if (!info) throw new cError(500, 'Info is required');\n        this.#info = info;\n        this.#session = session;\n    }\n\n    get session() { return this.#session; }\n    get info() { return { ...this.#info, className: this.className }; }\n    get discovery() { return this.#discovery; } // Info mở rộng lưu vào #discovery\n\n    newDiscovery(discovery = {}) {\n        if (discovery) {\n            Object.entries(discovery).forEach(([key, value]) => {\n                if (value && typeof value === 'object' && !Array.isArray(value)) {\n                    this.#discovery[key] = value;\n                } else {\n                    this.#discovery[key] = value;\n                }\n            });\n        }\n    }\n\n    // Info mở rộng lưu vào #discovery\n    serialize() {       // convert object gồm cả info đã mở rộng từ newDiscovery\n        return {\n            ...this.info,\n            ...Object.fromEntries(\n                Object.entries(this.#discovery).map(([key, value]) => [\n                    key,\n                    value && typeof value.serialize === 'function' ? value.serialize() : value,\n                ])\n            ),\n        };\n    }\n\n    // PERMISSION\n    getPermissionFor(action) {\n\n    }\n\n    addLog(logType, logTime, logForEntity, fnName, data) {\n        const options = {\n            logType: logType || '',           // event/scheduled | auto/manual |\n            logObject: logForEntity || '',           // Sử dụng thiết bị, theo dõi môi trường, nhật ký hệ thống, nhật ký thử nghiệm, nhật ký người dùng, nhật ký mẫu,\n            logNotion: '',                           // error, warning, info\n            timestamp: logTime || Date.now(),\n            systemLog: {\n                entity: this.className,\n                fnName: fnName || '',\n                timestamp: Date.now(),\n                sessionUID: this.session.sessionUID,\n                appUID: this.session.appUID,\n                accessKey: this.session.accessKey,\n                identityUID: this.session.identityUID,\n            },\n            description: data.description || '',\n        };\n\n        const doneBy = `thực hiện bởi ${this.session.identityName || this.session.identityUID}`;\n    }     // TODO\n    addAudit(actionType, timestamp, fnName, description) { }   // TODO\n}\n\nclass User extends Entity {\n    constructor(info, session) {\n        super(info, session);\n\n        // Tạo getter từ info object\n        Object.keys(info).forEach(key => {\n            if (key !== 'className') {\n                Object.defineProperty(this, key, {\n                    get: () => this.info[key],\n                    enumerable: true,\n                    configurable: true,\n                });\n            }\n        });\n        this.className = 'User';\n    }\n\n    get relation() { return this.discovery?.relations; }\n\n    async editInfo(newInfo) {\n        if (newInfo) {\n            // query/ post / access\n        }\n        return new User(this.info, this.session);\n    }\n\n    async newRelation(relation) {\n        if (relation?.appUID) {\n            // query/ post / access return {}\n            this.newDiscovery({ relations: await this.getRelation() });\n        }\n        // relations = [\n        //     {\n        //         appUID: 'LIMS-IRDOP-DEV',\n        //         disabled: false,\n        //         staff: true,\n        //         staff_technician: true,\n        //     }, {\n        //         appUID: 'LIMS-IRDOP-DEV',\n        //         disabled: false,\n        //         staff: true,\n        //         staff_technician: true,\n        //     },\n        // ]\n    }\n\n    async getRelationList() { }\n\n    async getRelation(appUID) { }\n\n    // CHECK Permission\n    canEdit() {\n    }\n}\n\n// TODO CLASS: Analysis, Sample, Receipt\n// TODO CLASS: File (with fileInfo {...})6\n// TODO CLASS: Log      (actionType on any entity) \n// TODO CLASS: Audit    (actionType on any entity)\n\nglobal.set('entity.js', { Session, User });\nnode.status({ fill: 'green', shape: 'dot', text: 'OK' });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 180,
        "wires": [
            [
                "1921ea2569c8fb02",
                "c3a6768321b9b8ce"
            ]
        ]
    },
    {
        "id": "1921ea2569c8fb02",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "data-service",
        "func": "node.status({ fill: 'yellow', shape: 'dot', text: '...' });\nconst { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst { convertCamelCase, convertSnakeCase } = global.get('utilities.js');\nconst { Session, User } = global.get('entity.js');\nconst { createCache } = global.get('cache.js');\nconst axios = global.get('axios');\nconst { Pool } = pg;\n\n// DECLARE CACHES\nconst sessionCache = createCache('Session', 120 * 60 * 1000);        // 2 hour\nconst userCache = createCache('User', 60 * 60 * 1000);        // 1 hour\nconst analysisCache = createCache('Analysis', 60 * 60 * 1000);        // 1 hour\nconst sampleCache = createCache('Sample', 60 * 60 * 1000);        // 1 hour\nconst receiptCache = createCache('Receipt', 60 * 60 * 1000);        // 1 hour\n\n// SESSION & USER main functions\nasync function getSession(req) {\n    // Validate và lấy ra appUID + sessionUID + accessKey(nếu có)\n    const { headers } = req;\n    let appUID = headers?.['x-fh-app-uid'];\n    if (!appUID) throw new cError(400, \"Please provide appUID\")\n    if (!headers?.['authorization']) throw new cError(401, \"Please login to continue\")\n    const sessionUID = headers?.['authorization'].split(' ')[1] || headers?.['Authorization'].split(' ')[1];\n    const accessKey = headers?.['x-fh-access-key'] || env.get('s3Config')[appUID];    // USER or SERVER KEY\n\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `Session:${sessionUID}`;      // Định danh cache\n        let cachedSession = sessionCache.get(cacheKey);   // Tìm cache\n        if (cachedSession) {\n            node.warn(`Cached session found: ${cacheKey}`);\n            return cachedSession;           // Trả về cache (nếu có)\n        }\n\n        // CONSTRUCT SESSION CLASS\n        const endpoint = \"https://pink.irdop.org/ab4dg2/auth/me\";\n        const headers = {\n            \"Content-Type\": `application/json`,\n            \"Authorization\": `Bearer ${sessionUID}`,   // từ user request\n            \"x-fh-app-uid\": appUID,                   // từ user request\n            \"x-fh-access-key\": accessKey,                // từ user request hoặc server setting\n        };\n\n        // GET SESSION INFO\n        const response = await axios.post(endpoint, {}, { headers });\n        const sessionInfo = convertCamelCase(response?.data);\n\n        if (!sessionInfo) throw new cError(401, 'Please login to continue');\n\n        // CONSTRUCT SESSION\n        const session = new Session(sessionInfo, headers);\n        await session.getUser();    // Preload user info\n        await session.getDb()       // Preload Database connection\n\n        // SET CACHE & RETURN\n        return sessionCache.set(cacheKey, session);\n    } catch (error) {\n        handleError(error, 'data-service.js.getSession');\n        throw error;\n    } finally {\n        trackPerformance('data-service.js.getSession', startTime);\n    }\n}\nasync function loginUser(req) {\n    const { body, headers } = req;\n    const { email, password } = body;\n    const startTime = Date.now();\n    try {\n        const appUID = headers?.['x-fh-app-uid'];\n        if (!email) throw new cError(400, \"Please provide email\");\n        if (!password) throw new cError(400, \"Please provide password\");\n        if (!appUID) throw new cError(400, \"No application is provided for your login session\");\n\n        node.warn(123123);\n        // GET SESSION\n        const response = await axios.post('https://pink.irdop.org/gre134e/auth/login', { email, password }, {\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'x-fh-app-uid': appUID\n            }\n        });\n\n        // RESPONSE\n        const sessionInfo = convertCamelCase(response?.data);\n        if (!sessionInfo) throw new cError(401, 'Failed to validate your credentials');\n\n        // CREATE SESSION ENTITY\n        const session = new Session(sessionInfo, headers);\n        await session.getUser();    // Preload user info\n        await session.getDb();      // Preload Database Pool\n        const cacheKey = `Session:${session.token}`;\n        sessionCache.set(cacheKey, session);\n        return session;\n    } catch (error) {\n        handleError(error, `data-service.js.loginUser [${email}]`);\n        throw error;\n    } finally {\n        trackPerformance(`data-service.js.loginUser [${email}]`, startTime, true);\n    }\n}\nasync function getUser(session) {\n    // Validate và lấy ra identityUID + email\n    if (typeof session !== 'object') throw new cError(400, 'session input must be an object');\n    const { identityUID, email } = session;\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `User:${identityUID}`;    // Định danh cache\n        const userInfo = userCache.get(cacheKey) ? userCache.get(cacheKey) : async () => {\n            // GET USER INFO\n            const endpoint = \"https://pink.irdop.org/ab4dg2/get/iden\";\n            const body = { identity_uid: identityUID, email: email };\n            const headers = session.headers;\n            const response = await axios.post(endpoint, body, { headers });\n            const userInfo = convertCamelCase(response?.data);         // convert to camelCase format\n            if (!userInfo) throw new cError(404, 'User not found');\n\n            // Set cache & return\n            return userCache.set(cacheKey, userInfo);\n        }\n\n        // CREATE USER ENTITY\n        const user = new User(userInfo, session);\n        return user;\n    } catch (error) {\n        node.warn({ error });\n        handleError(error, 'data-service.js.getUser');\n        throw error;\n    } finally {\n        trackPerformance('data-service.js.getUser', startTime, true);\n    }\n}\nasync function getUserByInfo(identity, session) {\n    const startTime = Date.now();\n    try {\n        const { identityUID, email } = identity;\n        if (!identityUID && !email) throw new cError(400, \"Please provide identityUID or email\");\n\n        // TRY CACHE\n        const cacheKey = `User:${identityUID || email}`;   // Định danh cache\n        const cachedUser = userCache.get(cacheKey);          // Tìm cache\n        if (cachedUser) return cachedUser;                  // Trả về cache nếu có\n\n        // SEND REQUEST\n        const endpoint = \"https://pink.irdop.org/ab4dg2/get/iden\";\n        const body = { identity_uid: identityUID, email };\n        const headers = { ...session.headers };\n        const response = await axios.post(endpoint, body, { headers });\n\n        // CONVERT TO CAMEL CASE\n        const userInfo = convertCamelCase(response?.data);\n        if (!userInfo) throw new cError(404, 'User not found');\n\n        // RETURN USER ENTITY & CACHE\n        const user = new User(userInfo, session);\n        userCache.set(cacheKey, user);\n        return user;\n    } catch (error) {\n        handleError(error, 'data-service.js.getUser');\n        throw error;\n    } finally {\n        trackPerformance('getUser', startTime, true);\n    }\n\n}\nasync function newUser(req, session) {\n    const { identityName, email } = req?.body;\n    // Với user phải có identityName và email (Bot/Server thì không cần)\n    if (!identityName) throw new cError(400, \"Please provide identity name\");\n    if (!email) throw new cError(400, \"Please provide email\");\n\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `User:${identityName}:${email}`;    // Định danh cache\n        const cachedUser = userCache.get(cacheKey);   // Tìm cache\n        if (cachedUser) throw new cError(400, 'User already exists'); // User đã tồn tại\n\n        // PREPARE RELATIONS\n        const { relations } = req.body;     // Lấy relations từ POST request\n        if (Array.isArray(relations) && relations.length > 0) {\n            // Format relations to match the API\n            relations.forEach(relation => {\n                return {\n                    relation_name: session.appUID, // gán appUID cho relation_name\n                    ...relation\n                };\n            });\n        }\n\n        // POST NEW USER\n        const newUser = await axios.post('https://pink.irdop.org/ab4dg2/insert/iden', {\n            identity_name: identityName,                // Bắt buộc\n            email: email,                               // Bắt buộc\n            password: req.body.password,\n            identity_contact: req.body.identityContact || {},\n            telegram_peer: req.body.telegramPeer || {},\n            zalo_user_id: req.body.zaloUserId || \"\",\n            relations: relations || [],\n        }, {\n            headers: {\n                ...session.headers,            // session built-in headers\n            }\n        });\n\n        const userInfo = convertCamelCase(newUser?.data);\n        // Failed to create user\n        if (!userInfo) throw new cError(400, 'Failed to create a new user');\n\n        // CREATE USER ENTITY\n        const user = new User(userInfo, session);\n        userCache.set(cacheKey, user);   // Cache user\n        return user;\n    } catch (error) {\n        handleError(error, 'newUser');\n        throw error;\n    } finally {\n        trackPerformance(`newUser [${identityName} - ${email}]`, startTime, true);\n    }\n}\n\n// SAMPLE & ANALYSIS\n\n// TODO: GET analysis, sample, receipt\n// TODO: GET fileUpLink, fileInfo, fileDownLink\n\nglobal.set('data-service.js', {\n    getSession,\n    getUser,\n    getUserByInfo,\n    loginUser,\n    newUser,\n})\nnode.status({ fill: 'green', shape: 'dot', text: 'OK' });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "pg",
                "module": "pg"
            }
        ],
        "x": 730,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "26e4fd86f86ad619",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "auth session",
        "func": "const { getSession } = global.get(\"data-service.js\");\n// GET: https://red.irdop.org/v1/auth/session\nnode.warn({msg})\ntry {\n    // GET SESSION & USER\n    const { req } = msg;\n    const session = await getSession(req);\n    const user = session.user ? await session.getUser() : null;\n\n    // PREPARE RESPONSE\n    if (user) {\n        msg.statusCode = 200;\n        msg.payload = {\n            session: session.serialize(),\n            type: \"AuthSuccess\",\n        };\n    } else {\n        msg.statusCode = 401;\n        msg.payload = { message: 'Session is expired. Please login to continue' };\n    }\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred' };\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\nreturn msg;\n\n/** RESPONSE BODY:\n * {\n *   session: {\n *      ...sessionInfo,\n *      user: {\n *          ...userInfo,\n *          className: \"User\"\n *      }\n *      className: \"Session\"\n *   }\n *   type: \"Auth\"\n * }\n */\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 340,
        "wires": [
            [
                "14cfa6918c935777"
            ]
        ]
    },
    {
        "id": "e529ddc66ccceda4",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "cache",
        "func": "node.status({fill: 'yellow', shape: 'dot', text: '...'});\n\nconst CacheWorld = {}; // global.get('CacheWorld') || {}; <--- dòng code comment này làm leak context giữa các deploy (??)\nglobal.set('CacheWorld', CacheWorld);\n\n\nfunction createCache(cacheName, ttl = 6 * 60 * 1000) {\n    // Validate inputs\n    if (CacheWorld[cacheName]) {\n        node.warn(`[ CAUTION ] Cache name \"${cacheName}\" already exists. Use a different name if intended.`);\n        return CacheWorld[cacheName];\n    }\n    if (typeof ttl !== 'number' || ttl < 0) {\n        throw new Error('Invalid TTL value. It must be a positive number.');\n    }\n    if (!cacheName || typeof cacheName !== 'string') {\n        throw new Error('Cache name is required and must be a string.');\n    }\n\n    const store = new Map();\n    const cache = {\n        ttl,\n        get(key) {\n            const entry = store.get(key);\n            if (!entry) return null;\n            if (this.ttl > 0 && Date.now() - entry.timestamp > this.ttl) {\n                node.warn(`Cache entry \"${key}\" has expired. Cleaning up...`);\n                store.delete(key);\n                return null;\n            }\n            return entry.value;\n        },\n        set(key, value) {\n            store.set(key, { value, timestamp: Date.now() });\n            return value;\n        },\n        has(key) {\n            return store.has(key);\n        },\n        size() {\n            return store.size;\n        },\n        keys() {\n            return Array.from(store.keys());\n        },\n        delete(key) {\n            const entry = store.get(key);\n            if (!entry) return false;\n            if (entry.value && typeof entry.value.clear === 'function') {\n                entry.value.clear();\n            }\n            store.delete(key);\n            return true;\n        },\n        clear() {\n            for (const [, entry] of store) {\n                if (entry.value && typeof entry.value.clear === 'function') {\n                    entry.value.clear();\n                }\n            }\n            store.clear();\n            return true;\n        },\n        getAll() {\n            return Object.fromEntries(Array.from(store, ([key, entry]) => [key, entry.value]));\n        },\n        entries() {\n            return Array.from(store.entries());\n        },\n    };\n\n    CacheWorld[cacheName] = cache;\n    return cache;\n}\n\nfunction getCache(cacheName) {\n    return CacheWorld?.[cacheName];\n}\n\n// CACHE CLEANER\nconst cleaner = setInterval(() => {\n    let totalCleaned = 0;\n    let memoryCleaned = 0;\n    let nameCleaned = [];\n\n    for (const cacheName in CacheWorld) {\n        const cache = CacheWorld[cacheName];\n        if (!cache || cache.size() === 0) continue;\n\n        for (const [key, entry] of cache.entries()) {\n            try {\n                const cacheTTL = cache.ttl || 0;\n                if (cacheTTL > 0 && entry.timestamp + cacheTTL < Date.now()) {\n                    // Clean nested caches if they exist\n                    if (entry.value && typeof entry.value.clear === 'function') {\n                        entry.value.clear();\n                    }\n\n                    // Estimate memory cleaned (rough approximation)\n                    memoryCleaned += JSON.stringify(entry.value).length || 0;\n\n                    // Delete expired entry\n                    cache.delete(key);\n                    totalCleaned++;\n                    nameCleaned.push(key);\n                }\n            } catch (error) {\n                node.error(`Error cleaning cache entry: ${key} in ${cacheName}`, error);\n            }\n        }\n\n        // Remove empty caches from CacheWorld\n        if (cache.size() === 0) {\n            delete CacheWorld[cacheName];\n        }\n    }\n\n    if (totalCleaned > 0) {\n        node.warn(`Cache cleaner removed ${totalCleaned} entries from ${Object.keys(CacheWorld).length} caches. Memory cleaned: ${memoryCleaned} bytes. Cache names: ${nameCleaned.join(', ')}`);\n    }\n}, 5 * 60 * 1000); // every 5 minutes\n\n\nglobal.set('cache.js', {\n    createCache,\n    getCache,\n    CacheWorld,\n});\n\nnode.warn('Cache cleaner is scheduled');\nnode.status({fill: 'green', shape: 'dot', text: 'OK'});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 170,
        "y": 100,
        "wires": [
            [
                "6cace463e1b92b68"
            ]
        ]
    },
    {
        "id": "6cace463e1b92b68",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "utilities",
        "func": "node.status({fill: 'yellow', shape: 'dot', text: '...'});\nconst { createCache } = global.get('cache.js');\nconst performanceData = createCache('performanceData', 0); // No expiration\nconst axios = global.get('axios');\n\nclass cError extends Error {\n    constructor(statusCode, properties, rethrow = true) {\n        if (typeof properties === 'string') {\n            properties = { message: properties, statusCode, rethrow };\n        }\n        else if (typeof properties === 'object') {\n            properties = {\n                message: properties.message || 'An error occurred',\n                statusCode: properties.statusCode || properties.code || 500,\n                rethrow: rethrow || properties.rethrow || false,\n            };\n        }\n        else {\n            properties = { message: 'An error occurred', statusCode, rethrow };\n        }\n        super(properties.message);\n\n        // Capture the stack trace\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, cError);\n        }\n        this.statusCode = statusCode || 500;\n        this.catchCount = 0;\n    }\n}\n\nfunction handleError(error, functionName, rethrow = false) {\n    if (error.catchCount++ === 0) {\n        node.warn(`${error.message} (caused at ${functionName})\\n${error.stack}`);\n    }\n    return error;\n}\n\nfunction trackPerformance(functionName, startTime, isSuccess = true) {\n    const elapsedTime = Date.now() - startTime;\n    const currentData = performanceData.get(functionName) || { count: 0, totalTime: 0, successCount: 0, errorCount: 0 };\n    currentData.count += 1;\n    currentData.totalTime += elapsedTime;\n    if (isSuccess) {\n        currentData.successCount += 1;\n    } else {\n        currentData.errorCount += 1;\n    }\n    performanceData.set(functionName, currentData);\n    return currentData;\n}\n\nfunction printPerformanceData() {\n    const data = performanceData.getAll();\n    let message = 'Performance Data:\\n';\n    let messageList = [];\n    for (const [functionName, { count, totalTime, successCount, errorCount }] of Object.entries(data)) {\n        const averageTime = totalTime / count;\n        messageList.push(`Function: ${functionName}, Calls: ${count}, Total Time: ${totalTime}ms, Average Time: ${averageTime.toFixed(2)}ms, Success: ${successCount}, Errors: ${errorCount}\\n`);\n    }\n    if (messageList.length > 0)\n        message += messageList.join('');\n    else\n        message += 'No data.';\n    node.warn(message);\n}\n\nasync function testPoolConnection(pool) {\n    try {\n        await pool.query('SELECT 1');\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function getColumnValues(tableName, pool, data) {\n    try {\n        const result = await pool.query(\n            `SELECT column_name FROM information_schema.columns WHERE table_name = $1`,\n            [tableName]\n        );\n        const allColumns = result.rows.map(row => row.column_name);\n\n        const columns = [];\n        const values = [];\n        for (const column of allColumns) {\n            if (data.hasOwnProperty(column)) {\n                columns.push(column);\n                values.push(data[column]);\n            }\n        }\n\n        return { columns, values };\n    } catch (error) {\n        handleError('file-access.getColumnValues', error, true);\n    }\n}\n\nfunction convertSnakeCase(input) {\n    // if (typeof input === 'string') {\n    //     // Check if the string is already in snake_case\n    //     if (!/[A-Z]/.test(input)) {\n    //         return input; // Return as-is if no uppercase letters are found\n    //     }\n    //     // Convert camelCase string to snake_case\n    //     return input.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()\n    //         .replace(/(?<![a-z])UID(?![a-z])/g, '_uid'); // Special case for UID, ensuring it's not part of a larger word\n    // } else \n    if (typeof input === 'object' && input !== null) {\n        if (Array.isArray(input)) {\n            // If it's an array, recursively process each element\n            return input.map(item => convertSnakeCase(item));\n        } else {\n            // If it's an object, process each key and value\n            return Object.keys(input).reduce((acc, key) => {\n                const snakeKey = key.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()\n                    .replace(/(?<![a-z])UID(?![a-z])/g, '_uid'); // Special case for UID, ensuring it's not part of a larger word\n                acc[snakeKey] = convertSnakeCase(input[key]);\n                return acc;\n            }, {});\n        }\n    }\n    // Return other data types as-is\n    return input;\n}\n\nfunction convertCamelCase(input) {\n    // if (typeof input === 'string') {\n    //     // Handle special case for _uid first\n    //     input = input.replace(/_uid/g, 'UID');\n\n    //     // Check if the string is already in camelCase\n    //     if (!/_/.test(input) || input.length > 3 && input?.slice(0,3) === 'sx_') {\n    //         return input; // Return as-is if no underscores are found\n    //     }\n\n    //     // Convert snake_case string to camelCase\n    //     return input.replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n    // } else \n    if (typeof input === 'object' && input !== null) {\n        if (Array.isArray(input)) {\n            // If it's an array, recursively process each element\n            return input.map(item => convertCamelCase(item));\n        } else {\n            // If it's an object, process each key and value\n            return Object.keys(input).reduce((acc, key) => {\n                const camelKey = key.replace(/_uid/g, 'UID')\n                    .replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n                acc[camelKey] = convertCamelCase(input[key]);\n                return acc;\n            }, {});\n        }\n    }\n    // Return other data types as-is\n    return input;\n}\n\nglobal.set('utilities.js', {\n    handleError,\n    trackPerformance,\n    printPerformanceData,\n    cError,\n    testPoolConnection,\n    getColumnValues,\n    convertSnakeCase,\n    convertCamelCase\n});\n\nnode.status({fill: 'green', shape: 'dot', text: 'OK'});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 260,
        "y": 140,
        "wires": [
            [
                "bf234ff85f0c2f41"
            ]
        ]
    },
    {
        "id": "7e61714455d1fd33",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "Login User",
        "func": "const { loginUser } = global.get('data-service.js');\n// endpoint: https://red.irdop.org/v1/auth/login\n\n// RESPONSE { session: { ... }, type: 'LoginSuccess' }\n//\n\ntry {\n    const { req } = msg;\n    const session = await loginUser(req);\n\n    if (session?.info) {\n        msg.statusCode = 200;\n        msg.payload = {\n            session: session.serialize(),\n            type: 'LoginSuccess',\n        };\n    } else {\n        msg.statusCode = 403;\n        msg.payload = { message: 'Access denied' };\n    }\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;\n    msg.payload = { message: error.message };\n    node.error(error);\n}\n\nreturn msg;\n\n\n// // Test input\n// const req = {};\n// req.headers = {\n//     'Content-Type': 'application/json',\n//     'Accept': 'application/json',\n//     'x-fh-app-uid': 'LIMS-IRDOP-PRD',\n// }\n// req.body = {\n//     email: 'abc@xuantruong.xyz',\n//     password: 'xt012j',\n// };",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 380,
        "wires": [
            [
                "5dd6f391b1630e96"
            ]
        ]
    },
    {
        "id": "01e6f89d395c8166",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/auth/login",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 380,
        "wires": [
            [
                "7e61714455d1fd33"
            ]
        ]
    },
    {
        "id": "5dd6f391b1630e96",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 380,
        "wires": []
    },
    {
        "id": "9c20c2e033e39f7e",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/auth/session",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 340,
        "wires": [
            [
                "26e4fd86f86ad619"
            ]
        ]
    },
    {
        "id": "14cfa6918c935777",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 340,
        "wires": []
    },
    {
        "id": "34a32b0c48f415b2",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "New User",
        "func": "const { loginUser } = global.get('data-service.js');\n// endpoint: https://red.irdop.org/v1/auth/login\n\n// RESPONSE { session: { ... }, type: 'LoginSuccess' }\n//\n\ntry {\n    const { req } = msg;\n    const session = await loginUser(req);\n\n    if (session?.info) {\n        msg.statusCode = 200;\n        msg.payload = {\n            session: session.serialize(),\n            type: 'LoginSuccess',\n        };\n    } else {\n        msg.statusCode = 403;\n        msg.payload = { message: 'Access denied' };\n    }\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;\n    msg.payload = { message: error.message };\n    node.error(error);\n}\n\nreturn msg;\n\n\n// // Test input\n// const req = {};\n// req.headers = {\n//     'Content-Type': 'application/json',\n//     'Accept': 'application/json',\n//     'x-fh-app-uid': 'LIMS-IRDOP-PRD',\n// }\n// req.params = {\n//     email: 'abc@xuantruong.xyz',\n//     password: 'xt012j',\n// };",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 500,
        "wires": [
            [
                "75c54f96498fed4f"
            ]
        ]
    },
    {
        "id": "624483601a2c0a6c",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/user/new",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 500,
        "wires": [
            [
                "34a32b0c48f415b2"
            ]
        ]
    },
    {
        "id": "75c54f96498fed4f",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 500,
        "wires": []
    },
    {
        "id": "36f2943ff908aed4",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 85,
        "y": 260,
        "wires": [
            [
                "a9a92aabb3b0b68a"
            ]
        ],
        "l": false
    },
    {
        "id": "a9a92aabb3b0b68a",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "Print Performance Data",
        "func": "const { printPerformanceData } = global.get('utilities.js');\nprintPerformanceData();\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 230,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "5b12f9edbda9b6bd",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "Get User Info",
        "func": "// url: https://red.irdop.org/v1/user/info\n// method: POST\nconst { cError } = global.get('utilities.js');\nconst { getSession, getUserByInfo } = global.get('data-service.js');\nnode.warn('GET USER INFO');\ntry {\n    const { req } = msg;\n    const session = await getSession(req);\n    if (!session) throw new cError(401, 'Session is expired. Please login to continue');\n\n    const { params } = req;\n    if (!params) throw new cError(400, 'Bad request. A query is required');\n    if (!params.identityUID && !params.email) throw new cError(400, 'An email or identity is required');\n\n    const user = await getUserByInfo(params, session);\n    if (user) {\n        msg.statusCode = 200;\n        msg.payload = {\n            user: user.serialize(),\n            type: \"UserInfo\",\n        };\n\n    } else {\n        msg.statusCode = 404;\n        msg.payload = { message: 'User not found' };\n    }\n\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred' };\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 420,
        "wires": [
            [
                "3734c6c883f592d4"
            ]
        ]
    },
    {
        "id": "c81954ca1fe00eb2",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/user/info/:identityUID",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 420,
        "wires": [
            [
                "5b12f9edbda9b6bd"
            ]
        ]
    },
    {
        "id": "3734c6c883f592d4",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 420,
        "wires": []
    },
    {
        "id": "403ce01496e111e6",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 3100,
        "y": 80,
        "wires": [
            [
                "da4b71158770682e"
            ]
        ]
    },
    {
        "id": "9a0e363b9d06a71d",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "function 14",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3250,
        "y": 200,
        "wires": [
            [
                "b6fb6469bec408a3"
            ]
        ]
    },
    {
        "id": "8eaadab6625cf21e",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/kkj",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 3060,
        "y": 200,
        "wires": [
            [
                "9a0e363b9d06a71d"
            ]
        ]
    },
    {
        "id": "b6fb6469bec408a3",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 3430,
        "y": 220,
        "wires": []
    },
    {
        "id": "da4b71158770682e",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "function 15",
        "func": "node.warn({msg})\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3250,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "040785e928e90fa2",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 295,
        "y": 180,
        "wires": [
            [
                "bf234ff85f0c2f41"
            ]
        ],
        "l": false
    },
    {
        "id": "c3a6768321b9b8ce",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "document.js",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "025ddee93afcb9d3",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "function 18",
        "func": "const repo = global.get('repo.js');\nconst { getSession,\n    getUser,\n    getUserByInfo,\n    loginUser,\n    newUser} = global.get('data-service.js');\n\nconst { trackPerformance, cError, handleError } = global.get('utilities.js');\n\nif (!repo) {\n    node.status({ fill: 'red', shape: 'dot', text: 'repo.js not found in global context' });\n    node.error(\"repo.js not found in global context. Make sure the node defining it runs first.\");\n    return null;\n}\n\nconst { s3Client } = repo;\n\nconst minioOptions = {\n    \"endPoint\": \"s3.irdop.org\",\n    \"accessKey\": \"rNItZci16fmAVcb9HA2e\",\n    \"secretKey\": \"GD1hNEGOteycopeFIDWqPItFoULeJvGkX52LMBdt\",\n};\n\nconst session = {\n    identityUID: 'user-123',\n    identityName: 'Test User',\n    s3Bucket: 'irdop-dev',\n};\n\n(async function() {\n    let presignedGetUrl = null;\n    let presignedPutUrl = null;\n        node.warn(\"this is f18\")\n\n    node.warn(getSession(msg))\n    try {\n        const minioS3Client = new s3Client(minioOptions, session);\n        node.warn(\"[Usage] s3Client instance created.\");\n\n        const objectToPut = 'tmp/a.txt';\n        const expiryForPut = 600;\n        const uploadMetaData = {\n        };\n        // presignedPutUrl = await minioS3Client.getPresignedPutUrl(objectToPut, expiryForPut, uploadMetaData);\n        //  if (presignedPutUrl) {\n        //      node.log(`[Usage] Đã nhận Presigned URL PUT cho \"${objectToPut}\": ${presignedPutUrl}`);\n        //      msg.payload = {\n        //          action: 'upload',\n        //          objectName: objectToPut,\n        //          presignedPutUrl: presignedPutUrl\n        //      };\n        // } else {\n        //      throw new cError(500, 'Info is required');\n        // }\n\n        // msg.payload = msg.payload || {};\n\n        // if (presignedGetUrl) {\n        //     msg.payload.presignedGetUrl = presignedGetUrl;\n        // }\n        //  if (presignedPutUrl) {\n        //      msg.payload.presignedPutUrl = presignedPutUrl;\n        //      msg.payload.objectToPut = objectToPut;\n        //  }\n        return msg;\n    } catch (error) {\n        throw new cError(500, \"Error with presignUrl :\"+error);\n    }\n})();",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 180,
        "wires": [
            [
                "4d3a98c42477cca6"
            ]
        ]
    },
    {
        "id": "ad02195183ff5441",
        "type": "comment",
        "z": "f3deaa9ef8948c89",
        "name": "SQL SCHEMA",
        "info": "CREATE TABLE \"S3PresignedUrl\" (\n        -- Presigned URL\n)\n\nCREATE TABLE \"S3Object\" (\n        \"fileUID\",\n        \"createdAt\",\n        \"deletedAt\",\n        \"identityUID\",\n        \"appUID\",\n        \"fileInfo\",     -- {fileName, fileMime, ... }\n\n        \"bucketName\",\n        \"objectName\",\n        \"versionID\"\n        \"eTag\"\n)\n\nCREATE TABLE \"Document\" (\n        \"documentUID\",     -- prefix uuid v4\n        \"createdAt\",\n        \"deletedAt\",\n        \"modifiedAt\",\n\n        \"className\",       -- SampleDocument, SOP, Equipment, Personel,...\n        \"data\",            -- Serialized class data\n)\n\nCREATE TABLE \"AuditTrail\" (\n        \n)",
        "x": 940,
        "y": 40,
        "wires": []
    },
    {
        "id": "0730a908731fd351",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "",
        "url": "/v1/s3hook/notification",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 920,
        "y": 420,
        "wires": [
            [
                "936ab34d061b13bd"
            ]
        ],
        "icon": "node-red/leveldb.svg"
    },
    {
        "id": "936ab34d061b13bd",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "s3 events",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 420,
        "wires": [
            [
                "ae2ad0ce0408670d"
            ]
        ]
    },
    {
        "id": "ae2ad0ce0408670d",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1260,
        "y": 420,
        "wires": []
    },
    {
        "id": "f058ed39b81ee1c5",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "",
        "url": "/v1/s3hook/log",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 900,
        "y": 460,
        "wires": [
            [
                "70c321c215674dc8"
            ]
        ],
        "icon": "node-red/leveldb.svg"
    },
    {
        "id": "70c321c215674dc8",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "s3 logs",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 460,
        "wires": [
            [
                "e90275fd1d80699e"
            ]
        ]
    },
    {
        "id": "e90275fd1d80699e",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "g": "b5db9eb4f8a97ec0",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1260,
        "y": 460,
        "wires": []
    },
    {
        "id": "4d3a98c42477cca6",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1210,
        "y": 180,
        "wires": []
    },
    {
        "id": "d8be0870257285dd",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "test db connection",
        "func": "const { getSession } = global.get(\"data-service.js\");\ntry {\n        // GET SESSION & USER\n        // const { req } = msg;\n\n        const req = {};\n        req.headers = {};\n        req.headers.authorization = \"Bearer sx_58364de7a7b24a0283d6ad95443f4bf2400f17a8b1264c16835325095b0b5e75317a12f9846d426f85745652c85e\"\n        req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-PRD\";\n\n        const session = await getSession(req);\n\n        // PREPARE RESPONSE\n        if (session?.db) {\n                const result = await session.db.query(`SELECT table_name\nFROM information_schema.tables\nWHERE table_schema = 'public';`);\n                node.warn({ result });\n        } else {\n                msg.statusCode = 401;\n                msg.payload = { message: 'Session is expired. Please login to continue' };\n        }\n} catch (error) {\n        if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n                msg.statusCode = error.statusCode;\n                msg.payload = { message: error.message || 'Client error occurred' };\n        } else {\n                msg.statusCode = 500;\n                msg.payload = { message: 'Internal server error' };\n                node.error(error);\n        }\n}\nreturn msg;\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "2e4cee91be44662f",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "Test DB Connection",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 975,
        "y": 220,
        "wires": [
            [
                "d8be0870257285dd"
            ]
        ],
        "l": false
    },
    {
        "id": "9ef8f6de866a4816",
        "type": "comment",
        "z": "f3deaa9ef8948c89",
        "name": "Updates",
        "info": "Hàm getSession() sẽ trả vể Session Class và gọi sẵn:\n- getUser() // Lấy user info\n- getDb()   // lấy Database connection\n(data-service.js dòng 52-53);\n\n\nĐỔI TÊN các Class: (Cho dễ gọi)\n- s3Client -> ObjectConnection\n- dbClient -> DataConnection\n(xem repo.js)\n\nTHÊM CHỨC NĂNG: database connection cho mỗi Session \n(xem entity.js)\n\nappUID và Database name\nLIMS-IRDOP-DEV -> LIMS-DEV\nLIMS-IRDOP-PRD -> LIMS",
        "x": 920,
        "y": 80,
        "wires": []
    },
    {
        "id": "074bd4c2694edae1",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "test genFileUID",
        "func": "const { getSession } = global.get(\"data-service.js\");\ntry {\n        // GET SESSION & USER\n        // const { req } = msg;\n\n        const req = {};\n        req.headers = {};\n        req.headers.authorization = \"Bearer sx_58364de7a7b24a0283d6ad95443f4bf2400f17a8b1264c16835325095b0b5e75317a12f9846d426f85745652c85e\"\n        req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-PRD\";\n\n        const session = await getSession(req);\n\n        // PREPARE RESPONSE\n        if (session?.db) {\n                const result = await session.s3.genFileUID()\n                node.warn({ result });\n        } else {\n                msg.statusCode = 401;\n                msg.payload = { message: 'Session is expired. Please login to continue' };\n        }\n} catch (error) {\n        if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n                msg.statusCode = error.statusCode;\n                msg.payload = { message: error.message || 'Client error occurred' };\n        } else {\n                msg.statusCode = 500;\n                msg.payload = { message: 'Internal server error' };\n                node.error(error);\n        }\n}\nreturn msg;\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "4acf0f74ec0e3a50",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "genFileUID",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 975,
        "y": 260,
        "wires": [
            [
                "074bd4c2694edae1"
            ]
        ],
        "l": false
    },
    {
        "id": "2b520f5b9538e2c3",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "test bucketList",
        "func": "const { getSession } = global.get(\"data-service.js\");\ntry {\n        // GET SESSION & USER\n        // const { req } = msg;\n\n        const req = {};\n        req.headers = {};\n        req.headers.authorization = \"Bearer sx_58364de7a7b24a0283d6ad95443f4bf2400f17a8b1264c16835325095b0b5e75317a12f9846d426f85745652c85e\"\n        req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";\n\n        const session = await getSession(req);\n        node.warn({session});\n\n        // PREPARE RESPONSE\n        if (session?.s3) {\n                const result = await session.s3.listBuckets()\n                node.warn({ result });\n        } else {\n                msg.statusCode = 401;\n                msg.payload = { message: 'Session is expired. Please login to continue' };\n        }\n} catch (error) {\n        node.warn(error.stack);\n        if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n                msg.statusCode = error.statusCode;\n                msg.payload = { message: error.message || 'Client error occurred' };\n        } else {\n                msg.statusCode = 500;\n                msg.payload = { message: 'Internal server error' };\n                node.error(error);\n        }\n}\nreturn msg;\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 300,
        "wires": [
            []
        ]
    },
    {
        "id": "7755f4982ffaf2a3",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "Test DB Connection",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 975,
        "y": 300,
        "wires": [
            [
                "2b520f5b9538e2c3"
            ]
        ],
        "l": false
    },
    {
        "id": "bf234ff85f0c2f41",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "repo.js",
        "func": "const { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst { createCache, getCache }     = global.get('cache.js');\nconst { Client }                    = minio;\nconst { Pool }                      = pg;\nconst { v4: uuidv4 }                = uuid  // required('uuid');\n\nconst columnCache = createCache (\"ColumnCache\", 60*60*1000) || getCache(\"ColumnCache\");\n\nclass ObjectConnection extends Client {\n    #db;                // DataConnection instance ie. db.query()\n    #defaultBucket;     // Default bucket name\n    #session;           // Session instance\n\n    constructor(options, session) {\n        super(options);\n        this.#session       = session;\n        this.#db            = session.db;\n        this.#defaultBucket = options.bucket;\n        if (!this.#defaultBucket) throw new cError (400, `[ Error ] invalid minio client config for ${options?.endPoint}`)\n    }\n\n    get identityUID()   { return this.#session.identityUID;     }\n    get identityName()  { return this.#session.identityName;    }\n    get defaultBucket() { return this.#defaultBucket;           }\n\n\n    async getUpLink(fileInfo, objectName, expiry = 604800, reqParams, requestDate) { // Không thay đổi tên hàm đã quy định, cố gắng để params theo đúng như document gốc\n        const startTime=Date.now() \n        let isSuccess=true\n        try {\n            const url = await this.presignedUrl(\"PUT\", this.defaultBucket, objectName, expiry, reqParams, requestDate);\n            // TODO: Insert to presign table\n            const result = await this.insertPresignRecord({\n                objectName,\n                url,\n                expiry,\n                reqParams,\n                requestDate\n            })\n            return { url }      // return inserted record\n        } catch (error) {\n            isSuccess = false\n            handleError();      // sử dụng handle Error\n            return null;\n        } finally {\n            trackPerformance(\"ObjectConnection.getUpLink\", startTime, isSuccess);\n        }\n    }\n\n    async getDownLink(fileInfo, objectName, expiry = 604800, reqParams, requestDate) {\n        const startTime = Date.now()\n        let isSuccess = true\n        try {\n            const url = await this.presignedUrl(\"GET\", this.defaultBucket, objectName, expiry, reqParams, requestDate);\n            // TODO: Insert to presign table\n            const result = await this.insertPresignRecord({\n                objectName,\n                url,\n                expiry,\n                reqParams,\n                requestDate\n            })\n            return { url }      // return inserted record\n        } catch (error) {\n            isSuccess = false\n            handleError();      // sử dụng handle Error\n            return null;\n        } finally {\n            trackPerformance(\"ObjectConnection.getDownLink\", startTime, isSuccess);\n        }\n    }\n\n    async insertPresignRecord (options) {\n        try {\n            node.warn(\"in inssert right now\");\n            // TODO: Dùng await db.getColumnValues() Để lấy columns + values -> Insert query\n            // return { result?.rows[0], ... className: \"PresignRecord\" }\n        } catch (error) {\n            // TODO: handlerError\n        }\n    }\n\n    async onUploadComplete  (options) {\n        // TODO: Chuyển record từ bảng PresignedUrl sang bảng objectStorage\n    }\n    async onUploadFailure   (options) {\n        // TODO: Đánh dấu record failed\n    }\n\n    genFileUID() {    \n        // generateing file_25acd0e9b90298a using uuid v4\n        return `file_${(new Date().getFullYear()+'').slice(-2)}${uuidv4().replace(/-/g,'').slice(0,12)}`;    \n    }\n\n    // Tên quá dài\n    async getPresignedGet(objectName, expiry = 604800, reqParams, requestDate) {\n        try {\n            const url = await this.presignedUrl(\"GET\", this.#defaultBucket, objectName, expiry, reqParams, requestDate);\n            node.warn(`[s3Client] Generated presigned GET URL: ${url}`);\n            return url;\n        } catch (err) {\n            handleError('repo.getPresinged')\n            return null;\n        } finally {\n\n        }\n    }\n\n    async getPresignedPutUrl(objectName, expiry = 600, metaData = {}) {\n        node.warn(`[s3Client] Generating presigned PUT URL for bucket: ${this.#defaultBucket}, object: ${objectName}`);\n        try {\n            const url = await this.presignedPutObject(this.#defaultBucket, objectName, expiry, metaData);\n             node.warn(`[s3Client] Generated presigned PUT URL: ${url}`);\n            return url;\n        } catch (err) {\n            node.error(`[s3Client] Lỗi khi tạo Presigned PUT URL cho ${objectName}:`, err);\n            return null;\n        }\n    }\n}\n\n\nclass DataConnection extends Pool {\n    #config;\n    #session;\n    #Pool;\n\n    constructor(config, session) {\n        node.warn({config});\n        config.password = config.pw;\n        super(config);\n        this.#config = config;\n        this.#session = session;\n    }\n\n    get dbName ()           { return this.#config?.name             }\n    get identityUID ()      { return this.#session?.identityUID         }\n    get defaultBucket  ()   { return this.#session?.s3Bucket            }\n\n    async getColumnValues (tableName, data) {   // Khớp data elements với columns field. Trả vể { columns, values }\n        try {\n            // Retrieve columns from the database\n            const cacheKey      = `${this.dbName}:${tableName}`;\n            const cachedColumns = columnCache.get(cacheKey);\n            const allColumns    = cachedColumns || (await this.query (\n                `SELECT column_name FROM information_schema.columns WHERE table_name = $1`,\n                [tableName]\n            )).rows.map(row => row.column_name);\n\n            if (!cachedColumns) columnCache.set(cacheKey, allColumns);\n\n            // Filter data to match columns while maintain element's order\n            const columns = [];\n            const values = [];\n            for (const column of allColumns) {\n                if (data.hasOwnProperty(column)) {\n                    columns.push(column);\n                    values.push(data[column]);\n                }\n            }\n\n        return { columns, values };\n        } catch (error) {\n            handleError('file-access.getColumnValues', error, true);\n        }\n    }\n\n    async testConnection() {\n        node.warn(`[ DataConnection ] Testing connection to ${this.dbName} database`);\n        try             { return await this.query(`SELECT 1`) || false; } \n        catch (error)   { return false;                                 }\n    }\n}\n\n\nglobal.set('repo.js', {\n    ObjectConnection,\n    DataConnection\n});\n\nnode.status({ fill: 'green', shape: 'dot', text: 'OK' });\nreturn msg",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "minio",
                "module": "minio"
            },
            {
                "var": "pg",
                "module": "pg"
            },
            {
                "var": "uuid",
                "module": "uuid"
            }
        ],
        "x": 410,
        "y": 180,
        "wires": [
            [
                "35818376b74b9267"
            ]
        ]
    },
    {
        "id": "9a2fab9a4fe0699f",
        "type": "comment",
        "z": "7c3157bf68c1b848",
        "name": "",
        "info": "",
        "x": 1300,
        "y": 660,
        "wires": []
    },
    {
        "id": "62d20a13bc2bc538",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "function 19",
        "func": "const repo = global.get('repo.js');\nconst { getSession,\n    getUser,\n    getUserByInfo,\n    loginUser,\n    newUser} = global.get('data-service.js');\n\nconst { trackPerformance, cError, handleError } = global.get('utilities.js');\n\nif (!repo) {\n    node.status({ fill: 'red', shape: 'dot', text: 'repo.js not found in global context' });\n    node.error(\"repo.js not found in global context. Make sure the node defining it runs first.\");\n    return null;\n}\n\nconst { s3Client } = repo;\n\nconst minioOptions = {\n    \"endPoint\": \"s3.irdop.org\",\n    \"accessKey\": \"rNItZci16fmAVcb9HA2e\",\n    \"secretKey\": \"GD1hNEGOteycopeFIDWqPItFoULeJvGkX52LMBdt\",\n};\n\nconst session = {\n    identityUID: 'user-123',\n    identityName: 'Test User',\n    s3Bucket: 'irdop-dev',\n};\n\n(async function() {\n    let presignedGetUrl = null;\n    let presignedPutUrl = null;\n        node.warn(\"this is f18\")\n\n    node.warn(getSession(msg))\n    try {\n        const minioS3Client = new s3Client(minioOptions, session);\n        node.warn(\"[Usage] s3Client instance created.\");\n\n        const objectToPut = 'tmp/a.txt';\n        const expiryForPut = 600;\n        const uploadMetaData = {\n        };\n        // presignedPutUrl = await minioS3Client.getPresignedPutUrl(objectToPut, expiryForPut, uploadMetaData);\n        //  if (presignedPutUrl) {\n        //      node.log(`[Usage] Đã nhận Presigned URL PUT cho \"${objectToPut}\": ${presignedPutUrl}`);\n        //      msg.payload = {\n        //          action: 'upload',\n        //          objectName: objectToPut,\n        //          presignedPutUrl: presignedPutUrl\n        //      };\n        // } else {\n        //      throw new cError(500, 'Info is required');\n        // }\n\n        // msg.payload = msg.payload || {};\n\n        // if (presignedGetUrl) {\n        //     msg.payload.presignedGetUrl = presignedGetUrl;\n        // }\n        //  if (presignedPutUrl) {\n        //      msg.payload.presignedPutUrl = presignedPutUrl;\n        //      msg.payload.objectToPut = objectToPut;\n        //  }\n        return msg;\n    } catch (error) {\n        throw new cError(500, \"Error with presignUrl :\"+error);\n    }\n})();",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1190,
        "y": 860,
        "wires": [
            [
                "ee0e3927d3866b73"
            ]
        ]
    },
    {
        "id": "333f696bdb9f46df",
        "type": "comment",
        "z": "7c3157bf68c1b848",
        "name": "SQL SCHEMA",
        "info": "const { trackPerformance, cError, handleError } = global.get('utilities.js') || {\n    trackPerformance: (name, start, success) => { node.warn(`[PERF] ${name}: ${Date.now() - start}ms (Success: ${success})`); },\n    cError: class extends Error { constructor(code, message) { super(message); this.code = code; } },\n    handleError: (context, error, shouldThrow) => { node.error(`[ERROR] ${context}: ${error.message}`); if (shouldThrow) throw error; }\n};\n\nconst columnCache = global.get('cache.js')?.getCache(\"ColumnCache\") || new Map();\n\nconst repo = global.get('repo.js');\n\nif (!repo || !repo.ObjectConnection || !repo.DataConnection) {\n    node.error(\"Required classes (ObjectConnection, DataConnection) not found in global context. Ensure the setup node ('node_red_test_node') is deployed and runs successfully first.\");\n    node.status({ fill: 'red', shape: 'dot', text: 'Repo Classes Not Found' });\n    return null;\n}\n\nconst { ObjectConnection, DataConnection } = repo;\n\nconst minioConfig = {\n    endPoint: 'localhost',\n    port: 9000,\n    useSSL: false,\n    accessKey: 'YOUR_MINIO_ACCESS_KEY',\n    secretKey: 'YOUR_MINIO_SECRET_KEY',\n    bucket: 'your-default-bucket'\n};\n\nconst pgConfig = {\n    user: 'your_db_user',\n    host: 'localhost',\n    database: 'your_db_name',\n    pw: 'your_db_password',\n    port: 5432,\n    name: 'your_db_name'\n};\n\nconst mockSession = {\n    identityUID: \"mock-user-id\",\n    identityName: \"Test User\",\n    s3Bucket: minioConfig.bucket,\n    db: null\n};\n\nlet objectConnection = null;\nlet dataConnection = null;\n\ntry {\n    dataConnection = new DataConnection(pgConfig, mockSession);\n    mockSession.db = dataConnection;\n    objectConnection = new ObjectConnection(minioConfig, mockSession);\n\n    node.status({ fill: 'green', shape: 'dot', text: 'Ready' });\n\n} catch (initError) {\n    node.error(\"Failed to initialize connections using classes from global context:\", initError);\n    node.status({ fill: 'red', shape: 'dot', text: 'Init Failed' });\n}\n\nnode.on('input', async function(msg) {\n    if (!objectConnection || !dataConnection) {\n        node.error(\"Connections not initialized. Ensure the setup node ran successfully.\");\n        msg.payload = { error: \"Connections not initialized\" };\n        node.send(msg);\n        return;\n    }\n\n    const { topic, payload } = msg;\n\n    try {\n        let result = null;\n\n        switch (topic) {\n            case 'getPresignedPutUrl':\n                 if (payload && payload.objectName) {\n                      node.warn(`Testing getPresignedPutUrl for object: ${payload.objectName}`);\n                      result = await objectConnection.getPresignedPutUrl(payload.objectName, payload.expiry, payload.metaData);\n                 } else {\n                     throw new Error(\"Invalid payload for getPresignedPutUrl. Expected { objectName: '...', ... }\");\n                 }\n                 break;\n\n            default:\n                node.warn(`Only 'getPresignedPutUrl' topic is handled. Received unknown topic: ${topic}.`);\n                result = { status: `Only 'getPresignedPutUrl' topic is handled. Received unknown topic: ${topic}.` };\n        }\n\n        msg.payload = result;\n        node.send(msg);\n\n    } catch (error) {\n        node.error(`Error processing message with topic ${topic}:`, error);\n        msg.payload = { error: error.message };\n        node.send(msg);\n    }\n});\n",
        "x": 1340,
        "y": 720,
        "wires": []
    },
    {
        "id": "ee0e3927d3866b73",
        "type": "http response",
        "z": "7c3157bf68c1b848",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1330,
        "y": 860,
        "wires": []
    },
    {
        "id": "d0dd4c2c72b4524e",
        "type": "comment",
        "z": "7c3157bf68c1b848",
        "name": "Updates",
        "info": "Hàm getSession() sẽ trả vể Session Class và gọi sẵn:\n- getUser() // Lấy user info\n- getDb()   // lấy Database connection\n(data-service.js dòng 52-53);\n\n\nĐỔI TÊN các Class: (Cho dễ gọi)\n- s3Client -> ObjectConnection\n- dbClient -> DataConnection\n(xem repo.js)\n\nTHÊM CHỨC NĂNG: database connection cho mỗi Session \n(xem entity.js)\n",
        "x": 1320,
        "y": 760,
        "wires": []
    },
    {
        "id": "55c91307ac74c3f6",
        "type": "inject",
        "z": "7c3157bf68c1b848",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 105,
        "y": 420,
        "wires": [
            [
                "32af65a13a37e041"
            ]
        ],
        "l": false
    },
    {
        "id": "32af65a13a37e041",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "Print Performance Data",
        "func": "const { printPerformanceData } = global.get('utilities.js');\nprintPerformanceData();\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 420,
        "wires": [
            []
        ]
    },
    {
        "id": "81faf9b9c28f72be",
        "type": "http response",
        "z": "7c3157bf68c1b848",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 870,
        "y": 280,
        "wires": []
    },
    {
        "id": "899857d7c14e4269",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "test db connection",
        "func": "const { getSession } = global.get(\"data-service.js\");\ntry {\n        // GET SESSION & USER\n        // const { req } = msg;\n\n        const req = {};\n        req.headers = {};\n        req.headers.authorization = \"Bearer sx_58364de7a7b24a0283d6ad95443f4bf2400f17a8b1264c16835325095b0b5e75317a12f9846d426f85745652c85e\"\n        req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-PRD\";\n\n        const session = await getSession(req);\n\n        // PREPARE RESPONSE\n        if (session?.db) {\n                const result = await session.db.query(\n                        `SELECT tablename\n                        FROM pg_catalog.pg_tables\n                        WHERE schemaname = 'public';\n                        `\n                )\n                node.warn( {result} );\n        } else {\n                msg.statusCode = 401;\n                msg.payload = { message: 'Session is expired. Please login to continue' };\n        }\n} catch (error) {\n        if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n                msg.statusCode = error.statusCode;\n                msg.payload = { message: error.message || 'Client error occurred' };\n        } else {\n                msg.statusCode = 500;\n                msg.payload = { message: 'Internal server error' };\n                node.error(error);\n        }\n}\n\nreturn msg;\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "01d70e60f2c2e6b4",
        "type": "inject",
        "z": "7c3157bf68c1b848",
        "name": "Test DB Connection",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 655,
        "y": 400,
        "wires": [
            [
                "899857d7c14e4269"
            ]
        ],
        "l": false
    },
    {
        "id": "c21f7d1f6aac7234",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "test genFileUID",
        "func": "const { getSession } = global.get(\"data-service.js\");\ntry {\n        // GET SESSION & USER\n        // const { req } = msg;\n\n        const req = {};\n        req.headers = {};\n        req.headers.authorization = \"Bearer sx_58364de7a7b24a0283d6ad95443f4bf2400f17a8b1264c16835325095b0b5e75317a12f9846d426f85745652c85e\"\n        req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-PRD\";\n\n        const session = await getSession(req);\n\n        // PREPARE RESPONSE\n        if (session?.db) {\n                const result = await session.s3.genFileUID()\n                node.warn({ result });\n        } else {\n                msg.statusCode = 401;\n                msg.payload = { message: 'Session is expired. Please login to continue' };\n        }\n} catch (error) {\n        if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n                msg.statusCode = error.statusCode;\n                msg.payload = { message: error.message || 'Client error occurred' };\n        } else {\n                msg.statusCode = 500;\n                msg.payload = { message: 'Internal server error' };\n                node.error(error);\n        }\n}\nreturn msg;\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "7c36aba87e6023c2",
        "type": "inject",
        "z": "7c3157bf68c1b848",
        "name": "genFileUID",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 655,
        "y": 440,
        "wires": [
            [
                "c21f7d1f6aac7234"
            ]
        ],
        "l": false
    },
    {
        "id": "681384c558da21f3",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "test bucketList",
        "func": "const { getSession } = global.get(\"data-service.js\");\ntry {\n        // GET SESSION & USER\n        // const { req } = msg;\n\n        const req = {};\n        req.headers = {};\n        req.headers.authorization = \"Bearer sx_58364de7a7b24a0283d6ad95443f4bf2400f17a8b1264c16835325095b0b5e75317a12f9846d426f85745652c85e\"\n        req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";\n\n        const session = await getSession(req);\n        node.warn({session});\n\n        // PREPARE RESPONSE\n        if (session?.s3) {\n                const result = await session.s3.listBuckets()\n                node.warn({ result });\n\n                \n                const requestDate = new Date(Date.now());\n                const test = await session.s3.presignedUrl(\"PUT\", \"irdop\", \"test.pdf\", 300, \"\", requestDate);\n                node.warn({ test });\n        } else {\n                msg.statusCode = 401;\n                msg.payload = { message: 'Session is expired. Please login to continue' };\n        }\n} catch (error) {\n        node.warn(error.stack);\n        if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n                msg.statusCode = error.statusCode;\n                msg.payload = { message: error.message || 'Client error occurred' };\n        } else {\n                msg.statusCode = 500;\n                msg.payload = { message: 'Internal server error' };\n                node.error(error);\n        }\n}\nreturn msg;\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "37efd865b3192621",
        "type": "inject",
        "z": "7c3157bf68c1b848",
        "name": "Test DB Connection",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 655,
        "y": 480,
        "wires": [
            [
                "681384c558da21f3"
            ]
        ],
        "l": false
    },
    {
        "id": "60a7efdd2392105b",
        "type": "inject",
        "z": "7c3157bf68c1b848",
        "name": "START",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "0.001",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 370,
        "y": 500,
        "wires": [
            [
                "9f87f39705146579"
            ]
        ]
    },
    {
        "id": "953c8243745c5841",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "entity.js",
        "func": "node.status({ fill: 'yellow', shape: 'dot', text: '...' });\nconst { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst dataService = global.get('data-service.js');\nconst { createCache, CacheWorld } = global.get('cache.js');\nconst { ObjectConnection, DataConnection } = global.get('repo.js');\n\nclass Session {\n    #headers = {};\n    #info = {};\n    #discovery = {};\n    s3 = {};   // ObjectStore client\n    db = {};   // Database client\n\n    constructor(info, headers) {\n        if (!info) throw new cError(500, 'Session Info is required');\n        this.className = this.constructor.name;\n        this.#info = { ...info, className: this.className };\n        this.#headers = headers;\n\n        // S3 Client cho Session entity\n        const s3Options = env.get('s3Config')[this.appUID];         // s3 config theo appUID \n        this.s3 = new ObjectConnection(s3Options, this);         // Lưu client vào session\n        node.warn({ s3: this.s3 });\n    }\n\n    // Identity\n    get info() { return this.#info }\n    get identityUID() { return this.#info.identityUID; }\n    get user() { return this.#discovery?.User; }\n    get email() { return this.#discovery?.User?.email; }\n    get identityName() { return this.#discovery?.User?.identityName; }\n    get role() { return this.#info.role; }\n\n    // Auth & access\n    get token() { return this.sessionUID; }\n    get sessionUID() { return this.#info.sessionUID; }\n    get headers() { return this.#headers; }\n    get appUID() { return this.#info.appUID; }\n    set headers(headers) { this.#headers = headers; }\n\n    // Repo\n    get accessKey() { return this.#info.accessKey; }\n\n    async getUser() {       // Lấy userInfo của session này\n        try {\n            const user = await dataService.getUser(this);\n            if (user) this.#discovery['User'] = user;\n            return user;\n        } catch (error) { return null; }\n    }\n\n    async getDb() {         // Establish database connection\n        const startTime = Date.now();     // Track Performance\n        let isSuccess = true;           // Track Performance\n        try {\n            const dbConfig = env.get('dbConfig')[this.appUID];\n            this.db = new DataConnection(dbConfig, this);\n            await this.db.connect();\n            return this.db;\n        } catch (error) {\n            isSuccess = false;\n            handleError(error, 'repo.js.Session.getDB()');\n        } finally {\n            trackPerformance(\"repo.js.Session.getDB()\", startTime, isSuccess);\n        }\n    }\n\n    serialize() {           // toJSON \n        return {\n            ...this.info,\n            ...Object.fromEntries(\n                Object.entries(this.#discovery).map(([key, value]) => [\n                    key,\n                    value && typeof value.serialize === 'function' ? value.serialize() : value,\n                ]),\n            ),\n            className: this.className,\n        };\n    }\n}\n\nclass Entity {\n    #discovery = {};\n    #info = {};\n    #session = {};\n\n    constructor(info, session) {\n        if (!info) throw new cError(500, 'Info is required');\n        this.#info = info;\n        this.#session = session;\n    }\n\n    get session() { return this.#session; }\n    get info() { return { ...this.#info, className: this.className }; }\n    get discovery() { return this.#discovery; } // Info mở rộng lưu vào #discovery\n\n    newDiscovery(discovery = {}) {\n        if (discovery) {\n            Object.entries(discovery).forEach(([key, value]) => {\n                if (value && typeof value === 'object' && !Array.isArray(value)) {\n                    this.#discovery[key] = value;\n                } else {\n                    this.#discovery[key] = value;\n                }\n            });\n        }\n    }\n\n    // Info mở rộng lưu vào #discovery\n    serialize() {       // convert object gồm cả info đã mở rộng từ newDiscovery\n        return {\n            ...this.info,\n            ...Object.fromEntries(\n                Object.entries(this.#discovery).map(([key, value]) => [\n                    key,\n                    value && typeof value.serialize === 'function' ? value.serialize() : value,\n                ])\n            ),\n        };\n    }\n\n    // PERMISSION\n    getPermissionFor(action) {\n\n    }\n\n    addLog(logType, logTime, logForEntity, fnName, data) {\n        const options = {\n            logType: logType || '',           // event/scheduled | auto/manual |\n            logObject: logForEntity || '',           // Sử dụng thiết bị, theo dõi môi trường, nhật ký hệ thống, nhật ký thử nghiệm, nhật ký người dùng, nhật ký mẫu,\n            logNotion: '',                           // error, warning, info\n            timestamp: logTime || Date.now(),\n            systemLog: {\n                entity: this.className,\n                fnName: fnName || '',\n                timestamp: Date.now(),\n                sessionUID: this.session.sessionUID,\n                appUID: this.session.appUID,\n                accessKey: this.session.accessKey,\n                identityUID: this.session.identityUID,\n            },\n            description: data.description || '',\n        };\n\n        const doneBy = `thực hiện bởi ${this.session.identityName || this.session.identityUID}`;\n    }     // TODO\n    addAudit(actionType, timestamp, fnName, description) { }   // TODO\n}\n\nclass User extends Entity {\n    constructor(info, session) {\n        super(info, session);\n\n        // Tạo getter từ info object\n        Object.keys(info).forEach(key => {\n            if (key !== 'className') {\n                Object.defineProperty(this, key, {\n                    get: () => this.info[key],\n                    enumerable: true,\n                    configurable: true,\n                });\n            }\n        });\n        this.className = 'User';\n    }\n\n    get relation() { return this.discovery?.relations; }\n\n    async editInfo(newInfo) {\n        if (newInfo) {\n            // query/ post / access\n        }\n        return new User(this.info, this.session);\n    }\n\n    async newRelation(relation) {\n        if (relation?.appUID) {\n            // query/ post / access return {}\n            this.newDiscovery({ relations: await this.getRelation() });\n        }\n        // relations = [\n        //     {\n        //         appUID: 'LIMS-IRDOP-DEV',\n        //         disabled: false,\n        //         staff: true,\n        //         staff_technician: true,\n        //     }, {\n        //         appUID: 'LIMS-IRDOP-DEV',\n        //         disabled: false,\n        //         staff: true,\n        //         staff_technician: true,\n        //     },\n        // ]\n    }\n\n    async getRelationList() { }\n\n    async getRelation(appUID) { }\n\n    // CHECK Permission\n    canEdit() {\n    }\n}\n\n// TODO CLASS: Analysis, Sample, Receipt\n// TODO CLASS: File (with fileInfo {...})6\n// TODO CLASS: Log      (actionType on any entity) \n// TODO CLASS: Audit    (actionType on any entity)\n\nglobal.set('entity.js', { Session, User });\nnode.status({ fill: 'green', shape: 'dot', text: 'OK' });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 620,
        "wires": [
            [
                "11e509928b14c56d",
                "4d5d788611c88d5b"
            ]
        ]
    },
    {
        "id": "11e509928b14c56d",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "data-service",
        "func": "node.status({ fill: 'yellow', shape: 'dot', text: '...' });\nconst { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst { convertCamelCase, convertSnakeCase } = global.get('utilities.js');\nconst { Session, User } = global.get('entity.js');\nconst { createCache } = global.get('cache.js');\nconst axios = global.get('axios');\nconst { Pool } = pg;\n\n// DECLARE CACHES\nconst sessionCache = createCache('Session', 120 * 60 * 1000);        // 2 hour\nconst userCache = createCache('User', 60 * 60 * 1000);        // 1 hour\nconst analysisCache = createCache('Analysis', 60 * 60 * 1000);        // 1 hour\nconst sampleCache = createCache('Sample', 60 * 60 * 1000);        // 1 hour\nconst receiptCache = createCache('Receipt', 60 * 60 * 1000);        // 1 hour\n\n// SESSION & USER main functions\nasync function getSession(req) {\n    // Validate và lấy ra appUID + sessionUID + accessKey(nếu có)\n    const { headers } = req;\n    let appUID = headers?.['x-fh-app-uid'];\n    if (!appUID) throw new cError(400, \"Please provide appUID\")\n    if (!headers?.['authorization']) throw new cError(401, \"Please login to continue\")\n    const sessionUID = headers?.['authorization'].split(' ')[1] || headers?.['Authorization'].split(' ')[1];\n    const accessKey = headers?.['x-fh-access-key'] || env.get('s3Config')[appUID];    // USER or SERVER KEY\n\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `Session:${sessionUID}`;      // Định danh cache\n        let cachedSession = sessionCache.get(cacheKey);   // Tìm cache\n        if (cachedSession) {\n            node.warn(`Cached session found: ${cacheKey}`);\n            return cachedSession;           // Trả về cache (nếu có)\n        }\n\n        // CONSTRUCT SESSION CLASS\n        const endpoint = \"https://pink.irdop.org/ab4dg2/auth/me\";\n        const headers = {\n            \"Content-Type\": `application/json`,\n            \"Authorization\": `Bearer ${sessionUID}`,   // từ user request\n            \"x-fh-app-uid\": appUID,                   // từ user request\n            \"x-fh-access-key\": accessKey,                // từ user request hoặc server setting\n        };\n\n        // GET SESSION INFO\n        const response = await axios.post(endpoint, {}, { headers });\n        const sessionInfo = convertCamelCase(response?.data);\n\n        if (!sessionInfo) throw new cError(401, 'Please login to continue');\n\n        // CONSTRUCT SESSION\n        const session = new Session(sessionInfo, headers);\n        await session.getUser();    // Preload user info\n        await session.getDb()       // Preload Database connection\n\n        // SET CACHE & RETURN\n        return sessionCache.set(cacheKey, session);\n    } catch (error) {\n        handleError(error, 'data-service.js.getSession');\n        throw error;\n    } finally {\n        trackPerformance('data-service.js.getSession', startTime);\n    }\n}\nasync function loginUser(req) {\n    const { body, headers } = req;\n    const { email, password } = body;\n    const startTime = Date.now();\n    try {\n        const appUID = headers?.['x-fh-app-uid'];\n        if (!email) throw new cError(400, \"Please provide email\");\n        if (!password) throw new cError(400, \"Please provide password\");\n        if (!appUID) throw new cError(400, \"No application is provided for your login session\");\n\n        node.warn(123123);\n        // GET SESSION\n        const response = await axios.post('https://pink.irdop.org/gre134e/auth/login', { email, password }, {\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'x-fh-app-uid': appUID\n            }\n        });\n\n        // RESPONSE\n        const sessionInfo = convertCamelCase(response?.data);\n        if (!sessionInfo) throw new cError(401, 'Failed to validate your credentials');\n\n        // CREATE SESSION ENTITY\n        const session = new Session(sessionInfo, headers);\n        await session.getUser();    // Preload user info\n        await session.getDb();      // Preload Database Pool\n        const cacheKey = `Session:${session.token}`;\n        sessionCache.set(cacheKey, session);\n        return session;\n    } catch (error) {\n        handleError(error, `data-service.js.loginUser [${email}]`);\n        throw error;\n    } finally {\n        trackPerformance(`data-service.js.loginUser [${email}]`, startTime, true);\n    }\n}\nasync function getUser(session) {\n    // Validate và lấy ra identityUID + email\n    if (typeof session !== 'object') throw new cError(400, 'session input must be an object');\n    const { identityUID, email } = session;\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `User:${identityUID}`;    // Định danh cache\n        const userInfo = userCache.get(cacheKey) ? userCache.get(cacheKey) : async () => {\n            // GET USER INFO\n            const endpoint = \"https://pink.irdop.org/ab4dg2/get/iden\";\n            const body = { identity_uid: identityUID, email: email };\n            const headers = session.headers;\n            const response = await axios.post(endpoint, body, { headers });\n            const userInfo = convertCamelCase(response?.data);         // convert to camelCase format\n            if (!userInfo) throw new cError(404, 'User not found');\n\n            // Set cache & return\n            return userCache.set(cacheKey, userInfo);\n        }\n\n        // CREATE USER ENTITY\n        const user = new User(userInfo, session);\n        return user;\n    } catch (error) {\n        node.warn({ error });\n        handleError(error, 'data-service.js.getUser');\n        throw error;\n    } finally {\n        trackPerformance('data-service.js.getUser', startTime, true);\n    }\n}\nasync function getUserByInfo(identity, session) {\n    const startTime = Date.now();\n    try {\n        const { identityUID, email } = identity;\n        if (!identityUID && !email) throw new cError(400, \"Please provide identityUID or email\");\n\n        // TRY CACHE\n        const cacheKey = `User:${identityUID || email}`;   // Định danh cache\n        const cachedUser = userCache.get(cacheKey);          // Tìm cache\n        if (cachedUser) return cachedUser;                  // Trả về cache nếu có\n\n        // SEND REQUEST\n        const endpoint = \"https://pink.irdop.org/ab4dg2/get/iden\";\n        const body = { identity_uid: identityUID, email };\n        const headers = { ...session.headers };\n        const response = await axios.post(endpoint, body, { headers });\n\n        // CONVERT TO CAMEL CASE\n        const userInfo = convertCamelCase(response?.data);\n        if (!userInfo) throw new cError(404, 'User not found');\n\n        // RETURN USER ENTITY & CACHE\n        const user = new User(userInfo, session);\n        userCache.set(cacheKey, user);\n        return user;\n    } catch (error) {\n        handleError(error, 'data-service.js.getUser');\n        throw error;\n    } finally {\n        trackPerformance('getUser', startTime, true);\n    }\n\n}\nasync function newUser(req, session) {\n    const { identityName, email } = req?.body;\n    // Với user phải có identityName và email (Bot/Server thì không cần)\n    if (!identityName) throw new cError(400, \"Please provide identity name\");\n    if (!email) throw new cError(400, \"Please provide email\");\n\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `User:${identityName}:${email}`;    // Định danh cache\n        const cachedUser = userCache.get(cacheKey);   // Tìm cache\n        if (cachedUser) throw new cError(400, 'User already exists'); // User đã tồn tại\n\n        // PREPARE RELATIONS\n        const { relations } = req.body;     // Lấy relations từ POST request\n        if (Array.isArray(relations) && relations.length > 0) {\n            // Format relations to match the API\n            relations.forEach(relation => {\n                return {\n                    relation_name: session.appUID, // gán appUID cho relation_name\n                    ...relation\n                };\n            });\n        }\n\n        // POST NEW USER\n        const newUser = await axios.post('https://pink.irdop.org/ab4dg2/insert/iden', {\n            identity_name: identityName,                // Bắt buộc\n            email: email,                               // Bắt buộc\n            password: req.body.password,\n            identity_contact: req.body.identityContact || {},\n            telegram_peer: req.body.telegramPeer || {},\n            zalo_user_id: req.body.zaloUserId || \"\",\n            relations: relations || [],\n        }, {\n            headers: {\n                ...session.headers,            // session built-in headers\n            }\n        });\n\n        const userInfo = convertCamelCase(newUser?.data);\n        // Failed to create user\n        if (!userInfo) throw new cError(400, 'Failed to create a new user');\n\n        // CREATE USER ENTITY\n        const user = new User(userInfo, session);\n        userCache.set(cacheKey, user);   // Cache user\n        return user;\n    } catch (error) {\n        handleError(error, 'newUser');\n        throw error;\n    } finally {\n        trackPerformance(`newUser [${identityName} - ${email}]`, startTime, true);\n    }\n}\n\n// SAMPLE & ANALYSIS\n\n// TODO: GET analysis, sample, receipt\n// TODO: GET fileUpLink, fileInfo, fileDownLink\n\nglobal.set('data-service.js', {\n    getSession,\n    getUser,\n    getUserByInfo,\n    loginUser,\n    newUser,\n})\nnode.status({ fill: 'green', shape: 'dot', text: 'OK' });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "pg",
                "module": "pg"
            }
        ],
        "x": 1310,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "9f87f39705146579",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "cache",
        "func": "node.status({fill: 'yellow', shape: 'dot', text: '...'});\n\nconst CacheWorld = {}; // global.get('CacheWorld') || {}; <--- dòng code comment này làm leak context giữa các deploy (??)\nglobal.set('CacheWorld', CacheWorld);\n\n\nfunction createCache(cacheName, ttl = 6 * 60 * 1000) {\n    // Validate inputs\n    if (CacheWorld[cacheName]) {\n        node.warn(`[ CAUTION ] Cache name \"${cacheName}\" already exists. Use a different name if intended.`);\n        return CacheWorld[cacheName];\n    }\n    if (typeof ttl !== 'number' || ttl < 0) {\n        throw new Error('Invalid TTL value. It must be a positive number.');\n    }\n    if (!cacheName || typeof cacheName !== 'string') {\n        throw new Error('Cache name is required and must be a string.');\n    }\n\n    const store = new Map();\n    const cache = {\n        ttl,\n        get(key) {\n            const entry = store.get(key);\n            if (!entry) return null;\n            if (this.ttl > 0 && Date.now() - entry.timestamp > this.ttl) {\n                node.warn(`Cache entry \"${key}\" has expired. Cleaning up...`);\n                store.delete(key);\n                return null;\n            }\n            return entry.value;\n        },\n        set(key, value) {\n            store.set(key, { value, timestamp: Date.now() });\n            return value;\n        },\n        has(key) {\n            return store.has(key);\n        },\n        size() {\n            return store.size;\n        },\n        keys() {\n            return Array.from(store.keys());\n        },\n        delete(key) {\n            const entry = store.get(key);\n            if (!entry) return false;\n            if (entry.value && typeof entry.value.clear === 'function') {\n                entry.value.clear();\n            }\n            store.delete(key);\n            return true;\n        },\n        clear() {\n            for (const [, entry] of store) {\n                if (entry.value && typeof entry.value.clear === 'function') {\n                    entry.value.clear();\n                }\n            }\n            store.clear();\n            return true;\n        },\n        getAll() {\n            return Object.fromEntries(Array.from(store, ([key, entry]) => [key, entry.value]));\n        },\n        entries() {\n            return Array.from(store.entries());\n        },\n    };\n\n    CacheWorld[cacheName] = cache;\n    return cache;\n}\n\nfunction getCache(cacheName) {\n    return CacheWorld?.[cacheName];\n}\n\n// CACHE CLEANER\nconst cleaner = setInterval(() => {\n    let totalCleaned = 0;\n    let memoryCleaned = 0;\n    let nameCleaned = [];\n\n    for (const cacheName in CacheWorld) {\n        const cache = CacheWorld[cacheName];\n        if (!cache || cache.size() === 0) continue;\n\n        for (const [key, entry] of cache.entries()) {\n            try {\n                const cacheTTL = cache.ttl || 0;\n                if (cacheTTL > 0 && entry.timestamp + cacheTTL < Date.now()) {\n                    // Clean nested caches if they exist\n                    if (entry.value && typeof entry.value.clear === 'function') {\n                        entry.value.clear();\n                    }\n\n                    // Estimate memory cleaned (rough approximation)\n                    memoryCleaned += JSON.stringify(entry.value).length || 0;\n\n                    // Delete expired entry\n                    cache.delete(key);\n                    totalCleaned++;\n                    nameCleaned.push(key);\n                }\n            } catch (error) {\n                node.error(`Error cleaning cache entry: ${key} in ${cacheName}`, error);\n            }\n        }\n\n        // Remove empty caches from CacheWorld\n        if (cache.size() === 0) {\n            delete CacheWorld[cacheName];\n        }\n    }\n\n    if (totalCleaned > 0) {\n        node.warn(`Cache cleaner removed ${totalCleaned} entries from ${Object.keys(CacheWorld).length} caches. Memory cleaned: ${memoryCleaned} bytes. Cache names: ${nameCleaned.join(', ')}`);\n    }\n}, 5 * 60 * 1000); // every 5 minutes\n\n\nglobal.set('cache.js', {\n    createCache,\n    getCache,\n    CacheWorld,\n});\n\nnode.warn('Cache cleaner is scheduled');\nnode.status({fill: 'green', shape: 'dot', text: 'OK'});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 540,
        "wires": [
            [
                "b42f210e0a7ac078"
            ]
        ]
    },
    {
        "id": "b42f210e0a7ac078",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "utilities",
        "func": "node.status({fill: 'yellow', shape: 'dot', text: '...'});\nconst { createCache } = global.get('cache.js');\nconst performanceData = createCache('performanceData', 0); // No expiration\nconst axios = global.get('axios');\n\nclass cError extends Error {\n    constructor(statusCode, properties, rethrow = true) {\n        if (typeof properties === 'string') {\n            properties = { message: properties, statusCode, rethrow };\n        }\n        else if (typeof properties === 'object') {\n            properties = {\n                message: properties.message || 'An error occurred',\n                statusCode: properties.statusCode || properties.code || 500,\n                rethrow: rethrow || properties.rethrow || false,\n            };\n        }\n        else {\n            properties = { message: 'An error occurred', statusCode, rethrow };\n        }\n        super(properties.message);\n\n        // Capture the stack trace\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, cError);\n        }\n        this.statusCode = statusCode || 500;\n        this.catchCount = 0;\n    }\n}\n\nfunction handleError(error, functionName, rethrow = false) {\n    if (error.catchCount++ === 0) {\n        node.warn(`${error.message} (caused at ${functionName})\\n${error.stack}`);\n    }\n    return error;\n}\n\nfunction trackPerformance(functionName, startTime, isSuccess = true) {\n    const elapsedTime = Date.now() - startTime;\n    const currentData = performanceData.get(functionName) || { count: 0, totalTime: 0, successCount: 0, errorCount: 0 };\n    currentData.count += 1;\n    currentData.totalTime += elapsedTime;\n    if (isSuccess) {\n        currentData.successCount += 1;\n    } else {\n        currentData.errorCount += 1;\n    }\n    performanceData.set(functionName, currentData);\n    return currentData;\n}\n\nfunction printPerformanceData() {\n    const data = performanceData.getAll();\n    let message = 'Performance Data:\\n';\n    let messageList = [];\n    for (const [functionName, { count, totalTime, successCount, errorCount }] of Object.entries(data)) {\n        const averageTime = totalTime / count;\n        messageList.push(`Function: ${functionName}, Calls: ${count}, Total Time: ${totalTime}ms, Average Time: ${averageTime.toFixed(2)}ms, Success: ${successCount}, Errors: ${errorCount}\\n`);\n    }\n    if (messageList.length > 0)\n        message += messageList.join('');\n    else\n        message += 'No data.';\n    node.warn(message);\n}\n\nasync function testPoolConnection(pool) {\n    try {\n        await pool.query('SELECT 1');\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function getColumnValues(tableName, pool, data) {\n    try {\n        const result = await pool.query(\n            `SELECT column_name FROM information_schema.columns WHERE table_name = $1`,\n            [tableName]\n        );\n        const allColumns = result.rows.map(row => row.column_name);\n\n        const columns = [];\n        const values = [];\n        for (const column of allColumns) {\n            if (data.hasOwnProperty(column)) {\n                columns.push(column);\n                values.push(data[column]);\n            }\n        }\n\n        return { columns, values };\n    } catch (error) {\n        handleError('file-access.getColumnValues', error, true);\n    }\n}\n\nfunction convertSnakeCase(input) {\n    // if (typeof input === 'string') {\n    //     // Check if the string is already in snake_case\n    //     if (!/[A-Z]/.test(input)) {\n    //         return input; // Return as-is if no uppercase letters are found\n    //     }\n    //     // Convert camelCase string to snake_case\n    //     return input.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()\n    //         .replace(/(?<![a-z])UID(?![a-z])/g, '_uid'); // Special case for UID, ensuring it's not part of a larger word\n    // } else \n    if (typeof input === 'object' && input !== null) {\n        if (Array.isArray(input)) {\n            // If it's an array, recursively process each element\n            return input.map(item => convertSnakeCase(item));\n        } else {\n            // If it's an object, process each key and value\n            return Object.keys(input).reduce((acc, key) => {\n                const snakeKey = key.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()\n                    .replace(/(?<![a-z])UID(?![a-z])/g, '_uid'); // Special case for UID, ensuring it's not part of a larger word\n                acc[snakeKey] = convertSnakeCase(input[key]);\n                return acc;\n            }, {});\n        }\n    }\n    // Return other data types as-is\n    return input;\n}\n\nfunction convertCamelCase(input) {\n    // if (typeof input === 'string') {\n    //     // Handle special case for _uid first\n    //     input = input.replace(/_uid/g, 'UID');\n\n    //     // Check if the string is already in camelCase\n    //     if (!/_/.test(input) || input.length > 3 && input?.slice(0,3) === 'sx_') {\n    //         return input; // Return as-is if no underscores are found\n    //     }\n\n    //     // Convert snake_case string to camelCase\n    //     return input.replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n    // } else \n    if (typeof input === 'object' && input !== null) {\n        if (Array.isArray(input)) {\n            // If it's an array, recursively process each element\n            return input.map(item => convertCamelCase(item));\n        } else {\n            // If it's an object, process each key and value\n            return Object.keys(input).reduce((acc, key) => {\n                const camelKey = key.replace(/_uid/g, 'UID')\n                    .replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n                acc[camelKey] = convertCamelCase(input[key]);\n                return acc;\n            }, {});\n        }\n    }\n    // Return other data types as-is\n    return input;\n}\n\nglobal.set('utilities.js', {\n    handleError,\n    trackPerformance,\n    printPerformanceData,\n    cError,\n    testPoolConnection,\n    getColumnValues,\n    convertSnakeCase,\n    convertCamelCase\n});\n\nnode.status({fill: 'green', shape: 'dot', text: 'OK'});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 580,
        "wires": [
            [
                "c17d5fe3d4f22ac8"
            ]
        ]
    },
    {
        "id": "3c44d6ac587aae73",
        "type": "inject",
        "z": "7c3157bf68c1b848",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 595,
        "y": 620,
        "wires": [
            [
                "c17d5fe3d4f22ac8"
            ]
        ],
        "l": false
    },
    {
        "id": "4d5d788611c88d5b",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "document.js",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "c17d5fe3d4f22ac8",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "repo.js",
        "func": "const { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst { createCache, getCache }     = global.get('cache.js');\nconst { Client }                    = minio;\nconst { Pool }                      = pg;\nconst { v4: uuidv4 }                = uuid  // required('uuid');\n\nconst columnCache = createCache (\"ColumnCache\", 60*60*1000) || getCache(\"ColumnCache\");\n\nclass ObjectConnection extends Client {\n    #db;                // DataConnection instance ie. db.query()\n    #defaultBucket;     // Default bucket name\n    #session;           // Session instance\n\n    constructor(options, session) {\n        super(options);\n        this.#session       = session;\n        this.#db            = session.db;\n        this.#defaultBucket = options.bucket;\n        if (!this.#defaultBucket) throw new cError (400, `[ Error ] invalid minio client config for ${options?.endPoint}`)\n    }\n\n    get identityUID()   { return this.#session.identityUID;     }\n    get identityName()  { return this.#session.identityName;    }\n    get defaultBucket() { return this.#defaultBucket;           }\n\n\n    async getUpLink(fileInfo, objectName, expiry = 604800, reqParams, requestDate) { // Không thay đổi tên hàm đã quy định, cố gắng để params theo đúng như document gốc\n        const startTime=Date.now() \n        let isSuccess=true\n        try {\n            const url = await this.#session.s3.presignedUrl(\"PUT\", this.#defaultBucket, objectName, expiry, reqParams, requestDate);\n            // TODO: Insert to presign table\n            const result = await this.insertPresignRecord({\n                objectName,\n                url,\n                expiry,\n                reqParams,\n                requestDate\n            })\n            return { url }      // return inserted record\n        } catch (error) {\n            isSuccess = false\n            handleError(\"ObjectConnection.GetUpLink\",error);      // sử dụng handle Error\n            node.warn(error)\n            return null;\n        } finally {\n            trackPerformance(\"ObjectConnection.getUpLink\", startTime, isSuccess);\n        }\n    }\n\n    async getDownLink(fileInfo, objectName, expiry = 604800, reqParams, requestDate) {\n        const startTime = Date.now()\n        let isSuccess = true\n        try {\n            const url = await this.#session.s3.presignedUrl(\"GET\",this.#defaultBucket , objectName, expiry, reqParams, requestDate);\n           // TODO: Insert to presign table\n            const result = await this.insertPresignRecord({\n                objectName,\n                url,\n                expiry,\n                reqParams,\n                requestDate\n            })\n\n            node.warn(url);\n            return { url }      // return inserted record\n        } catch (error) {\n            isSuccess = false\n            node.warn(error);\n            handleError(error);      // sử dụng handle Error\n            return null;\n        } finally {\n            trackPerformance(\"ObjectConnection.getDownLink\", startTime, isSuccess);\n        }\n    }\n\n    async insertPresignRecord (options) {\n        try {\n            // TODO: Dùng await db.getColumnValues() Để lấy columns + values -> Insert query\n        //   const result=  await this.#session.db.getColumnValues(\"S3PresignedUrl\",options.data)\n           //node.warn(result)\n             //return { result?.rows[0], ... className: \"PresignRecord\" }\n        } catch (error) {\n            // TODO: handlerError\n        }\n    }\n\n    async onUploadComplete  (options) {\n        // TODO: Chuyển record từ bảng PresignedUrl sang bảng objectStorage\n    }\n    async onUploadFailure   (options) {\n        // TODO: Đánh dấu record failed\n    }\n\n    genFileUID() {    \n        // generateing file_25acd0e9b90298a using uuid v4\n        return `file_${(new Date().getFullYear()+'').slice(-2)}${uuidv4().replace(/-/g,'').slice(0,12)}`;    \n    }\n\n    // Tên quá dài\n    async getPresignedGet(objectName, expiry = 604800, reqParams, requestDate) {\n        try {\n            const url = await this.presignedUrl(\"GET\", this.#defaultBucket, objectName, expiry, reqParams, requestDate);\n            node.warn(`[s3Client] Generated presigned GET URL: ${url}`);\n            return url;\n        } catch (err) {\n            handleError('repo.getPresinged')\n            return null;\n        } finally {\n\n        }\n    }\n\n    async getPresignedPutUrl(objectName, expiry = 600, metaData = {}) {\n        node.warn(`[s3Client] Generating presigned PUT URL for bucket: ${this.#defaultBucket}, object: ${objectName}`);\n        try {\n            const url = await this.presignedPutObject(this.#defaultBucket, objectName, expiry, metaData);\n             node.warn(`[s3Client] Generated presigned PUT URL: ${url}`);\n            return url;\n        } catch (err) {\n            node.error(`[s3Client] Lỗi khi tạo Presigned PUT URL cho ${objectName}:`, err);\n            return null;\n        }\n    }\n}\n\nclass DataConnection extends Pool {\n\n    #config;\n\n    #session;\n\n    #Pool;\n\n\n\n    constructor(config, session) {\n\n        config.password = config.pw;\n\n        super(config);\n\n        this.#config = config;\n\n        this.#session = session;\n\n    }\n\n\n\n    get dbName () { return this.#config?.name }\n\n    get identityUID () { return this.#session?.identityUID }\n\n    get defaultBucket () { return this.#session?.s3Bucket }\n\n\n    async getColumnValues (tableName, data) {   // Khớp data elements với columns field. Trả vể { columns, values }\n        try {\n            const cacheKey      = `${this.dbName}:${tableName}`;\n            const cachedColumns = columnCache.get(cacheKey);\n            const allColumns    = cachedColumns || (await this.query (\n                `SELECT column_name FROM information_schema.columns WHERE table_name = $1`,\n                [tableName]\n            )).rows.map(row => row.column_name);\n            if (!cachedColumns) columnCache.set(cacheKey, allColumns);\n            \n            // Filter data to match columns while maintain element's order\n            const columns = [];\n            const values = [];\n            \n            for (const column of allColumns) {\n                if (data.hasOwnProperty(column)) {\n                    columns.push(column);\n                    values.push(data[column]);\n                }\n            }\n\n        return { columns, values };\n        } catch (error) {\n            handleError('file-access.getColumnValues', error, true);\n        }\n    }\n\n\n\n    async testConnection() {\n\n        node.warn(`[ DataConnection ] Testing connection to ${this.dbName} database`);\n\n        try { return await this.query('SELECT 1') || false;\n\n        }\n\n        catch (error) { return error; }\n\n    }\n\n}\n\n\n\nglobal.set('repo.js', {\n\n    ObjectConnection,\n\n    DataConnection\n\n});\n\n\n\nnode.status({ fill: 'green', shape: 'dot', text: 'OK' });\n\nreturn msg\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "minio",
                "module": "minio"
            },
            {
                "var": "pg",
                "module": "pg"
            },
            {
                "var": "uuid",
                "module": "uuid"
            }
        ],
        "x": 710,
        "y": 620,
        "wires": [
            [
                "d8cffdb3b9561826"
            ]
        ]
    },
    {
        "id": "d8cffdb3b9561826",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "function 22",
        "func": "const { trackPerformance, cError, handleError } = global.get('utilities.js') || {\n    trackPerformance: (name, start, success) => { node.warn(`[PERF] ${name}: ${Date.now() - start}ms (Success: ${success})`); },\n    cError: class extends Error { constructor(code, message) { super(message); this.code = code; } },\n    handleError: (context, error, shouldThrow) => { node.error(`[ERROR] ${context}: ${error.message}`); if (shouldThrow) throw error; }\n};\nconst { getSession } = global.get(\"data-service.js\");\nconst columnCache = global.get('cache.js')?.getCache(\"ColumnCache\") || new Map(); // Get existing cache or provide a simple mock\nconst repo = global.get('repo.js');\n\nif (!repo || !repo.ObjectConnection || !repo.DataConnection) {\n    node.error(\"Required classes (ObjectConnection, DataConnection) not found in global context. Ensure the setup node ('node_red_test_node') is deployed and runs successfully first.\");\n    node.status({ fill: 'red', shape: 'dot', text: 'Repo Classes Not Found' });\n    return null; // In Node-RED, returning null stops message propagation\n}\n\nconst { ObjectConnection, DataConnection } = repo;\nconst req = {};\nreq.headers = {};\nreq.headers.authorization = \"Bearer sx_58364de7a7b24a0283d6ad95443f4bf2400f17a8b1264c16835325095b0b5e75317a12f9846d426f85745652c85e\"\nreq.headers['x-fh-app-uid'] = \"LIMS-IRDOP-PRD\";\n// Example usage:\nconst fileInfo = {\n  fileName: \"document.pdf\",\n  fileSize: 1024 * 500, // 500 KB\n  fileType: \"application/pdf\",\n  filePath: \"/document.pdf\",\n  uploadDate: new Date(\"2025-05-18T10:00:00Z\"),\n};\n\nconst payload = {\n  objectName: \"report.pdf\",\n  expiry: 600,\n  reqParams: {\n    version: \"v2\",\n    accessLevel: \"read\"\n  },\n   fileInfo: fileInfo,\n  requestDate: new Date(),\n};\nconst minioOptions = {\n    \"bucket\":\"irdop\",\n    \"endPoint\": \"s3.irdop.org\",\n    \"accessKey\": \"rNItZci16fmAVcb9HA2e\",\n    \"secretKey\": \"GD1hNEGOteycopeFIDWqPItFoULeJvGkX52LMBdt\",\n};\nconst dbOptions = {\n    \"name\": \"LIMS\", // Tên tùy chọn này không được sử dụng trực tiếp bởi pg\n    user: \"postgres\", // Tên người dùng database\n    host: \"red.irdop.org\", // Địa chỉ host database\n   // password: \"exploring-dynasty-system\", // Mật khẩu database (sử dụng 'password' thay vì 'pw' cho pg)\n    port: 5432, // Cổng kết nối database\n    database: \"LIMS\", // Tên cơ sở dữ liệu cụ thể bạn muốn kết nối\n    pw:\"exploring-dynasty-system\"\n};\nconst session = await getSession(req);\n\n//const result = await session.db.testConnection()\n// Initialize connections using the classes retrieved from global context\nlet objectConnection = null;\nlet dataConnection = null;\n\ntry {\n    dataConnection = new DataConnection(dbOptions, session);\n    req.headers = {};\n    req.headers.authorization = \"Bearer sx_58364de7a7b24a0283d6ad95443f4bf2400f17a8b1264c16835325095b0b5e75317a12f9846d426f85745652c85e\"\n    req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";\n    objectConnection = new ObjectConnection(minioOptions, await getSession(req));\n} catch (initError) {\n    node.warn( initError);\n    node.status({ fill: 'red', shape: 'dot', text: 'Init Failed' });\n}\n\nlet topic = \"insertPresignRecord\"\n\n    try {\n        let result = null;\n        switch (topic) {\n            case 'testConnection':\n                node.warn(\"Testing DataConnection...\");\n                result = await dataConnection.testConnection();\n                node.warn(result);\n                break;\n\n            case 'getColumnValues':\n                // payload should be { tableName: '...', data: { ... } }\n                if (payload && payload.tableName && payload.data) {\n                    node.warn(`Testing getColumnValues for table: ${payload.tableName}`);\n                    result = await dataConnection.getColumnValues(payload.tableName, payload.data);\n                } else {\n                    throw new Error(\"Invalid payload for getColumnValues. Expected { tableName, data }\");\n                }\n                break;\n\n            case 'getUpLink':\n                if (true) {\n                    node.warn(`Testing getUpLink for object: ${payload.objectName}`);\n                    const fileInfo = payload.fileInfo || { fileName: payload.objectName, fileMime: 'application/octet-stream' };\n                    result = await objectConnection.getUpLink(fileInfo, payload.objectName, payload.expiry, payload.reqParams, payload.requestDate);\n                     node.warn(result)\n                } else {\n                    throw new Error(\"Invalid payload for getUpLink. Expected { objectName, ... }\");\n                }\n                break;\n\n            case 'getDownLink':\n                // payload should be { fileInfo: { ... }, objectName: '...' }\n                if (true) {\n                    node.warn(`Testing getDownLink for object: ${payload.objectName}`);\n                    // Pass dummy fileInfo if not provided\n                    const fileInfo = payload.fileInfo || { fileName: payload.objectName, fileMime: 'application/octet-stream' };\n                    result = await objectConnection.getDownLink(fileInfo, payload.objectName, payload.expiry, payload.reqParams, payload.requestDate);\n                    node.warn(result);\n                } else {\n                    throw new Error(\"Invalid payload for getDownLink. Expected { objectName, ... }\");\n                }\n                break;\n\n            case 'genFileUID':\n                node.warn(\"Testing genFileUID...\");\n                result = objectConnection.genFileUID();\n                node.warn(result);\n                break;\n\n            case 'insertPresignRecord':\n                if (true) {\n                    payload.tableName=\"s3_object\"\n                    payload.data = {\n                        file_uid: 'b2c3d4e5-f6a7-8901-2345-67890abcdef0',\n                        created_at: '2024-10-15T14:30:00Z', \n                        deleted_at: null,\n                        identity_uid: 'd1e2f3g4-h5i6-7890-1234-567890abcdef', \n                        app_uid: 'e2f3g4h5-i6j7-8901-2345-67890abcdef0',\n                        file_info: {\n                            fileName: \"profile_pic.jpg\",\n                            fileMime: \"image/jpeg\",\n                            size: 50000,\n                            resolution: \"800x600\",\n                            uploadedBy: \"user_johndoe_456\"\n                        },\n                        bucket_name: 'user-profile-images',\n                        object_name: 'users/d1e2f3g4-h5i6-7890-1234-567890abcdef/avatar.jpg', \n                        version_id: 'AjHkLjKmNlOpQrStUvWxYzAbCdEfGh',\n                        etag: '1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p' \n                    };\n                    let result = await dataConnection.getColumnValues(\"s3_object\",payload.data)\n                    node.warn(result);\n                 } else {\n                    throw new Error(\"Invalid payload for insertPresignRecord. Expected { objectName, url, expiry, ... }\");\n                }\n                break;\n\n            case 'onUploadComplete':\n                // payload should contain info about the completed upload\n                if (payload) {\n                    node.warn(\"Testing onUploadComplete...\");\n                    await objectConnection.onUploadComplete(payload);\n                    result = { status: \"onUploadComplete called\" };\n                } else {\n                    throw new Error(\"Invalid payload for onUploadComplete.\");\n                }\n                break;\n\n            case 'onUploadFailure':\n                // payload should contain info about the failed upload\n                if (payload) {\n                    node.warn(\"Testing onUploadFailure...\");\n                    await objectConnection.onUploadFailure(payload);\n                    result = { status: \"onUploadFailure called\" };\n                } else {\n                    throw new Error(\"Invalid payload for onUploadFailure.\");\n                }\n                break;\n\n\n            default:\n                node.warn(`Unknown topic: ${topic}. No action taken.`);\n                result = { status: `Unknown topic: ${topic}` };\n        }\n\n        // Send the result in the output message\n        msg.payload = result;\n        node.send(msg);\n\n    } catch (error) {\n        node.warn(error);\n        node.error(`Error processing message with topic ${topic}:`, error);\n        msg.payload = { error: error.message };\n        node.send(msg);\n    }\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "minio",
                "module": "minio"
            },
            {
                "var": "pg",
                "module": "pg"
            }
        ],
        "x": 730,
        "y": 700,
        "wires": [
            []
        ]
    },
    {
        "id": "2e4fc5ed1e6010ed",
        "type": "inject",
        "z": "7c3157bf68c1b848",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 500,
        "y": 280,
        "wires": [
            [
                "b786a866f377844f"
            ]
        ]
    },
    {
        "id": "b786a866f377844f",
        "type": "function",
        "z": "7c3157bf68c1b848",
        "name": "function 21",
        "func": "const dbOptions = {\n    // \"name\": \"LIMS\", // Tên tùy chọn này không được sử dụng trực tiếp bởi pg\n    user: \"postgres\", // Tên người dùng database\n    host: \"red.irdop.org\", // Địa chỉ host database\n    password: \"exploring-dynasty-system\", // Mật khẩu database (sử dụng 'password' thay vì 'pw' cho pg)\n    port: 5432, // Cổng kết nối database\n    database: \"LIMS\" // Tên cơ sở dữ liệu cụ thể bạn muốn kết nối\n};\n(async function() {\n    node.status({ fill: 'yellow', shape: 'dot', text: 'Connecting to DB...' });\n    node.log(`Attempting direct connection to database: ${dbOptions.database} at ${dbOptions.host}:${dbOptions.port}`);\n\n    let pool; \n    try {\n        pool = new pg.Pool(dbOptions);\n\n        // Lắng nghe sự kiện lỗi trên Pool (quan trọng cho việc quản lý kết nối)\n        pool.on('error', (err, client) => {\n            node.error('Unexpected error on idle client', err);\n            // Trong ứng dụng thực tế có thể muốn xử lý lỗi nghiêm trọng hơn\n        });\n\n        // Thực hiện truy vấn để lấy danh sách tên các bảng\n        const sqlQuery = `\n            SELECT table_name\n            FROM information_schema.tables\n            WHERE table_type = 'BASE TABLE'\n            AND table_schema = 'public'; -- Hoặc schema khác nếu bảng của bạn nằm ngoài 'public'\n        `;\n\n        node.log(`Executing query: ${sqlQuery}`);\n        const result = await pool.query(sqlQuery);\n        const tableNames = result.rows.map(row => row.table_name);\n        node.warn(\"Database Tables:\");\n        node.warn(tableNames);\n        node.status({ fill: 'green', shape: 'dot', text: `Found ${tableNames.length} tables` });\n        msg.payload = tableNames;\n\n    } catch (error) {\n        node.status({ fill: 'red', shape: 'dot', text: 'DB Error' });\n        node.error(\"Database connection or query failed:\", error);\n\n        // Đặt thông báo lỗi vào msg.payload\n        msg.payload = { error: error.message };\n\n    } finally {\n        // Quan trọng: Đóng Pool khi bạn không còn cần nó nữa.\n        // Đối với Node Function xử lý msg liên tục, quản lý Pool ngoài hàm chính\n        // hoặc sử dụng context của Node có thể phù hợp hơn.\n        // Trong ví dụ đơn giản này, chúng ta sẽ đóng Pool sau mỗi lần chạy.\n        if (pool) {\n            node.log(\"Ending DB Pool connection.\");\n            await pool.end(); // Đóng tất cả kết nối trong Pool\n        }\n    }\n\n    // Trả về message để chuyển đến node tiếp theo trong flow\n    return msg;\n\n})(); // Tự động gọi async function này\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "pg",
                "module": "pg"
            }
        ],
        "x": 730,
        "y": 280,
        "wires": [
            [
                "81faf9b9c28f72be"
            ]
        ]
    }
]