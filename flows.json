[
    {
        "id": "f3deaa9ef8948c89",
        "type": "tab",
        "label": "Main",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7dba9e4b6a7d6c28",
        "type": "tab",
        "label": "Main v2",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "90c138ec34557557",
        "type": "tab",
        "label": "Auth Center",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "7a1fb64c865d34db",
        "type": "tab",
        "label": "Internal Service Agent",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "5fb64aedc3e2bcf3",
        "type": "tab",
        "label": "Main",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "46183d332de8b18f",
        "type": "tab",
        "label": "API Endpoints",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "10b4777ab9cd5025",
        "type": "tab",
        "label": "FileHub",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "90124c05cecd5787",
        "type": "group",
        "z": "46183d332de8b18f",
        "name": "Lab ",
        "style": {
            "label": true
        },
        "nodes": [
            "07a1f2e0af111f21",
            "090ebfb08a8ab273",
            "060cdca3bfae5f5b",
            "8d7268b919feebd5",
            "ad7bd9e2daa32fef",
            "fb3a0e2a0a704a0d",
            "8d198522e922ef0d",
            "d351b04153bfba19",
            "b8c068dee7f01d2a"
        ],
        "x": 114,
        "y": 499,
        "w": 732,
        "h": 162
    },
    {
        "id": "57283995a4e830fa",
        "type": "group",
        "z": "46183d332de8b18f",
        "name": "Receipt",
        "style": {
            "label": true
        },
        "nodes": [
            "1cb34f3ccb1d836b",
            "47f3cb2d817de769",
            "4440c61fceb80da0",
            "c9dd0bee078610dd",
            "5ee6e7e6112b7d57",
            "99cd3462bc22c5a8",
            "2cb72e179fa185f8",
            "bbe9b9eb9dd66dc6",
            "1ef57e1e3ad923f3",
            "89a8e8326f42fe01",
            "2654e3fc0cab17e1",
            "2e004b1018baf7e7",
            "5719ec270d4ff6ae",
            "11bbf920bc70be60",
            "3193afaf0ad7f95b",
            "56d3a89ac68c4146",
            "37730e93de030aea",
            "90e8a0f8e82bbe33"
        ],
        "x": 114,
        "y": 159,
        "w": 732,
        "h": 322
    },
    {
        "id": "0ebdf399fafbbae5",
        "type": "group",
        "z": "46183d332de8b18f",
        "name": "Batch Requests",
        "style": {
            "label": true
        },
        "nodes": [
            "d1051bd5a1a694ca",
            "bacb0542964eb8d8",
            "409496890a4f5b21",
            "a9fde53619f580f5",
            "69c05241cea6e0c4"
        ],
        "x": 104,
        "y": 19,
        "w": 742,
        "h": 122
    },
    {
        "id": "41f21d405706fdf9",
        "type": "junction",
        "z": "5fb64aedc3e2bcf3",
        "x": 440,
        "y": 140,
        "wires": [
            [
                "1433a20f7944ae6c",
                "b58595f09d34fcaa",
                "e78d8f6b94f6ec77",
                "5fea1f3d11b6585c",
                "946622c90626134c"
            ]
        ]
    },
    {
        "id": "5bd705a8479a63c2",
        "type": "junction",
        "z": "5fb64aedc3e2bcf3",
        "x": 840,
        "y": 180,
        "wires": [
            [
                "7581a676cb093d88"
            ]
        ]
    },
    {
        "id": "1398d930cd2dd1d9",
        "type": "junction",
        "z": "5fb64aedc3e2bcf3",
        "x": 760,
        "y": 180,
        "wires": [
            [
                "5bd705a8479a63c2"
            ]
        ]
    },
    {
        "id": "4e2aeff839f1c074",
        "type": "telegram client config",
        "botname": "IRDOP Internal Service",
        "verboselogging": false,
        "loginmode": "bot",
        "useproxy": false,
        "usewss": false,
        "devicemodel": "",
        "systemversion": "",
        "appversion": "",
        "host": "",
        "sockstype": "5",
        "port": "6667",
        "username": "anonymous",
        "password": "",
        "secret": "",
        "mtproxy": false,
        "timeout": "2"
    },
    {
        "id": "acac4ace959569ed",
        "type": "telegram client config",
        "botname": "oa_zalo_bot",
        "verboselogging": false,
        "loginmode": "bot",
        "useproxy": false,
        "usewss": false,
        "devicemodel": "",
        "systemversion": "",
        "appversion": "",
        "host": "",
        "sockstype": "5",
        "port": "6667",
        "username": "anonymous",
        "password": "",
        "secret": "",
        "mtproxy": false,
        "timeout": "2"
    },
    {
        "id": "39d97d88c2550518",
        "type": "global-config",
        "name": "global-config",
        "env": [
            {
                "name": "dbConfig:LIMS-IRDOP-DEV",
                "value": "{\"name\":\"lims-dev\",\"user\":\"postgres\",\"host\":\"postgres-db\",\"pw\":\"exploring-dynasty-system\",\"port\":5432}",
                "type": "json"
            },
            {
                "name": "dbConfig:LIMS-IRDOP-PRD",
                "value": "{\"name\":\"LIMS\",\"user\":\"postgres\",\"host\":\"postgres-db\",\"pw\":\"exploring-dynasty-system\",\"port\":5432}",
                "type": "json"
            },
            {
                "name": "dbConfig:identity",
                "value": "",
                "type": "str"
            },
            {
                "name": "s3Config",
                "value": "{\"LIMS-IRDOP-DEV\":{\"accessKey\":\"x7z4dOGRsXcpoFBlljVQ\",\"secretkey\":\"KfIqpTPDvX2EapIk7q2toyLzbeepumyq8wkT7dn7\"},\"LIMS-IRDOP-PRD\":{\"accessKey\":\"0byNFACo4TAzTIpZSUNg\",\"secretkey\":\"b2BRQVNnJ1pxsbSzVLCyZEcAUTOXGxk6e8HPcqqD\"}}",
                "type": "json"
            }
        ]
    },
    {
        "id": "5713a18fe4b90d79",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "START",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.001",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 100,
        "y": 60,
        "wires": [
            [
                "e529ddc66ccceda4"
            ]
        ]
    },
    {
        "id": "35818376b74b9267",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "entity.js",
        "func": "const { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst dataService = global.get('data-service.js');\nconst { createCache, CacheWorld } = global.get('cache.js');\n\nclass Session {\n    #headers = {};\n    #info = {};\n    #discovery = {};\n\n    constructor(info, headers) {\n        if (!info) throw new cError(500, 'Info is required');\n        this.className = this.constructor.name;\n        this.#info = { ...info, className: this.className };\n        this.#headers = headers;\n    }\n\n    get info() { return { ...this.#info, className: this.className }; }\n    get identityUID() { return this.info.identityUID; }\n    get user() { return this.#discovery?.User; }\n    get email() { return this.#discovery?.User?.email; }\n    get identityName() { return this.#discovery?.User?.identityName; }\n    get role() { return this.info.role; }\n    get token() { return this.sessionUID; }         // Token chính là sessionUID\n    get sessionUID() { return this.info.sessionUID; }\n    get headers() { return this.#headers; }\n    set headers(headers) { this.#headers = headers; }\n    get appUID() { return this.#info.appUID; }\n    get accessKey() { return this.#info.accessKey; }\n\n    async getUser() {\n        try {\n            const user = await dataService.getUser(this);\n            if (user) this.#discovery['User'] = user;\n            return user;\n        } catch (error) { return null; }\n    }\n\n    serialize() {\n        return {\n            ...this.info,\n            ...Object.fromEntries(\n                Object.entries(this.#discovery).map(([key, value]) => [\n                    key,\n                    value && typeof value.serialize === 'function' ? value.serialize() : value,\n                ]),\n            ),\n            className: this.className,\n        };\n    }\n}\n\nclass Entity {\n    #discovery = {};\n    #info = {};\n    #session = {};\n\n    constructor(info, session) {\n        if (!info) throw new cError(500, 'Info is required');\n        this.#info = info;\n        this.#session = session;\n    }\n\n    get session() { return this.#session; }\n    get info() { return { ...this.#info, className: this.className }; }\n    get discovery() { return this.#discovery; } // Info mở rộng lưu vào #discovery\n\n    newDiscovery(discovery = {}) {\n        if (discovery) {\n            Object.entries(discovery).forEach(([key, value]) => {\n                if (value && typeof value === 'object' && !Array.isArray(value)) {\n                    this.#discovery[key] = value;\n                } else {\n                    this.#discovery[key] = value;\n                }\n            });\n        }\n    }\n\n    // Info mở rộng lưu vào #discovery\n    serialize() {       // convert object gồm cả info đã mở rộng từ newDiscovery\n        return {\n            ...this.info,\n            ...Object.fromEntries(\n                Object.entries(this.#discovery).map(([key, value]) => [\n                    key,\n                    value && typeof value.serialize === 'function' ? value.serialize() : value,\n                ])\n            ),\n        };\n    }\n\n    // PERMISSION\n    getPermissionFor(action) {\n\n    }\n\n    addLog(logType, logTime, logForEntity, fnName, data) {\n        const options = {\n            logType: logType || '',           // event/scheduled | auto/manual |\n            logObject: logForEntity || '',           // Sử dụng thiết bị, theo dõi môi trường, nhật ký hệ thống, nhật ký thử nghiệm, nhật ký người dùng, nhật ký mẫu,\n            logNotion: '',                           // error, warning, info\n            timestamp: logTime || Date.now(),\n            systemLog: {\n                entity: this.className,\n                fnName: fnName || '',\n                timestamp: Date.now(),\n                sessionUID: this.session.sessionUID,\n                appUID: this.session.appUID,\n                accessKey: this.session.accessKey,\n                identityUID: this.session.identityUID,\n            },\n            description: data.description || '',\n        };\n\n        const doneBy = `thực hiện bởi ${this.session.identityName || this.session.identityUID}`;\n    }     // TODO\n    addAudit(actionType, timestamp, fnName, description) { }   // TODO\n}\n\nclass User extends Entity {\n    constructor(info, session) {\n        super(info, session);\n\n        // Tạo getter từ info object\n        Object.keys(info).forEach(key => {\n            if (key !== 'className') {\n                Object.defineProperty(this, key, {\n                    get: () => this.info[key],\n                    enumerable: true,\n                    configurable: true,\n                });\n            }\n        });\n        this.className = 'User';\n    }\n\n    get relation() { return this.discovery?.relations; }\n\n    async editInfo(newInfo) {\n        if (newInfo) {\n            // query/ post / access\n        }\n        return new User(this.info, this.session);\n    }\n\n    async newRelation(relation) {\n        if (relation?.appUID) {\n            // query/ post / access return {}\n            this.newDiscovery({ relations: await this.getRelation() });\n        }\n        // relations = [\n        //     {\n        //         appUID: 'LIMS-IRDOP-DEV',\n        //         disabled: false,\n        //         staff: true,\n        //         staff_technician: true,\n        //     }, {\n        //         appUID: 'LIMS-IRDOP-DEV',\n        //         disabled: false,\n        //         staff: true,\n        //         staff_technician: true,\n        //     },\n        // ]\n    }\n\n    async getRelationList() { }\n\n    async getRelation(appUID) { }\n\n    // CHECK Permission\n    canEdit() {\n    }\n}\n\n// TODO CLASS: Analysis, Sample, Receipt\n// TODO CLASS: File (with fileInfo {...})6\n// TODO CLASS: Log      (actionType on any entity) \n// TODO CLASS: Audit    (actionType on any entity)\n\nglobal.set('entity.js', { Session, User });\nnode.warn('entity.js loaded successfully');\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 280,
        "y": 180,
        "wires": [
            [
                "1921ea2569c8fb02"
            ]
        ]
    },
    {
        "id": "1921ea2569c8fb02",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "data-service",
        "func": "const { trackPerformance, cError, handleError } = global.get('utilities.js');\nconst { convertCamelCase, convertSnakeCase } = global.get('utilities.js');\nconst { Session, User } = global.get('entity.js');\nconst { createCache } = global.get('cache.js');\nconst axios = global.get('axios');\nconst { Pool } = global.get('pg');\n\nconst sessionCache = createCache('Session', 120 * 60 * 1000);        // 2 hour\nconst userCache = createCache('User', 60 * 60 * 1000);        // 1 hour\nconst analysisCache = createCache('Analysis', 60 * 60 * 1000);        // 1 hour\nconst sampleCache = createCache('Sample', 60 * 60 * 1000);        // 1 hour\nconst receiptCache = createCache('Receipt', 60 * 60 * 1000);        // 1 hour\n\n// SESSION & USER\nasync function getSession(req) {\n    const { headers } = req;\n    let appUID = headers['x-fh-app-uid'];\n    if (!appUID) throw new cError(400, \"Please provide appUID\")\n    if (!headers['authorization']) throw new cError(401, \"Please login to continue\")\n    const sessionUID = headers['authorization'].split(' ')[1] || headers['Authorization'].split(' ')[1];\n    const accessKey = headers['x-fh-access-key'] || env.get('s3Config')[appUID];    // USER or SERVER KEY\n    \n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `Session:${sessionUID}`;      // Định danh cache\n        let cachedSession = sessionCache.get(cacheKey);   // Tìm cache\n            node.warn({cachedSession});\n        if (cachedSession) {\n            node.warn(`Cached session found: ${cacheKey}`);\n            return cachedSession;           // Trả về cache (nếu có)\n        }\n\n        // CONSTRUCT SESSION CLASS\n        const endpoint = \"https://pink.irdop.org/ab4dg2/auth/me\";\n        const headers = {\n            \"Content-Type\": `application/json`,\n            \"Authorization\": `Bearer ${sessionUID}`,   // từ user request\n            \"x-fh-app-uid\": appUID,                   // từ user request\n            \"x-fh-access-key\": accessKey,                // từ user request hoặc server setting\n        };\n\n        // GET SESSION INFO\n        const response = await axios.post(endpoint, {}, { headers });\n        const sessionInfo = convertCamelCase(response?.data);\n\n        if (!sessionInfo) throw new cError(401, 'Please login to continue');\n\n        // CREATE & CACHE\n        const session = new Session(sessionInfo, headers);\n        await session.getUser(); // Preload user info\n\n        cachedSession = sessionCache.set(cacheKey, session);\n        return session;\n    } catch (error) {\n        handleError(error, 'data-service.js.getSession');\n        throw error;\n    } finally {\n        trackPerformance('data-service.js.getSession', startTime);\n    }\n}\nasync function loginUser(req) {\n    const { body, headers } = req;\n    const { email, password } = body;\n    const appUID = headers['x-fh-app-uid'];\n    if (!email) throw new cError(400, \"Please provide email\");\n    if (!password) throw new cError(400, \"Please provide password\");\n    if (!appUID) throw new cError(400, \"No application is provided for your login session\");\n\n    const startTime = Date.now();\n    try {\n        node.warn(123123);\n        // GET SESSION\n        const response = await axios.post('https://pink.irdop.org/gre134e/auth/login', { email, password }, {\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'x-fh-app-uid': appUID\n            }\n        });\n\n        // RESPONSE\n        const sessionInfo = convertCamelCase(response?.data);\n        if (!sessionInfo) throw new cError(401, 'Failed to validate your credentials');\n\n        // CREATE SESSION ENTITY\n        const session = new Session(sessionInfo, headers);\n        await session.getUser(); // Preload user info\n        const cacheKey = `Session:${session.token}`;\n        sessionCache.set(cacheKey, session);\n        return session;\n    } catch (error) {\n        handleError(error, `data-service.js.loginUser [${email}]`);\n        throw error;\n    } finally {\n        trackPerformance(`data-service.js.loginUser [${email}]`, startTime, true);\n    }\n}\nasync function getUser(session) {\n    const { identityUID, email } = session;\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `User:${identityUID}`;    // Định danh cache\n        const userInfo = userCache.get(cacheKey) ? userCache.get(cacheKey) : async () => {\n            // GET USER INFO\n            const endpoint = \"https://pink.irdop.org/ab4dg2/get/iden\";\n            const body = { identity_uid: identityUID, email: email };\n            const headers = session.headers;\n            const response = await axios.post(endpoint, body, { headers });\n            const userInfo = convertCamelCase(response?.data);         // convert to camelCase format\n            if (!userInfo) throw new cError(404, 'User not found');\n            userCache.set(cacheKey, userInfo);                          // Cache user info\n            return userInfo;\n        }\n\n        // CREATE USER ENTITY\n        const user = new User(userInfo, session);\n        return user;\n    } catch (error) {\n        node.warn({ error });\n        handleError(error, 'data-service.js.getUser');\n        throw error;\n    } finally {\n        trackPerformance('data-service.js.getUser', startTime, true);\n    }\n}\nasync function getUserByInfo(identity, session) {\n    const { identityUID, email } = identity;\n    if (!identityUID && !email) throw new cError(400, \"Please provide identityUID or email\");\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `User:${identityUID || email}`;   // Định danh cache\n        const cachedUser = userCache.get(cacheKey);          // Tìm cache\n        if (cachedUser) return cachedUser;                  // Trả về cache nếu có\n\n        // SEND REQUEST\n        const endpoint = \"https://pink.irdop.org/ab4dg2/get/iden\";\n        const body = { identity_uid: identityUID, email };\n        const headers = { ...session.headers };\n        const response = await axios.post(endpoint, body, { headers });\n        \n        // CONVERT TO CAMEL CASE\n        const userInfo = convertCamelCase(response?.data);\n        if (!userInfo) throw new cError(404, 'User not found');\n\n        // RETURN USER ENTITY & CACHE\n        const user = new User(userInfo, session);\n        userCache.set(cacheKey, user);\n        return user;\n    } catch (error) {\n        handleError(error, 'data-service.js.getUser');\n        throw error;\n    } finally {\n        trackPerformance('getUser', startTime, true);\n    }\n\n}\nasync function newUser(req, session) {\n    const { identityName, email } = req?.body;\n    // Với user phải có identityName và email (Bot/Server thì không cần)\n    if (!identityName) throw new cError(400, \"Please provide identity name\");\n    if (!email) throw new cError(400, \"Please provide email\");\n\n    const startTime = Date.now();\n    try {\n        // TRY CACHE\n        const cacheKey = `User:${identityName}:${email}`;    // Định danh cache\n        const cachedUser = userCache.get(cacheKey);   // Tìm cache\n        if (cachedUser) throw new cError(400, 'User already exists'); // User đã tồn tại\n\n        // PREPARE RELATIONS\n        const { relations } = req.body;     // Lấy relations từ POST request\n        if (Array.isArray(relations) && relations.length > 0) {\n            // Format relations to match the API\n            relations.forEach(relation => {\n                return {\n                    relation_name: session.appUID, // gán appUID cho relation_name\n                    ...relation\n                };\n            });\n        }\n\n        // POST NEW USER\n        const newUser = await axios.post('https://pink.irdop.org/ab4dg2/insert/iden', {\n            identity_name: identityName,                 // Bắt buộc\n            email: email,                        // Bắt buộc\n            password: req.body.password,\n            identity_contact: req.body.identityContact || {},\n            telegram_peer: req.body.telegramPeer || {},\n            zalo_user_id: req.body.zaloUserId || \"\",\n            relations: relations || [],\n        }, {\n            headers: {\n                ...session.headers,            // session built-in headers\n            }\n        });\n\n        const userInfo = convertCamelCase(newUser?.data);\n        // Failed to create user\n        if (!userInfo) throw new cError(400, 'Failed to create a new user');\n\n        // CREATE USER ENTITY\n        const user = new User(userInfo, session);\n        userCache.set(cacheKey, user);   // Cache user\n        return user;\n    } catch (error) {\n        handleError(error, 'newUser');\n        throw error;\n    } finally {\n        trackPerformance(`newUser [${identityName} - ${email}]`, startTime, true);\n    }\n}\n\n// SAMPLE & ANALYSIS\n\n// TODO: GET analysis, sample, receipt\n// TODO: GET fileUpLink, fileInfo, fileDownLink\n\nglobal.set('data-service.js', {\n    getSession,\n    getUser,\n    getUserByInfo,\n    loginUser,\n    newUser,\n})\nnode.warn('data-service.js is loaded');\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "pg",
                "module": "pg"
            }
        ],
        "x": 370,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "26e4fd86f86ad619",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "auth session",
        "func": "const { getSession } = global.get(\"data-service.js\");\n// GET: https://red.irdop.org/v1/auth/session\nnode.warn({msg})\ntry {\n    // GET SESSION & USER\n    const { req } = msg;\n    const session = await getSession(req);\n    const user = session.user ? await session.getUser() : null;\n\n    // PREPARE RESPONSE\n    if (user) {\n        msg.statusCode = 200;\n        msg.payload = {\n            session: session.serialize(),\n            type: \"AuthSuccess\",\n        };\n    } else {\n        msg.statusCode = 401;\n        msg.payload = { message: 'Session is expired. Please login to continue' };\n    }\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred' };\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\nreturn msg;\n\n/** RESPONSE BODY:\n * {\n *   session: {\n *      ...sessionInfo,\n *      user: {\n *          ...userInfo,\n *          className: \"User\"\n *      }\n *      className: \"Session\"\n *   }\n *   type: \"Auth\"\n * }\n */\n\n// // Test input\n// const req = {};\n// req.headers = {};\n// req.headers.authorization = \"Bearer sx_1549e6de0f174145a387745644e50aa30f7e6cf75c5342ccb2d7c51b0fdb8f40e3c6839c40df425b8fd4091147e6\"\n// req.headers['x-fh-app-uid'] = \"LIMS-IRDOP-DEV\";",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 340,
        "wires": [
            [
                "14cfa6918c935777"
            ]
        ]
    },
    {
        "id": "e529ddc66ccceda4",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "cache",
        "func": "const CacheWorld = {}; // global.get('CacheWorld') || {};\nglobal.set('CacheWorld', CacheWorld);\n\nfunction createCache(cacheName, ttl = 6 * 60 * 1000) {\n    // Validate inputs\n    if (CacheWorld[cacheName]) {\n        node.warn(`Cache name \"${cacheName}\" already exists. Please use a different name.`);\n    }\n    if (typeof ttl !== 'number' || ttl < 0) {\n        throw new Error('Invalid TTL value. It must be a positive number.');\n    }\n    if (!cacheName || typeof cacheName !== 'string') {\n        throw new Error('Cache name is required and must be a string.');\n    }\n\n    const store = new Map();\n    const cache = {\n        ttl,\n        get(key) {\n            const entry = store.get(key);\n            if (!entry) return null;\n            if (this.ttl > 0 && Date.now() - entry.timestamp > this.ttl) {\n                node.warn(`Cache entry \"${key}\" has expired. Cleaning up...`);\n                if (entry.value && typeof entry.value.clear === 'function') {\n                    entry.value.clear();\n                }\n                store.delete(key);\n                return null;\n            }\n            return entry.value;\n        },\n        set(key, value) {\n            store.set(key, { value, timestamp: Date.now() });\n            return value;\n        },\n        has(key) {\n            return store.has(key);\n        },\n        size() {\n            return store.size;\n        },\n        keys() {\n            return Array.from(store.keys());\n        },\n        delete(key) {\n            const entry = store.get(key);\n            if (!entry) return false;\n            if (entry.value && typeof entry.value.clear === 'function') {\n                entry.value.clear();\n            }\n            store.delete(key);\n            return true;\n        },\n        clear() {\n            for (const [, entry] of store) {\n                if (entry.value && typeof entry.value.clear === 'function') {\n                    entry.value.clear();\n                }\n            }\n            store.clear();\n            return true;\n        },\n        getAll() {\n            return Object.fromEntries(Array.from(store, ([key, entry]) => [key, entry.value]));\n        },\n        entries() {\n            return Array.from(store.entries());\n        },\n    };\n\n    // Only store non-nested caches in CacheWorld\n    CacheWorld[cacheName] = cache;\n    return cache;\n}\n\n// CACHE CLEANER\nconst cleaner = setInterval(() => {\n    node.warn('Cache cleaner started');\n    let totalCleaned = 0;\n    let memoryCleaned = 0;\n    let nameCleaned = [];\n\n    for (const cacheName in CacheWorld) {\n        const cache = CacheWorld[cacheName];\n        if (!cache || cache.size() === 0) continue;\n\n        for (const [key, entry] of cache.entries()) {\n            try {\n                const cacheTTL = cache.ttl || 0;\n                if (cacheTTL > 0 && entry.timestamp + cacheTTL < Date.now()) {\n                    // Clean nested caches if they exist\n                    if (entry.value && typeof entry.value.clear === 'function') {\n                        entry.value.clear();\n                    }\n\n                    // Estimate memory cleaned (rough approximation)\n                    memoryCleaned += JSON.stringify(entry.value).length || 0;\n\n                    // Delete expired entry\n                    cache.delete(key);\n                    totalCleaned++;\n                    nameCleaned.push(key);\n                }\n            } catch (error) {\n                node.error(`Error cleaning cache entry: ${key} in ${cacheName}`, error);\n            }\n        }\n\n        // Remove empty caches from CacheWorld\n        if (cache.size() === 0) {\n            delete CacheWorld[cacheName];\n        }\n    }\n\n    if (totalCleaned > 0) {\n        node.warn(`Cache cleaner removed ${totalCleaned} entries from ${Object.keys(CacheWorld).length} caches. Memory cleaned: ${memoryCleaned} bytes. Cache names: ${nameCleaned.join(', ')}`);\n    }\n}, 5 * 60 * 1000); // every 5 minutes\n\n\nglobal.set('cache.js', {\n    createCache,\n    CacheWorld,\n});\n\nnode.warn('Cache.js loaded. Cleaner is scheduled');\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 130,
        "y": 100,
        "wires": [
            [
                "6cace463e1b92b68"
            ]
        ]
    },
    {
        "id": "6cace463e1b92b68",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "utilities",
        "func": "const { createCache } = global.get('cache.js');\nconst performanceData = createCache('performanceData', 0); // No expiration\nconst axios = global.get('axios');\n\nclass cError extends Error {\n    constructor(statusCode, properties, rethrow = true) {\n        if (typeof properties === 'string') {\n            properties = { message: properties, statusCode, rethrow };\n        }\n        else if (typeof properties === 'object') {\n            properties = {\n                message: properties.message || 'An error occurred',\n                statusCode: properties.statusCode || properties.code || 500,\n                rethrow: rethrow || properties.rethrow || false,\n            };\n        }\n        else {\n            properties = { message: 'An error occurred', statusCode, rethrow };\n        }\n        super(properties.message);\n\n        // Capture the stack trace\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, cError);\n        }\n        this.statusCode = statusCode || 500;\n        this.catchCount = 0;\n    }\n}\n\nfunction handleError(error, functionName, rethrow = false) {\n    if (error.catchCount === 0) {\n        error.catchCount += 1;\n        node.warn(`${error.message} (caused at ${functionName})\\n${error.stack}`);\n    } else {\n        error.catchCount = 1;\n        node.warn(`${error.message} (caused at ${functionName})\\n${error.stack}`);\n    }\n    return error;\n}\n\nfunction trackPerformance(functionName, startTime, isSuccess = true) {\n    const elapsedTime = Date.now() - startTime;\n    const currentData = performanceData.get(functionName) || { count: 0, totalTime: 0, successCount: 0, errorCount: 0 };\n    currentData.count += 1;\n    currentData.totalTime += elapsedTime;\n    if (isSuccess) {\n        currentData.successCount += 1;\n    } else {\n        currentData.errorCount += 1;\n    }\n    performanceData.set(functionName, currentData);\n    return currentData;\n}\n\nfunction printPerformanceData() {\n    const data = performanceData.getAll();\n    let message = 'Performance Data:\\n';\n    let messageList = [];\n    for (const [functionName, { count, totalTime, successCount, errorCount }] of Object.entries(data)) {\n        const averageTime = totalTime / count;\n        messageList.push(`Function: ${functionName}, Calls: ${count}, Total Time: ${totalTime}ms, Average Time: ${averageTime.toFixed(2)}ms, Success: ${successCount}, Errors: ${errorCount}\\n`);\n    }\n    if (messageList.length > 0)\n        message += messageList.join('');\n    else\n        message += 'No data.';\n    node.warn(message);\n}\n\nasync function testPoolConnection(pool) {\n    try {\n        await pool.query('SELECT 1');\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function getColumnValues(tableName, pool, data) {\n    try {\n        const result = await pool.query(\n            `SELECT column_name FROM information_schema.columns WHERE table_name = $1`,\n            [tableName]\n        );\n        const allColumns = result.rows.map(row => row.column_name);\n\n        const columns = [];\n        const values = [];\n        for (const column of allColumns) {\n            if (data.hasOwnProperty(column)) {\n                columns.push(column);\n                values.push(data[column]);\n            }\n        }\n\n        return { columns, values };\n    } catch (error) {\n        handleError('file-access.getColumnValues', error, true);\n    }\n}\n\nfunction convertSnakeCase(input) {\n    // if (typeof input === 'string') {\n    //     // Check if the string is already in snake_case\n    //     if (!/[A-Z]/.test(input)) {\n    //         return input; // Return as-is if no uppercase letters are found\n    //     }\n    //     // Convert camelCase string to snake_case\n    //     return input.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()\n    //         .replace(/(?<![a-z])UID(?![a-z])/g, '_uid'); // Special case for UID, ensuring it's not part of a larger word\n    // } else \n    if (typeof input === 'object' && input !== null) {\n        if (Array.isArray(input)) {\n            // If it's an array, recursively process each element\n            return input.map(item => convertSnakeCase(item));\n        } else {\n            // If it's an object, process each key and value\n            return Object.keys(input).reduce((acc, key) => {\n                const snakeKey = key.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()\n                    .replace(/(?<![a-z])UID(?![a-z])/g, '_uid'); // Special case for UID, ensuring it's not part of a larger word\n                acc[snakeKey] = convertSnakeCase(input[key]);\n                return acc;\n            }, {});\n        }\n    }\n    // Return other data types as-is\n    return input;\n}\n\nfunction convertCamelCase(input) {\n    // if (typeof input === 'string') {\n    //     // Handle special case for _uid first\n    //     input = input.replace(/_uid/g, 'UID');\n\n    //     // Check if the string is already in camelCase\n    //     if (!/_/.test(input) || input.length > 3 && input?.slice(0,3) === 'sx_') {\n    //         return input; // Return as-is if no underscores are found\n    //     }\n\n    //     // Convert snake_case string to camelCase\n    //     return input.replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n    // } else \n    if (typeof input === 'object' && input !== null) {\n        if (Array.isArray(input)) {\n            // If it's an array, recursively process each element\n            return input.map(item => convertCamelCase(item));\n        } else {\n            // If it's an object, process each key and value\n            return Object.keys(input).reduce((acc, key) => {\n                const camelKey = key.replace(/_uid/g, 'UID')\n                    .replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n                acc[camelKey] = convertCamelCase(input[key]);\n                return acc;\n            }, {});\n        }\n    }\n    // Return other data types as-is\n    return input;\n}\n\nglobal.set('utilities.js', {\n    handleError,\n    trackPerformance,\n    printPerformanceData,\n    cError,\n    testPoolConnection,\n    getColumnValues,\n    convertSnakeCase,\n    convertCamelCase\n});\n\nnode.warn('Utilities.js loaded');\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 190,
        "y": 140,
        "wires": [
            [
                "35818376b74b9267",
                "bf234ff85f0c2f41"
            ]
        ]
    },
    {
        "id": "7e61714455d1fd33",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "Login User",
        "func": "const { loginUser } = global.get('data-service.js');\n// endpoint: https://red.irdop.org/v1/auth/login\n\n// RESPONSE { session: { ... }, type: 'LoginSuccess' }\n//\n\ntry {\n    const { req } = msg;\n    const session = await loginUser(req);\n\n    if (session?.info) {\n        msg.statusCode = 200;\n        msg.payload = {\n            session: session.serialize(),\n            type: 'LoginSuccess',\n        };\n    } else {\n        msg.statusCode = 403;\n        msg.payload = { message: 'Access denied' };\n    }\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;\n    msg.payload = { message: error.message };\n    node.error(error);\n}\n\nreturn msg;\n\n\n// // Test input\n// const req = {};\n// req.headers = {\n//     'Content-Type': 'application/json',\n//     'Accept': 'application/json',\n//     'x-fh-app-uid': 'LIMS-IRDOP-PRD',\n// }\n// req.body = {\n//     email: 'abc@xuantruong.xyz',\n//     password: 'xt012j',\n// };",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 380,
        "wires": [
            [
                "5dd6f391b1630e96"
            ]
        ]
    },
    {
        "id": "01e6f89d395c8166",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/auth/login",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 380,
        "wires": [
            [
                "7e61714455d1fd33"
            ]
        ]
    },
    {
        "id": "5dd6f391b1630e96",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 380,
        "wires": []
    },
    {
        "id": "9c20c2e033e39f7e",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/auth/session",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 340,
        "wires": [
            [
                "26e4fd86f86ad619"
            ]
        ]
    },
    {
        "id": "14cfa6918c935777",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 340,
        "wires": []
    },
    {
        "id": "34a32b0c48f415b2",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "New User",
        "func": "const { loginUser } = global.get('data-service.js');\n// endpoint: https://red.irdop.org/v1/auth/login\n\n// RESPONSE { session: { ... }, type: 'LoginSuccess' }\n//\n\ntry {\n    const { req } = msg;\n    const session = await loginUser(req);\n\n    if (session?.info) {\n        msg.statusCode = 200;\n        msg.payload = {\n            session: session.serialize(),\n            type: 'LoginSuccess',\n        };\n    } else {\n        msg.statusCode = 403;\n        msg.payload = { message: 'Access denied' };\n    }\n} catch (error) {\n    msg.statusCode = error.statusCode || 500;\n    msg.payload = { message: error.message };\n    node.error(error);\n}\n\nreturn msg;\n\n\n// // Test input\n// const req = {};\n// req.headers = {\n//     'Content-Type': 'application/json',\n//     'Accept': 'application/json',\n//     'x-fh-app-uid': 'LIMS-IRDOP-PRD',\n// }\n// req.params = {\n//     email: 'abc@xuantruong.xyz',\n//     password: 'xt012j',\n// };",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 500,
        "wires": [
            [
                "75c54f96498fed4f"
            ]
        ]
    },
    {
        "id": "624483601a2c0a6c",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/user/new",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 500,
        "wires": [
            [
                "34a32b0c48f415b2"
            ]
        ]
    },
    {
        "id": "75c54f96498fed4f",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 500,
        "wires": []
    },
    {
        "id": "36f2943ff908aed4",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 545,
        "y": 100,
        "wires": [
            [
                "a9a92aabb3b0b68a"
            ]
        ],
        "l": false
    },
    {
        "id": "a9a92aabb3b0b68a",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "Print Performance Data",
        "func": "const { printPerformanceData } = global.get('utilities.js');\nprintPerformanceData();\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "5b12f9edbda9b6bd",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "Get User Info",
        "func": "// url: https://red.irdop.org/v1/user/info\n// method: POST\nconst { cError } = global.get('utilities.js');\nconst { getSession, getUserByInfo } = global.get('data-service.js');\nnode.warn('GET USER INFO');\ntry {\n    const { req } = msg;\n    const session = await getSession(req);\n    if (!session) throw new cError(401, 'Session is expired. Please login to continue');\n\n    const { params } = req;\n    if (!params) throw new cError(400, 'Bad request. A query is required');\n    if (!params.identityUID && !params.email) throw new cError(400, 'An email or identity is required');\n\n    const user = await getUserByInfo(params, session);\n    if (user) {\n        msg.statusCode = 200;\n        msg.payload = {\n            user: user.serialize(),\n            type: \"UserInfo\",\n        };\n\n    } else {\n        msg.statusCode = 404;\n        msg.payload = { message: 'User not found' };\n    }\n\n} catch (error) {\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        msg.statusCode = error.statusCode;\n        msg.payload = { message: error.message || 'Client error occurred' };\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Internal server error' };\n        node.error(error);\n    }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 420,
        "wires": [
            [
                "3734c6c883f592d4"
            ]
        ]
    },
    {
        "id": "c81954ca1fe00eb2",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/v1/user/info/:identityUID",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 420,
        "wires": [
            [
                "5b12f9edbda9b6bd"
            ]
        ]
    },
    {
        "id": "3734c6c883f592d4",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 570,
        "y": 420,
        "wires": []
    },
    {
        "id": "403ce01496e111e6",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 3100,
        "y": 80,
        "wires": [
            [
                "da4b71158770682e"
            ]
        ]
    },
    {
        "id": "9a0e363b9d06a71d",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "function 14",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3250,
        "y": 200,
        "wires": [
            [
                "b6fb6469bec408a3"
            ]
        ]
    },
    {
        "id": "8eaadab6625cf21e",
        "type": "http in",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "url": "/kkj",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 3060,
        "y": 200,
        "wires": [
            [
                "9a0e363b9d06a71d"
            ]
        ]
    },
    {
        "id": "b6fb6469bec408a3",
        "type": "http response",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 3430,
        "y": 220,
        "wires": []
    },
    {
        "id": "da4b71158770682e",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "function 15",
        "func": "node.warn({msg})\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3250,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "040785e928e90fa2",
        "type": "inject",
        "z": "f3deaa9ef8948c89",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 275,
        "y": 100,
        "wires": [
            [
                "bf234ff85f0c2f41",
                "647b1bfafb1c697e"
            ]
        ],
        "l": false
    },
    {
        "id": "bf234ff85f0c2f41",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "s3.js",
        "func": "const minio = global.get('minio');\n\nconst keys = env.get('s3Config');\nconst options = keys['LIMS-IRDOP-DEV'];\nconst client = new minio.Client(options);\nconst list = await client.listBuckets();\nfunction getUpLink() {\n    \n}\n\nglobal.set('s3.js', {\n    getUpLink,\n\n})\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "647b1bfafb1c697e",
        "type": "function",
        "z": "f3deaa9ef8948c89",
        "name": "db.js",
        "func": "return msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "7a575fb4ef9a69b9",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "Main v2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.001",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 120,
        "wires": [
            [
                "45bf1fee93057a80",
                "40ce27cbc483043f",
                "15231732dbe799f3",
                "c11baa3e662c9207",
                "1143798f7d8e0f62",
                "2a7de89ea59313c3"
            ]
        ]
    },
    {
        "id": "45bf1fee93057a80",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "Lab Repository",
        "func": "// node-RED functions\nconst { Pool } = global.get('pg');\n\n// CONNECTING TO LAB DB\nasync function connect() {\n\ttry {\n                const pool = new Pool(JSON.parse(env.get('labDB')));\n\n\t\tif (await testConnection()) {\n                        node.warn('[ INFO ] LAB DB pool already connected');\n                }\n                else {\n                        await pool.connect();\n                        node.warn('[ SUCCESS ] LAB DB pool connected');\n                }\n                global.set('labRepoClient', pool);\n\t} catch (error) {\n\t\tnode.warn(`[ LAB REPO ERROR ] LABDB connection failed: ${error.stack}`);\n                node.warn(error.stack);\t\n\t}\n}\n\n// CRUD FUNCTIONS\nasync function getReceipt(id, rethrow) {\n        try {\n                const query = `SELECT * FROM receipts WHERE id = $1`;\n                const params = [id];\n                const result = await labRepoClient.query(query, params);\n\n                if (result?.rows[0]) {\n                        return {\n                                ...result.rows[0],\n                                className: 'Receipt',\n                        };\n                }\n                return null;\n        } catch (error) {\n                handleError(error, 'getReceipt', rethrow);\n        }\n}\n\nasync function getSample(id, rethrow) {\n        try {\n                const query = `SELECT * FROM samples WHERE id = $1`;\n                const params = [id];\n                const result = await labRepoClient.query(query, params);\n\n                if (result?.rows[0]) {\n                        return {\n                                ...result.rows[0],\n                                className: 'Sample',\n                        };\n                }\n                return null;\n        } catch (error) {\n                handleError(error, 'getSample', rethrow);\n        }\n}\n\nasync function getSAnalyte(id, rethrow) {\n        try {\n                const query = `SELECT * FROM sample_analytes WHERE id = $1`;\n                const params = [id];\n                const result = await labRepoClient.query(query, params);\n\n                if (result?.rows[0]) {\n                        return {\n                                ...result.rows[0],\n                                className: 'SampleAnalyte',\n                        };\n                }\n                return null;\n        } catch (error) {\n                handleError(error, 'getSAnalyte', rethrow);\n        }\n}\n\nasync function getProtocol(id, rethrow) {\n        try {\n                const query = `SELECT * FROM protocols WHERE id = $1`;\n                const params = [id];\n                const result = await labRepoClient.query(query, params);\n\n                const protocol = result?.rows[0];\n\n                if (protocol) {\n                        return {\n                                ...protocol,\n                                className: 'Protocol',\n                        };\n                }\n                return null;\n        } catch (error) {\n                handleError(error, 'getProtocol', rethrow);\n        }\n}\n\nasync function getAnalyte(id, rethrow) {\n        try {\n                const query = `SELECT * FROM analytes WHERE id = $1`;\n                const params = [id];\n                const result = await labRepoClient.query(query, params);\n                if (result?.rows[0]) {\n                        return {\n                                ...result.rows[0],\n                                className: 'Analyte',\n                        };\n                }\n                return null;\n        } catch (error) {\n                handleError(error, 'getAnalyte', rethrow);\n        }\n}\n\nasync function getClient(id, rethrow) {\n        try {\n                const query = `SELECT * FROM clients WHERE id = $1`;\n                const params = [id];\n                const result = await labRepoClient.query(query, params);\n                \n                if (result?.rows[0]) {\n                        return {\n                                ...result.rows[0],\n                                className: 'Client',\n                        };\n                }\n                return null;\n        } catch (error) {\n                handleError(error, 'getClient', rethrow);\n        }\n}\n\nasync function getMatrix(id, rethrow) {\n        try {\n                const query = `SELECT * FROM matrices WHERE id = $1`;\n                const params = [id];\n                const result = await labRepoClient.query(query, params);\n\n                const matrix = result?.rows[0];\n\n                // lấy ma trận parent nếu có\n                if (matrix?.parent_matrix_id) {\n                        matrix.parent_matrix = await getMatrix(matrix.parent_matrix_id);\n                }\n                \n                if (matrix) {\n                        return {\n                                ...matrix,\n                                className: 'Matrix',\n                        };\n                }\n                return null;\n        } catch (error) {\n                handleError(error, 'getMatrix', rethrow);\n        }\n}\n\nasync function setReceipt(receipt, rethrow) {\n        try {\n                if (Number.isInteger(receipt?.id) && receipt?.id > 0) {\n                        // Lấy receipt schema\n                        const validColumns = await matchValidColumns('receipts', Object.keys(receipt));\n\n                        // Lọc các trường input có trong receipt schema\n                        const validReceipt = Object.fromEntries(\n                                Object.entries(receipt).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Dựng query và thực thi\n                        const query = `\n                                UPDATE receipts\n                                SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                                WHERE id = $1\n                                RETURNING *`;\n                        const params = [receipt.id, ...validColumns.map(column => validReceipt[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // Trả về kết quả\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Receipt'\n                        };\n                }\n                throw new Error(`Invalid receipt id: ${receipt?.id}`);\n        } catch (error) {\n                handleError(error, 'setReceipt', rethrow);\n        }\n}\n\nasync function setSample(sample, rethrow) {\n        try {\n                if (Number.isInteger(sample?.id) && sample?.id > 0) {\n                        // Lấy sample schema\n                        const validColumns = await matchValidColumns('samples', Object.keys(sample));\n\n                        // Lọc các trường input có trong sample schema\n                        const validSample = Object.fromEntries(\n                                Object.entries(sample).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Dựng query và thực thi\n                        const query = `UPDATE samples SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} WHERE id = $1 RETURNING *`;\n                        const params = [sample.id, ...validColumns.map(column => validSample[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // Trả về kết quả\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Sample'\n                        };\n                }\n                throw new Error(`Invalid sample id: ${sample?.id}`);\n        } catch (error) {\n                handleError(error, 'setSample', rethrow);\n        }\n}\n\nasync function setSAnalyte(analyte, rethrow) {\n        try {\n                if (Number.isInteger(analyte?.id) && analyte?.id > 0) {\n                        // Lấy schema\n                        const validColumns = await matchValidColumns('sample_analytes', Object.keys(analyte));\n\n                        // Lọc các trường input có trong schema\n                        const validAnalyte = Object.fromEntries(\n                                Object.entries(analyte).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Dựng query và thực thi\n                        const query = `UPDATE sample_analytes SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} WHERE id = $1 RETURNING *`;\n                        const params = [analyte.id, ...validColumns.map(column => validAnalyte[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // Trả về kết quả\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'SampleAnalyte'\n                        };\n                }\n                throw new Error(`Invalid sample analyte id: ${analyte?.id}`);\n        } catch (error) {\n                handleError(error, 'setAnalyte', rethrow);\n        }\n}\n\nasync function setProtocol(protocol, rethrow) {\n        try {\n                if (Number.isInteger(protocol?.id) && protocol?.id > 0) {\n                        // Lấy schema\n                        const validColumns = await matchValidColumns('protocols', Object.keys(protocol));\n\n                        // Lọc các trường input có trong schema\n                        const validProtocol = Object.fromEntries(\n                                Object.entries(protocol).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Dựng query và thực thi\n                        const query = `\n                                UPDATE protocols \n                                SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} \n                                WHERE id = $1 RETURNING *`;\n                        const params = [protocol.id, ...validColumns.map(column => validProtocol[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // Trả về kết quả\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Protocol'\n                        };\n                }\n                throw new Error(`Invalid protocol id: ${protocol?.id}`);\n        } catch (error) {\n                handleError(error, 'setProtocol', rethrow);\n        }\n}\n\nasync function setMatrix(matrix, rethrow) {\n        try {\n                if (Number.isInteger(matrix?.id) && matrix?.id > 0) {\n                        // get schema\n                        const validColumns = await matchValidColumns('matrices', Object.keys(matrix));\n\n                        // filter input fields to match schema\n                        const validMatrix = Object.fromEntries(\n                                Object.entries(matrix).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Check if there are valid columns to update\n                        if (validColumns.length === 0) {\n                                throw new Error('No valid columns to update');\n                        }\n\n                        // construct query and execute\n                        const query = `UPDATE matrices SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} WHERE id = $1 RETURNING *`;\n                        const params = [matrix.id, ...validColumns.map(column => validMatrix[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // return result\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Matrix'\n                        };\n                }\n                else throw new Error(`Invalid matrix id: ${matrix?.id}`);\n        } catch (error) {\n                handleError(error, 'setMatrix', rethrow);\n        }\n}\n\nasync function setAnalyte(analyte, rethrow) {\n        try {\n                if (Number.isInteger(analyte?.id) && analyte?.id > 0) {\n                        // Lấy schema\n                        const validColumns = await matchValidColumns('analytes', Object.keys(analyte));\n\n                        // Lọc các trường input có trong schema\n                        const validAnalyte = Object.fromEntries(\n                                Object.entries(analyte).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Dựng query và thực thi\n                        const query = `UPDATE analytes SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} WHERE id = $1 RETURNING *`;\n                        const params = [analyte.id, ...validColumns.map(column => validAnalyte[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // Trả về kết quả\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Analyte'\n                        };\n                }\n                throw new Error(`Invalid analyte id: ${analyte?.id}`);\n        } catch (error) {\n                handleError(error, 'setAnalyte', rethrow);\n        }\n}\n\nasync function setClient(client, rethrow) {\n        try {\n                if (Number.isInteger(client?.id) && client?.id > 0) {\n                        // Lấy schema\n                        const validColumns = await matchValidColumns('clients', Object.keys(client));\n\n                        // Lọc các trường input có trong schema\n                        const validClient = Object.fromEntries(\n                                Object.entries(client).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Dựng query và thực thi\n                        const query = `UPDATE clients SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} WHERE id = $1 RETURNING *`;\n                        const params = [client.id, ...validColumns.map(column => validClient[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // Trả về kết quả\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Client'\n                        };\n                }\n                throw new Error(`Invalid client id: ${client?.id}`);\n        } catch (error) {\n                handleError(error, 'setClient', rethrow);\n        }\n}\n\nasync function createClient(client, rethrow) {\n        try {\n                if (client?.client_name) {\n                        // Get Schema\n                        const validColumns = await matchValidColumns('clients', Object.keys(client));\n\n                        // Filter input fields to match schema\n                        const validClient = Object.fromEntries(\n                                Object.entries(client).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Generate new UID\n                        const nextUid = await generateClientUID();\n                        validColumns.push('client_uid');\n                        validClient.client_uid = nextUid;\n\n                        // Construct query and execute\n                        const query = `INSERT INTO clients (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = [...validColumns.map(column => validClient[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // Return result\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Client'\n                        };\n                }\n                else throw new Error(`Invalid client name: ${client?.client_name}`);\n        } catch (error) {\n                handleError(error, 'createClient', rethrow);\n        }\n}\n\nasync function createReceipt(receipt, rethrow) {\n        try {\n                if (receipt?.client_id && !receipt?.id) {\n                        // Get schema\n                        const validColumns = await matchValidColumns('receipts', Object.keys(receipt));\n\n                        // Filter input fields to match schema\n                        const validReceipt = Object.fromEntries(\n                                Object.entries(receipt).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Generate new UID\n                        const nextUid = await generateReceiptUID();\n                        validColumns.push('receipt_uid');\n                        validReceipt.receipt_uid = nextUid;\n\n                        // Construct query and execute\n                        const query = `\n                                INSERT INTO receipts (${validColumns.join(',')}) \n                                VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) \n                                RETURNING *`;\n                        const params = [...validColumns.map(column => validReceipt[column])]; // Ensure params match validColumns\n\n                        // Debugging: Log query and params\n                        node.warn({ query, params });\n\n                        const result = await labRepoClient.query(query, params);\n\n                        // Return result\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Receipt'\n                        };\n                }\n                throw new Error(`Invalid receipt client id: ${receipt?.client_id}`);\n        } catch (error) {\n                handleError(error, 'createReceipt', rethrow);\n        }\n}\n\nasync function createProtocol(protocol, rethrow) {\n        try {\n                if (protocol?.protocol_name && protocol?.protocol_code) {\n                        // get schema\n                        const validColumns = await matchValidColumns('protocols', Object.keys(protocol));\n\n                        // filter input fields to match schema\n                        const validProtocol = Object.fromEntries(\n                                Object.entries(protocol).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // construct query and execute\n                        const query = `INSERT INTO protocols (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = [...validColumns.map(column => validProtocol[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // return result\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Protocol'\n                        };\n                }\n                else throw new Error(`Invalid protocol name: ${protocol?.protocol_name} or code: ${protocol?.protocol_code}`);\n        } catch (error) {\n                handleError(error, 'createProtocol', rethrow);\n        }\n}\n\nasync function createAnalyte(analyte, rethrow = true) {\n        try {\n                if (analyte?.analyte_name) {\n                        // get schema\n                        const validColumns = await matchValidColumns('analytes', Object.keys(analyte));\n\n                        // filter input fields to match schema\n                        const validAnalyte = Object.fromEntries(\n                                Object.entries(analyte).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // generate new UID\n                        const nextUid = await generateAnalyteUID();\n                        validColumns.push('analyte_uid');\n                        validAnalyte.analyte_uid = nextUid;\n                        // construct query and execute\n                        const query = `INSERT INTO analytes (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = [...validColumns.map(column => validAnalyte[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // return result\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Analyte'\n                        };\n                }\n                else throw new Error(`Invalid analyte name: ${analyte?.analyte_name}`);\n        } catch (error) {\n                handleError(error, 'createAnalyte', rethrow);\n        }\n}\n\nasync function createMatrix(matrix, rethrow) {\n        try {\n                if (matrix?.matrix_name) {\n                        // get schema\n                        const validColumns = await matchValidColumns('matrices', Object.keys(matrix));\n                        const validMatrix = Object.fromEntries(\n                                Object.entries(matrix).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Query\n                        const query = `INSERT INTO matrices (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = [...validColumns.map(column => validMatrix[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // Result return\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Matrix'\n                        };\n                }\n                else throw new Error(`Invalid matrix name: ${matrix?.matrix_name}`);\n        } catch (error) {\n                handleError(error, 'createMatrix', rethrow);\n        }\n}\n\nasync function updateMatrix(matrix, rethrow) {\n        try {\n                if (matrix?.id || (matrix.matrix_name && matrix.matrix_name === '')) {\n                        delete matrix?.matrix_uid;\n                        delete matrix?.created_at;\n                        delete matrix?.created_by_id;\n\n                        // get schema\n                        const validColumns = await matchValidColumns('matrices', Object.keys(matrix));\n\n                        // filter input fields to match schema\n                        const validMatrix = Object.fromEntries(\n                                Object.entries(matrix).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // construct query and execute\n                        const query = `UPDATE matrices SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} WHERE id = $1 RETURNING *`;\n                        const params = [matrix.id, ...validColumns.map(column => validMatrix[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // return result\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Matrix'\n                        };\n                }\n                else throw new Error(`Invalid matrix id: ${matrix?.id} or name: ${matrix?.matrix_name}`);\n        } catch (error) {\n                handleError(error, 'updateMatrix', rethrow);\n        }\n}\n\nasync function updateProtocol(protocol, rethrow) {\n        try {\n                if (protocol?.id || (protocol.protocol_name && protocol.protocol_name === '')) {\n                        delete protocol?.protocol_uid;\n                        delete protocol?.created_at;\n                        delete protocol?.created_by_id;\n\n                        // get schema\n                        const validColumns = await matchValidColumns('protocols', Object.keys(protocol));\n\n                        // filter input fields to match schema\n                        const validProtocol = Object.fromEntries(\n                                Object.entries(protocol).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // construct query and execute\n                        const query = `UPDATE protocols SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} WHERE id = $1 RETURNING *`;\n                        const params = [protocol.id, ...validColumns.map(column => validProtocol[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // return result\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Protocol'\n                        };\n                }\n                else throw new Error(`Invalid protocol id: ${protocol?.id} or name: ${protocol?.protocol_name}`);\n        } catch (error) {\n                handleError(error, 'updateProtocol', rethrow);\n        }\n}\n\nasync function updateAnalyte(analyte, rethrow) {\n        try {\n                if (analyte?.id || (analyte.analyte_name && analyte.analyte_name === '')) {\n                        delete analyte?.analyte_uid;\n                        delete analyte?.created_at;\n                        delete analyte?.created_by_id;\n\n                        // get schema\n                        const validColumns = await matchValidColumns('analytes', Object.keys(analyte));\n\n                        // filter input fields to match schema\n                        const validAnalyte = Object.fromEntries(\n                                Object.entries(analyte).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // construct query and execute\n                        const query = `UPDATE analytes SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} WHERE id = $1 RETURNING *`;\n                        const params = [analyte.id, ...validColumns.map(column => validAnalyte[column])];\n                        const result = await labRepoClient.query(query, params);\n\n                        // return result\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Analyte'\n                        };\n                }\n                else throw new Error(`Invalid analyte id: ${analyte?.id} or name: ${analyte?.analyte_name}`);\n        } catch (error) {\n                handleError(error, 'updateAnalyte', rethrow);\n        }\n}\n\n// HELPER FUNCTIONS\nasync function matchValidColumns(table_name, columns) {\n\ttry {\n\t\t/** 1. Get table columns from server */\n\t\t// Construct the SQL query to get the column names from the information schema\n\t\tconst validColumnsQuery = `SELECT column_name FROM information_schema.columns WHERE table_name = $1`;\n\t\tconst validColumnsParams = [table_name];\n\n\t\t// Execute the SQL query;\n\t\tconst validColumnsResult = await labRepoClient.query(validColumnsQuery, validColumnsParams);\n\n\t\t// Extract the column names from the query result\n\t\tconst validColumns = validColumnsResult.rows.map((row) => row.column_name);\n\n\t\t/** 2. Match columns */\n\t\t// Filter the input columns to include only valid columns\n\t\tconst matchedColumns = columns.filter((column) => validColumns.includes(column));\n\n\t\t// Return the matched columns\n\t\treturn matchedColumns || []; // if no match return []\n\t} catch (error) {\n\t\thandleError(error, 'matchValidColumns');\n                return [];\n\t}\n}\n\nasync function handleError(error, function_name, rethrow) {\n        node.warn(`[ LAB REPO ERROR ] ${function_name}: ${error.stack}`);\n        if (rethrow) throw error;\n        else return null;\n}\n\nasync function generateReceiptUID() {\n        try {\n                // Query to get the latest receipt UID\n                const query = `SELECT MAX(receipt_uid) AS latest_receipt_uid FROM receipts`;\n                const result = await labRepoClient.query(query);\n                \n                // Get the latest receipt UID if any, or default to 'TNMx00000000'\n                const latestReceiptUid = result.rows[0]?.latest_receipt_uid || 'TNMx00000000';\n\n                // Get the current time\n                const currentTime = new Date();\n                const currentYear = currentTime.getFullYear();\n                const currentMonth = currentTime.getMonth(); // 0-based index\n                const currentDay = currentTime.getDate();\n                const yearShort = currentYear.toString().slice(-2);\n                const quarter = Math.ceil((currentMonth + 1) / 3);\n                const monthInQuarter = (currentMonth % 3) + 1;\n                const dayFormatted = currentDay.toString().padStart(2, '0');\n                const dateString = `${yearShort}${quarter}${monthInQuarter}${dayFormatted}`;\n\n                // Extract previous day and index from the latest UID\n                const prevDay = latestReceiptUid.slice(8, 10);\n                const prevIndex = parseInt(latestReceiptUid.slice(-2));\n\n                // Determine the new index\n                let newIndex;\n                if (prevDay.toString() === dayFormatted) {\n                        newIndex = (prevIndex + 1).toString().padStart(2, '0');\n                } else {\n                        newIndex = '01';\n                }\n\n                // Construct the new receipt UID\n                const nextReceiptUid = `TNMx${dateString}${newIndex}`;\n\n                return nextReceiptUid;\n        } catch (error) {\n                handleError(error, 'generateReceiptUID');\n        }\n}\n\nasync function generateSampleUID() {\n        // TODO: Generate a new UID for a sample\n}\n\nasync function generateClientUID() {\n        try {\n                // Generate a random 4-character string from 0-9 and a-f\n                const randomChars = Array.from({ length: 4 }, () => {\n                        const randomNum = Math.floor(Math.random() * 16);\n                        return randomNum.toString(16); // Convert to hexadecimal\n                }).join('');\n\n                // Construct the client UID\n                const clientUID = `Cx${randomChars}`;\n\n                return clientUID;\n        } catch (error) {\n                handleError(error, 'generateClientUID');\n        }\n}\n\nasync function generateAnalyteUID() {\n        try {\n                // start with 'Ax' and 4 random number\n                const randomChars = Array.from({ length: 4 }, () => {\n                        const randomNum = Math.floor(Math.random() * 10);\n                        return randomNum.toString();\n                }).join('');\n                const analyteUID = `Ax${randomChars}`;\n                return analyteUID;\n        } catch (error) {\n                handleError(error, 'generateAnalyteUID');\n        }\n}\n\nasync function testConnection() {\n        try {\n                const client = global.get('labRepoClient');\n                const result = await client.query('SELECT 1');\n                return true; // return true if connected\n        } catch (error) {\n                return false;\n        }\n}\n\nasync function disconnect() {\n        const client = global.get('labRepoClient');\n        await client.end();\n        global.set('labRepoClient', undefined);\n        node.warn('[ INFO ] LAB DB disconnected');\n}\n\nawait connect();\nconst labRepoClient = global.get('labRepoClient');\n\n// export function\nglobal.set('labRepo', {\n        getReceipt,\n        getSample,\n        getSAnalyte,\n        getProtocol,\n        getAnalyte,\n        getClient,\n        getMatrix,\n        setReceipt,\n        setSample,\n        setSAnalyte,\n        setProtocol,\n        setMatrix,\n        setAnalyte,\n        setClient,\n        createClient,\n        createReceipt,\n        createProtocol,\n        createAnalyte,\n        createMatrix,\n        updateProtocol,\n        updateMatrix,\n        updateAnalyte,\n        generateReceiptUID,\n        generateSampleUID,\n        testConnection,\n        disconnect\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 200,
        "wires": [
            [
                "bc2f2db70e5e7dbf",
                "6ae6fbf463413930"
            ]
        ]
    },
    {
        "id": "089a99f8e1ab1988",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 945,
        "y": 160,
        "wires": [
            [
                "19ca365419ed5cc3"
            ]
        ],
        "l": false
    },
    {
        "id": "19ca365419ed5cc3",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "labRepo Disconnect",
        "func": "// create a new client\nconst repo = global.get('labRepo');\nawait repo.disconnect();\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "ed6473ecf715a809",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 945,
        "y": 200,
        "wires": [
            [
                "8aa3faa22e8aa0d1"
            ]
        ],
        "l": false
    },
    {
        "id": "8aa3faa22e8aa0d1",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "labRepo test connect",
        "func": "// create a new client\nconst airdopRepo = global.get('labRepo');\nconst result = await airdopRepo.testConnection();\nnode.warn(result);\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "40ce27cbc483043f",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "ERROR",
        "func": "const ERROR = {\n    HTTP_400: (message = 'Bad Request') => {\n        const error = new Error(message);\n        error.statusCode = 400;\n        error.errorName = 'Bad Request';\n        return error;\n    },\n    HTTP_401: (message = 'Unauthorized') => {\n        const error = new Error(message);\n        error.statusCode = 401;\n        error.errorName = 'Unauthorized';\n        return error;\n    },\n    HTTP_403: (message = 'Forbidden') => {\n        const error = new Error(message);\n        error.statusCode = 403;\n        error.errorName = 'Forbidden';\n        return error;\n    },\n    HTTP_404: (message = 'Not Found') => {\n        const error = new Error(message);\n        error.statusCode = 404;\n        error.errorName = 'Not Found';\n        return error;\n    },\n    HTTP_500: (message = 'Internal Server Error') => {\n        const error = new Error(message);\n        error.statusCode = 500;\n        error.errorName = 'Internal Server Error';\n        return error;\n    },\n    HTTP_503: (message = 'Service Unavailable') => {\n        const error = new Error(message);\n        error.statusCode = 503;\n        error.errorName = 'Service Unavailable';\n        return error;\n    }\n}\n\nglobal.set('ERROR', ERROR);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "58e48a419ff90cd7",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 945,
        "y": 240,
        "wires": [
            [
                "4b61de0696e7ab9a"
            ]
        ],
        "l": false
    },
    {
        "id": "4b61de0696e7ab9a",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "Log labCache",
        "func": "// create a new client\nconst cache = global.get('labCache');\nnode.warn(cache);\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "6ae6fbf463413930",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "Lab Cache",
        "func": "const labCache = {};\nglobal.set('labCache', labCache);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "bc2f2db70e5e7dbf",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "Lab Table",
        "func": "const repo = global.get('labRepo');\n\nclass Protocol {\n        static async get(id) {\n                try {\n                        let protocol = Protocol.getCache(id);\n                        if (!protocol) {\n                                protocol = await repo.getProtocol(id);\n                                Protocol.setCache(protocol);\n                        }\n\n                        // Get full matrices\n                        protocol.matrix_list = await Matrix.toMatrixList(protocol.matrix_ids);\n\n                        return protocol;\n                } catch (error) {\n                        Protocol.handleError(error, 'get', true);\n                }\n        }\n\n        static async create(protocol) {\n                try{\n                        if (protocol?.protocol_name && protocol?.protocol_code && protocol?.protocol_source) {\n                                // Make sure list of matrix ids\n                                if (protocol?.matrix_ids && protocol?.matrix_ids?.length > 0) {\n                                        protocol.matrix_ids = await Protocol.makeMatrixIds(protocol.matrix_ids);\n                                }\n\n                                const newProtocol = await repo.createProtocol(protocol);\n                                Protocol.setCache(newProtocol);\n                                return await Protocol.get(newProtocol.id);\n                        } else {\n                                throw global.get('ERROR').HTTP_400('Invalid protocol');\n                        }\n                } catch (error) {\n                        Protocol.handleError(error, 'create', true);\n                }\n        }\n\n        static async update(newProtocol) {\n                try {\n                        if (newProtocol?.id || (newProtocol.protocol_name && newProtocol.protocol_name === '')) {\n                                // Update Matrix Records\n                                if (newProtocol?.matrix_ids && newProtocol?.matrix_ids?.length > 0) {\n                                        newProtocol.matrix_ids = await Protocol.makeMatrixIds(newProtocol.matrix_ids);\n                                }\n\n                                // Update Protocol Record\n                                const updatedProtocol = await repo.updateProtocol(newProtocol);\n                                Protocol.setCache(updatedProtocol);\n                                return await Protocol.get(updatedProtocol.id);\n                        } else {\n                                throw global.get('ERROR').HTTP_400(`Invalid protocol id: ${newProtocol.id} or name: ${newProtocol.protocol_name}`);\n                        }\n                } catch (error) {\n                        Protocol.handleError(error, 'update', true);\n                }\n        }\n        \n        static async makeMatrixIds(matrixList) {    // return list ids\n                if (Array.isArray(matrixList)) {\n                        const updatedMatrixList = await Matrix.scanAndCreate(matrixList);\n                        return await Matrix.toMatrixIds(updatedMatrixList);\n                }\n                return [];\n        }\n\n        static async getMatrixList(protocol) {\n                if (protocol?.matrix_ids) {\n                        return await Matrix.toArrayObject(protocol.matrix_ids);\n                }\n                return [];\n        }\n\n        static setCache(protocol) {\n                if (!protocol?.id) return;\n                const cache = global.get('labCache');\n                if (!cache?.protocol) cache.protocol = {};\n                cache.protocol[protocol.id] = {\n                        value: protocol,\n                        created_at: Date.now()\n                }\n                return cache.protocol[protocol.id].value;\n        }\n\n        static getCache(id, expire = 1000 * 8) {  // 8 seconds\n                const cache = global.get('labCache');\n                if (!id || !cache?.protocol?.[id]) return null;\n                if (cache.protocol[id]?.created_at + expire < Date.now()) {\n                        delete cache.protocol[id];\n                        return null;\n                }\n                return cache.protocol[id]?.value;\n        }\n\n        static handleError(error, method, rethrow = false) {\n                node.warn(`[ ERROR ] Class Protocol ${method} \\n ${error.stack}`);\n                if (rethrow) throw error;\n        }\n}\n\nclass Matrix {\n        static async get(id) {\n                if (Number.isInteger(id)) {\n                        let matrix = Matrix.getCache(id);\n                        if (!matrix) {\n                                matrix = await repo.getMatrix(id);\n                                Matrix.setCache(matrix);\n                        }\n                        return matrix;\n                } else {\n                        return null;\n                }\n        }\n        static async create(matrix) {\n                try {\n                        if (matrix?.matrix_name) {\n                                const newMatrix = await repo.createMatrix(matrix, true);\n                                Matrix.setCache(newMatrix);\n                                return newMatrix;\n                        } else {\n                                throw global.get('ERRORS').HTTP_400(`Invalid matrix value of name: ${matrix.matrix_name}`);\n                        }\n                } catch (error) {\n                        Matrix.handleError(error, 'create', true);\n                }\n        }\n        static async update(newMatrix) {\n                if (newMatrix?.id && newMatrix?.matrix_name) {\n                        const updatedMatrix = await repo.updateMatrix(newMatrix, true);\n                        Matrix.setCache(updatedMatrix);\n                        return updatedMatrix;\n                } else {\n                        throw global.get('ERROR').HTTP_400('Invalid matrix');\n                }\n        }\n        // Array of matrix\n        static async scanAndCreate(matrices) {    // return List Object\n                try {\n                        const results = await Promise.allSettled(matrices.map(async (matrix) => {\n                                // Create if is object, and has no id\n                                if (typeof matrix === 'object' && !matrix?.id) {\n                                        const newMatrix = await Matrix.create(matrix);\n                                        return newMatrix;\n                                }\n                                else if (matrix?.id) {\n                                        return await Matrix.get(matrix.id);\n                                }\n                                else if (Number.isInteger(matrix)) {\n                                        return await Matrix.get(matrix);\n                                }\n                                else return null;\n                        }));\n                        return results.map(result => result.status === 'fulfilled' ? result.value : null);\n                } catch (error) {\n                        this.handleError(error, 'scanAndCreate', true);\n                }\n        }\n        static validateList(matrices) {        // Boolean\n                for (let matrix of matrices) {\n                        if (typeof matrix === 'number') {\n                                if (!Matrix.get(matrix)) return false;\n                        } else if (typeof matrix === 'object' && matrix !== null) {\n                                if (!matrix.matrix_name) return false;\n                        }\n                }\n                return true;\n        }\n        static async toMatrixIds(matrices) {      // List id\n                if (Array.isArray(matrices)) {\n                        const results = await Promise.allSettled(matrices.map(async (matrix) => {\n                                if (typeof matrix === 'number') {\n                                        return matrix;\n                                } else if (typeof matrix === 'object' && matrix?.id) {\n                                        return matrix.id;\n                                }\n                                else return null;\n                        }));\n                        return results.map(result => result.status === 'fulfilled' ? result.value : null);\n                }\n                return [];\n        }\n        static async toMatrixList(matrices) {  // List Object\n                let new_matrices = [];\n                try {\n                        // concurrently go through each matrix, if matrix is number, get matrix object, if matrix is object, push it\n                        new_matrices = await Promise.allSettled(matrices.map(async matrix => {\n                                if (typeof matrix === 'number') {\n                                        return await Matrix.get(matrix);\n                                } else if (typeof matrix === 'object' && matrix !== null) {\n                                        return matrix;\n                                } else return null;\n                        }));\n                        new_matrices = new_matrices.map(result => result.status === 'fulfilled' ? result.value : null);\n\n                        return new_matrices;\n                } catch (error) {\n                        this.handleError(error, 'toArrayObject', true);\n                        return [];\n                }\n        }\n        // Caches\n        static setCache(matrix) {\n                const cache = global.get('labCache');\n                if (!matrix?.id) return;\n                if (!cache.matrix) cache.matrix = {};\n                cache.matrix[matrix.id] = {\n                        value: matrix,\n                        created_at: Date.now()\n                }\n                return cache.matrix[matrix.id].value;\n        }\n        static getCache(id, expire = 1000 * 8) {  // 8 seconds\n                const cache = global.get('labCache');\n                if (!id || !cache?.matrix?.[id]) return null;\n                if (cache.matrix?.[id]?.created_at + expire < Date.now()) {\n                        delete cache.matrix[id];\n                        return null;\n                }\n                return cache.matrix[id].value;\n        }\n        static handleError(error, method, rethrow = false) {\n                node.warn(`[ ERROR ] Class Matrix ${method} \\n ${error.stack}`);\n                if (rethrow) throw error;\n        }\n}\n\nclass Analyte {\n        static async get(id) {\n                try {\n                        let analyte = Analyte.getCache(id);\n                        if (!analyte) {\n                                analyte = await repo.getAnalyte(id);\n                                Analyte.setCache(analyte);\n                        }\n                        return analyte;\n                } catch (error) {\n                        Analyte.handleError(error, 'get', true);\n                }\n        }\n        static async create(analyte) {\n                try {\n                        if (analyte?.analyte_name) {\n                                const newAnalyte = await repo.createAnalyte(analyte);\n                                Analyte.setCache(newAnalyte);\n                                return await Analyte.get(newAnalyte.id);\n                        } else {\n                                throw global.get('ERROR').HTTP_400('Invalid analyte');\n                        }\n                } catch (error) {\n                        Analyte.handleError(error, 'create', true);\n                }\n        }\n        static async update(newAnalyte) {\n                try {\n                        if (newAnalyte?.id || (newAnalyte.analyte_name && newAnalyte.analyte_name === '')) {\n                                const updatedAnalyte = await repo.updateAnalyte(newAnalyte);\n                                Analyte.setCache(updatedAnalyte);\n                                return await Analyte.get(updatedAnalyte.id);\n                        } else {\n                                throw global.get('ERROR').HTTP_400('Invalid analyte');\n                        }\n                } catch (error) {\n                        Analyte.handleError(error, 'update', true);\n                }\n        }\n\n        static setCache(analyte) {\n                const cache = global.get('labCache');\n                if (!analyte?.id) return;\n                if (!cache.analyte) cache.analyte = {};\n                cache.analyte[analyte.id] = {\n                        value: analyte,\n                        created_at: Date.now()\n                }\n                return cache.analyte[analyte.id].value;\n        }\n        static getCache(id, expire = 1000 * 8) {  // 8 seconds\n                const cache = global.get('labCache');\n                if (!id || !cache?.analyte?.[id]) return null;\n                if (cache.analyte?.[id]?.created_at + expire < Date.now()) {\n                        delete cache.analyte[id];\n                        return null;\n                }\n                return cache.analyte[id].value;\n        }\n\n        static handleError(error, method, rethrow = false) {\n                node.warn(`[ ERROR ] Class Analyte ${method} \\n ${error.stack}`);\n                if (rethrow) throw error;\n        }\n}\n\nglobal.set('labTables', {\n        Protocol,\n        Matrix,\n        Analyte,\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "65d2bcc1b02b718b",
        "type": "comment",
        "z": "7dba9e4b6a7d6c28",
        "name": "lab sql",
        "info": "-- PostgreSQL\nCREATE EXTENSION IF NOT EXISTS vector;\n\n-- DELETE ALL TABLES\nDROP TABLE IF EXISTS client CASCADE;\nDROP TABLE IF EXISTS protocol CASCADE;\nDROP TABLE IF EXISTS parameter CASCADE;\nDROP TABLE IF EXISTS receipt CASCADE;\nDROP TABLE IF EXISTS sample CASCADE;\nDROP TABLE IF EXISTS analysis CASCADE;\n\n-- LIBRARY TABLES\nCREATE TABLE client (\n    id SERIAL PRIMARY KEY,\n    client_uid      VARCHAR(20) NOT NULL,\n    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    created_by_uid  VARCHAR(20),\n    modified_at     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_uid VARCHAR(20),\n    client_name     VARCHAR(100) NOT NULL,\n    client_address  VARCHAR(255),\n    contacts        JSONB,\n    internal_memo TEXT\n);\n\nCREATE TABLE protocol (\n    id                      SERIAL PRIMARY KEY,\n    file_uid                VARCHAR(20),\n    protocol_name           VARCHAR(100) NOT NULL,    -- Phương pháp kiểm nghiệm gì đấy cho nền mẫu gì đấy bằng cách nào đấy\n    protocol_code           VARCHAR(100),             -- HDPP /TCVN /QCVN...\n    protocol_description    TEXT,\n    protocol_content        TEXT,              -- content\n    author_name             VARCHAR(100),\n    publisher               VARCHAR(100),\n    created_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    created_by_uid      VARCHAR(20),\n    modified_at         TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_uid     VARCHAR(20)\n);\n\nCREATE TABLE parameter (\n    id                          SERIAL PRIMARY KEY,\n    modified_at                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_uid             VARCHAR(20),\n    created_at                  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    created_by_uid              VARCHAR(20),\n    technicant_uid              VARCHAR(20),            -- Default identity of the tester\n    parameter_uid                 VARCHAR(20) NOT NULL,\n    parameter_name                VARCHAR(100) NOT NULL,\n    protocol_id                 INT REFERENCES protocol(id),\n    protocol_source             VARCHAR(100),\n    protocol_code               VARCHAR(100),\n    matrix                      VARCHAR(100),\n    default_unit                VARCHAR(100),\n    report_notation             TEXT,\n    turnaround_time_expected    INTERVAL,\n    embedding                   vector(1536)\n);\n\n-- ORDER MANAGEMENT TABLES\nCREATE TABLE receipt (\n    id SERIAL PRIMARY KEY,\n    receipt_uid VARCHAR(20) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    created_by_uid VARCHAR(20),\n    modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_uid VARCHAR(20),\n    client_id INT REFERENCES client(id),\n    client_name VARCHAR(100) NOT NULL,\n    contact_person JSONB, -- {name: '', email: '', phone: ''}\n    receipt_date DATE,\n    internal_memo TEXT\n);\n\nCREATE TABLE sample (\n    id SERIAL PRIMARY KEY,\n    sample_uid VARCHAR(20) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    created_by_uid VARCHAR(20),\n    modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_uid VARCHAR(20),\n    receipt_id INT REFERENCES receipt(id),\n    client_id INT REFERENCES client(id),\n    sample_date DATE,\n    sample_information JSONB,\n    sample_description TEXT,\n    sample_volume TEXT,\n    additional_requests TEXT\n);\n\nCREATE TABLE analysis (\n    id SERIAL PRIMARY KEY,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    created_by_uid VARCHAR(20),\n    modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_uid VARCHAR(20),\n    receipt_id INT REFERENCES receipt(id),\n    sample_id INT REFERENCES sample(id),\n    protocol_id         INT REFERENCES protocol(id),\n    parameter_id        INT REFERENCES parameter(id),\n    technicant_uid          VARCHAR(20),    -- Select identity of the tester idx123, idx124, ...\n    -- Local fields\n    parameter_name        VARCHAR(100),\n    protocol_source     VARCHAR(100),\n    protocol_code       VARCHAR(100),\n    result_unit         VARCHAR(100),\n    result_value        TEXT,\n    lodq                TEXT\n);\n\n\n\n\n-- Indexes for clients table\nCREATE INDEX idx_client_client_uid ON client(client_uid);\nCREATE INDEX idx_client_created_by_uid ON client(created_by_uid);\nCREATE INDEX idx_client_modified_by_uid ON client(modified_by_uid);\n\n-- Indexes for protocol table\nCREATE INDEX idx_protocol_created_by_uid ON protocol(created_by_uid);\nCREATE INDEX idx_protocol_modified_by_uid ON protocol(modified_by_uid);\nCREATE INDEX idx_protocol_protocol_name ON protocol(protocol_name);\n\n-- Indexes for parameter table\nCREATE INDEX idx_parameter_parameter_uid ON parameter(parameter_uid);\nCREATE INDEX idx_parameter_created_by_uid ON parameter(created_by_uid);\nCREATE INDEX idx_parameter_modified_by_uid ON parameter(modified_by_uid);\nCREATE INDEX idx_parameter_protocol_id ON parameter(protocol_id);\n\n-- Indexes for receipt table\nCREATE INDEX idx_receipt_receipt_uid ON receipt(receipt_uid);\nCREATE INDEX idx_receipt_created_by_uid ON receipt(created_by_uid);\nCREATE INDEX idx_receipt_modified_by_uid ON receipt(modified_by_uid);\nCREATE INDEX idx_receipt_client_id ON receipt(client_id);\n\n-- Indexes for sample table\nCREATE INDEX idx_sample_sample_uid ON sample(sample_uid);\nCREATE INDEX idx_sample_created_by_uid ON sample(created_by_uid);\nCREATE INDEX idx_sample_modified_by_uid ON sample(modified_by_uid);\nCREATE INDEX idx_sample_receipt_id ON sample(receipt_id);\nCREATE INDEX idx_sample_client_id ON sample(client_id);\n\n-- Indexes for analysis table\nCREATE INDEX idx_analysis_created_by_uid ON analysis(created_by_uid);\nCREATE INDEX idx_analysis_modified_by_uid ON analysis(modified_by_uid);\nCREATE INDEX idx_analysis_receipt_id ON analysis(receipt_id);\nCREATE INDEX idx_analysis_sample_id ON analysis(sample_id);\nCREATE INDEX idx_analysis_protocol_id ON analysis(protocol_id);\n",
        "x": 770,
        "y": 200,
        "wires": []
    },
    {
        "id": "88ccf2b86f55b996",
        "type": "comment",
        "z": "7dba9e4b6a7d6c28",
        "name": "filehub SQL",
        "info": "-- PostgreSQL\n-- vector extension\nCREATE EXTENSION IF NOT EXISTS vector;\n\nCREATE TABLE tag (\n        tag_name TEXT NOT NULL UNIQUE,\n        is_system_tag BOOLEAN NOT NULL DEFAULT FALSE,\n        is_user_tag BOOLEAN NOT NULL DEFAULT FALSE\n);\n\nCREATE TABLE media (\n        media_uid       VARCHAR(50) PRIMARY KEY DEFAULT 'media_' || substr(gen_random_uuid()::TEXT, 1, 10),\n        media_mime      VARCHAR(50) NOT NULL,     -- mime type\n        media_name      VARCHAR(255) NOT NULL,    -- file name or uid (with extension)\n        media_size      INT NOT NULL,             -- size in bytes\n        description_short TEXT,             -- AI generated 2-3 sentences\n        media_hash TEXT,                          -- hash of the file\n        uris TEXT[] NOT NULL,   -- ['https://drive.google.com/file/d/1234567890/view?usp=sharing', 'https://drive.google.com/file/d/1234567890/view?usp=sharing']\n        tags TEXT[],\n        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        created_by_uid VARCHAR(50) NOT NULL,    -- identity uid\n        modified_by_uid VARCHAR(50) NOT NULL,   -- identity uid\n        -- Indexes for efficiency\n        INDEX (created_by_uid),\n        INDEX (modified_by_uid),\n        INDEX (media_hash)\n);\n\nCREATE TABLE vector_store (\n        vs_uid TEXT PRIMARY KEY DEFAULT 'vs_' || substr(gen_random_uuid()::TEXT, 1, 8),\n        source_type     TEXT NOT NULL,\n        source_value    TEXT NOT NULL,\n        vector_sm       VECTOR(128),\n        vector_md       VECTOR(384),\n        vector_lg       VECTOR(1536),\n        vector_xl       VECTOR(3072),\n        model_name      VARCHAR(100),\n        metadata        JSONB,\n        created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        -- Added index for improved query performance\n        INDEX (source_type),\n        INDEX (source_value),\n        INDEX (created_at),\n        INDEX (model_name)\n);\n\nCREATE TABLE content (\n        id SERIAL PRIMARY KEY,\n        media_uid TEXT NOT NULL REFERENCES media(media_uid),\n        vs_uid TEXT NOT NULL REFERENCES vector_store(vs_uid)\n        content_category VARCHAR(30) NOT NULL, -- full / summary / specific_ (nuances inferred from the media)\n        content_text TEXT NOT NULL,\n        -- Indexes\n        INDEX (vs_uid),\n        INDEX (content_category),\n        INDEX (content_text)\n);\n\n\nCREATE TABLE activity (\n        activity_uid UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        source_type VARCHAR(100) NOT NULL,\n        source_value VARCHAR(100) NOT NULL,\n        activity_type TEXT NOT NULL, -- Downloaded / Uploaded / Extracted / Vectorized / Deleted / Updated / etc\n        activity_description TEXT, -- Download from url, deleted by user, deleted by system, delete local file...\n        metadata JSONB,\n        created_by_uid TEXT NOT NULL, -- identity uid\n);",
        "x": 790,
        "y": 280,
        "wires": []
    },
    {
        "id": "355a8f2bff1a5bd1",
        "type": "comment",
        "z": "7dba9e4b6a7d6c28",
        "name": "auth sql",
        "info": "-- PostgreSQL\n-- table for identity\n\n-- write code that drop all tables\nDROP TABLE IF EXISTS identities CASCADE;\nDROP TABLE IF EXISTS relations CASCADE;\nDROP TABLE IF EXISTS identity_roles CASCADE;\n\n\nCREATE TABLE identities (\n    identity_uid VARCHAR(20) NOT NULL PRIMARY KEY,\n    identity_name VARCHAR(255) NOT NULL,\n    identity_contact TEXT,\n    telegram_peer JSONB,\n    discord_snowflake JSONB,\n    email VARCHAR(255) NOT NULL,\n    password VARCHAR(100) NOT NULL,\n    security JSONB\n);\n\nCREATE TABLE relations (\n    id SERIAL PRIMARY KEY,\n    relation_name VARCHAR(255) NOT NULL UNIQUE,\n    relation_description TEXT\n);\n\nCREATE TABLE identity_roles (\n    id SERIAL PRIMARY KEY,\n    identity_uid VARCHAR(20) NOT NULL REFERENCES identities(identity_uid),\n    relation_id INT NOT NULL REFERENCES relations(id),\n    roles JSONB\n);\n\nCREATE TABLE sessions (\n    session_uid VARCHAR(20) NOT NULL PRIMARY KEY,\n    identity_uid VARCHAR(20) NOT NULL REFERENCES identities(identity_uid),\n    ip_address VARCHAR(20),\n    session_data JSONB,\n    session_expiry TIMESTAMP NOT NULL,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);",
        "x": 770,
        "y": 120,
        "wires": []
    },
    {
        "id": "15231732dbe799f3",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "FileHub Repo",
        "func": "",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            },
            {
                "var": "stream",
                "module": "stream"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 400,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "c11baa3e662c9207",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "Auth Repo",
        "func": "const { Pool } = global.get('pg');\nconst error = global.get('ERROR');\nconst idenRepo = {};\nglobal.set('idenRepo', idenRepo);\n\nasync function connect() {\n        try {\n                const pool = new Pool(JSON.parse(env.get('identityDB')));\n                if (await testConnection()) {\n                        node.warn('[ INFO ] IDEN DB pool already connected');\n                }\n                else {\n                        await pool.connect();\n                        node.warn('[ SUCCESS ] IDEN DB pool connected');\n                }\n                global.set('idenRepoClient', pool);\n        } catch (error) {\n                // Log additional information about the error\n                node.warn(`[ IDEN REPO ERROR ] IDEN DB connection failed:\\n ${error.stack}`);\n        }\n}\n\n// CRUD FUNCTIONS\nasync function verifyPassword(identity, tryingPassword, rethrow) {\n        try {\n                const bcrypt = global.get('bcrypt');\n                const email = identity?.email;\n                const identity_uid = identity?.identity_uid;\n\n                if (!tryingPassword || (!email && !identity_uid)) throw error.HTTP_400('Missing inputs');\n\n                // Lấy identity qua email\n\n                // Lấy password đã hash\n                const hashedPassword = await getIdenHashedPassword(identity, rethrow);\n                if (!hashedPassword) throw error.HTTP_403('Access Denied');\n\n                // So sánh password\n                const isMatch = await bcrypt.compare(tryingPassword, hashedPassword);\n                if (!isMatch) throw error.HTTP_403('Access Denied');        \n\n                // return  full identity\n                const full_identity = await getIden(identity, rethrow);\n                return full_identity;\n        } catch (error) {\n                handleError(error, 'verifyPassword', rethrow);\n        }\n}\n\nasync function getIden(identity, rethrow) {\n        try {\n                const identity_uid = identity?.identity_uid;\n                const email = identity?.email;\n\n                // query by any or all of uid and email\n                let query = '';\n                let params = [];\n                if (identity_uid && email) {\n                        query = 'SELECT * FROM identities WHERE identity_uid = $1 AND email = $2';\n                        params = [identity_uid, email];\n                }\n                else if (identity_uid) {\n                        query = 'SELECT * FROM identities WHERE identity_uid = $1';\n                        params = [identity_uid];\n                }\n                else if (email) {\n                        query = 'SELECT * FROM identities WHERE email = $1';\n                        params = [email];\n                }\n                else throw error.HTTP_400(`Missing input of identity_uid: ${identity_uid}, or email: ${email}`);\n\n                const result = await repo.query(query, params);\n\n                if (result?.rows?.length === 0) return null;\n                else {\n                        const identity = result.rows[0];\n                        delete identity.password;\n                        const relations = await getRelationByIden(identity);\n\n                        // Merging key-value pairs from relations into the identity object\n                        relations.forEach(relation => {\n                            Object.entries(relation).forEach(([key, value]) => {\n                                identity[key] = value; // Assign each key-value pair to identity\n                            });\n                        });\n\n                        identity.className = 'Identity';\n                        return identity;\n                }\n        } catch (error) {\n                handleError(error, 'getIden', rethrow);\n        }\n}\n\nasync function getIdenByUid(uid, rethrow) {\n        try {\n                return await getIden({ identity_uid: uid }, rethrow);\n        } catch (error) {\n                handleError(error, 'getIdentityByUid', rethrow);\n        }\n}\n\nasync function getIdenHashedPassword(identity, rethrow) {\n        try {\n                const identity_record = await getIden(identity, rethrow);\n                if (!identity_record) throw error.HTTP_404('Access Denied');\n\n                // get hashed\n                const query = 'SELECT password FROM identities WHERE identity_uid = $1';\n                const params = [identity_record.identity_uid];\n                const result = await repo.query(query, params);\n\n                // return hashed\n                if (result?.rows?.length === 0) throw error.HTTP_404('Access Denied');\n                else return result.rows[0].password;\n        } catch (error) {\n                handleError(error, 'getIdenHashedPassword', rethrow);\n        }\n}\n\nasync function getRelation(relationId, rethrow) {\n        try {\n                const query = `SELECT * FROM relations WHERE id = $1`;\n                const params = [relationId];\n                const result = await repo.query(query, params);\n                if (result?.rows?.length === 0) return null;\n                else return result.rows[0];\n        } catch (error) {\n                handleError(error, 'getRelation', rethrow);\n        }\n}\n\nasync function getRelationByName(relationName, rethrow) {\n        try {\n                const query = `SELECT * FROM relations WHERE relation_name = $1`;\n                const params = [relationName];\n                const result = await repo.query(query, params);\n                return result?.rows[0];\n        } catch (error) {\n                handleError(error, 'getRelationByName', rethrow);\n        }\n}\n\nasync function getRelationByIden(identity, rethrow) {\n        try {\n                const identity_uid = identity?.identity_uid;\n                if (!identity_uid) throw error.HTTP_400('Missing input of identity_uid');\n\n                // Get all unique relations and their roles of identity in one query\n                const query = `\n                    SELECT DISTINCT r.*, ir.roles \n                    FROM relations r\n                    JOIN identity_roles ir ON r.id = ir.relation_id \n                    WHERE ir.identity_uid = $1\n                `;\n                const params = [identity_uid];\n                const result = await repo.query(query, params);\n                \n                // Check if any relations were found\n                if (!result.rows || result.rows.length === 0) {\n                    return []; // Return an empty array if no relations found\n                }\n\n                // Extract relations and roles from the result\n                const relationNameRoles = result.rows.map(row => {\n                    return {\n                        [row.relation_name]: row.roles // Directly assign roles as a JSONB object\n                    };\n                });\n                return relationNameRoles;\n        } catch (error) {\n                handleError(error, 'findIdenRelation', rethrow);\n        }\n}\n\nasync function findRelationByIden(identity_uid, rethrow) {\n        try {\n                // Query to find relations and roles for a given identity\n                const query = `\n                        SELECT r.relation_name, ir.roles\n                        FROM identity_roles ir\n                        JOIN relations r ON ir.relation_id = r.id\n                        WHERE ir.identity_uid = $1\n                `;\n                const params = [identity_uid];\n                const result = await repo.query(query, params);\n\n                if (result.rows.length === 0) return null;\n\n                // Reduce the result rows to an object with relation names as keys and roles as values\n                const relations = result.rows.reduce((acc, row) => {\n                        acc[row.relation_name] = row.roles;\n                        return acc;\n                }, {});\n\n                return relations;\n        } catch (error) {\n                if (rethrow) throw error;\n                else return null;\n        }\n}\n\nasync function getIdenByTelegramPeer(peerInput, rethrow) {\n        try {\n                // convert peerInput to peerDb\n                const peerDb = convertPeerDB(peerInput);\n\n                if (!peerDb) return null;\n\n                // find identity_uid by telegram_peer JSONB and return full identity\n                const query = 'SELECT * FROM identities WHERE telegram_peer @> $1';\n                const params = [JSON.stringify(peerDb)];\n                const result = await repo.query(query, params);\n\n                if (result?.rows?.length === 0) return null;\n                else {\n                        const full_identity = await getIden({ identity_uid: result.rows[0].identity_uid });\n                        return full_identity;\n                }\n        } catch (error) {\n                handleError(error, 'getIdenByTelegramPeer', rethrow);\n        }\n}\n\nasync function createIden(identity, rethrow) {\n        try {\n                await repo.query('BEGIN'); // Start a transaction\n                const bcrypt = global.get('bcrypt');\n\n                if (identity?.identity_name && identity?.email) {\n                        identity.identity_uid = await generateIdenUid();\n                        identity.password = await bcrypt.hash(identity.password, 12);\n                        identity.security = {};\n                        delete identity.discord_snowflake;      // not implemented yet\n\n                        // nếu có telegram_peer, tạo peer\n                        if (identity?.telegram_peer && Object.keys(identity.telegram_peer).length > 1) {\n                                const peerDb = convertPeerDB(identity.telegram_peer);\n                                if (!peerDb) throw error.HTTP_400(`Invalid input of telegram_peer: ${JSON.stringify(identity.telegram_peer)}`);\n                                identity.telegram_peer = peerDb;\n                        }\n\n                        // Match Identity Schema\n                        const validColumns = await matchValidColumns('identities', Object.keys(identity));\n\n                        const validIdentity = Object.fromEntries(\n                                Object.entries(identity).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Check if the number of valid columns matches the number of parameters\n                        if (validColumns.length !== Object.keys(validIdentity).length) {\n                        throw error.HTTP_400('Mismatch between columns and parameters');\n                        }\n\n                        // Tạo Identity Record\n                        const query = `INSERT INTO identities (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = validColumns.map(column => validIdentity[column]);\n                        const result = await repo.query(query, params);\n\n                        // Tạo Relation và Role\n                        // lấy tất cả key có _relation\n                        const relations = Object.keys(identity).filter(key => key.endsWith('_relation'));\n\n                        // Lấy relation record và tạo role cho relation và iden\n                        for (const relation of relations) {\n                                let relation_record = await getRelationByName(relation);\n                                if (!relation_record) {\n                                        relation_record = await createRelation({ relation_name: relation });\n                                        if (!relation_record) throw error.HTTP_400(`Failed to create relation: ${relation}`);\n                                }\n                                // sau đó tạo role cho relation và iden\n                                const new_role = await createIdenRole({ \n                                        identity_uid: result.rows[0].identity_uid, \n                                        relation_id: relation_record.id, \n                                        roles: identity[relation] });\n                                if (!new_role) throw error.HTTP_400(`Failed to create role: ${relation}`);\n                        }\n\n                        await repo.query('COMMIT'); // Commit the transaction\n\n                        // lấy về tổng hợp identity\n                        const new_identity = await getIdenByUid(result.rows[0].identity_uid);\n                        // Trả về kết quả\n                        if (!new_identity) return null;\n                        else return {\n                                ...new_identity,\n                                className: 'Identity'\n                        };\n                }\n                else throw error.HTTP_400(`Missing input of name: ${identity.identity_name}, email: ${identity.email}, or password`);\n        } catch (error) {\n                await repo.query('ROLLBACK'); // Rollback the transaction on error\n                handleError(error, 'createIden', rethrow);\n        }\n}\n\nasync function createRelation(relation, rethrow) {\n        try {\n                if (relation.relation_name) {\n                        const validColumns = await matchValidColumns('relations', Object.keys(relation));\n                        const validRelation = Object.fromEntries(\n                                Object.entries(relation).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        const query = `INSERT INTO relations (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = [...validColumns.map(column => validRelation[column])];\n                        const result = await repo.query(query, params);\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Relation'\n                        };\n                }\n                else throw error.HTTP_400(`Missing input of name: ${relation.relation_name}`);\n        } catch (error) {\n                if (rethrow) throw error;\n                else return null;\n        }\n}\n\nasync function createIdenRole(identityRole, rethrow) {\n        try {\n                // Must have identity_uid and relation_id\n                if (identityRole.identity_uid && identityRole.relation_id) {\n                        const validColumns = await matchValidColumns('identity_roles', Object.keys(identityRole));\n                        const validIdentityRole = Object.fromEntries(\n                                Object.entries(identityRole).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Dựng query và thực thi\n                        const query = `INSERT INTO identity_roles (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = [...validColumns.map(column => validIdentityRole[column])];\n                        const result = await repo.query(query, params);\n\n                        // Trả về kết quả\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'IdentityRole'\n                        };\n                }\n                else throw error.HTTP_400(`Missing input of identity_uid: ${identityRole.identity_uid}, or relation_id: ${identityRole.relation_id}`);\n        } catch (error) {\n                handleError(error, 'createIdentityRole', rethrow);\n        }\n}\n\nasync function updateIden(identity, rethrow) {\n        try {\n                await repo.query('BEGIN'); // Start a transaction\n\n                const identity_uid = identity?.identity_uid || identity;\n                if (!identity_uid) throw error.HTTP_400('Missing input of identity_uid');\n\n                // check for identity_uid\n                identity = await getIdenByUid(identity_uid);\n                if (!identity) throw error.HTTP_404('Identity not found');\n\n                delete identity.password;\n\n                // check for relation\n                const relations = Object.keys(identity).filter(key => key.endsWith('_relation'));\n                if (relations.length > 0) {\n                        // if relation exists, update role\n                        for (const relation of relations) {\n                                // check if relation exists, if not, create it\n                                let relation_record = await getRelationByName(relation);\n                                if (!relation_record) {\n                                        relation_record = await createRelation({ relation_name: relation });\n                                        if (!relation_record) throw error.HTTP_400(`Failed to create relation: ${relation}`);\n                                }\n\n                                // check if role exists, if not, create it\n                                const new_role = await createOrUpdateIdenRole({\n                                        identity_uid: identity.identity_uid,\n                                        relation_id: relation_record.id,\n                                        roles: identity[relation]\n                                });\n                                if (!new_role) throw error.HTTP_400(`Failed to update role: ${relation}`);\n                        }\n                }\n\n                // match identity schema\n                const validColumns = await matchValidColumns('identities', Object.keys(identity));\n                const validIdentity = Object.fromEntries(\n                        Object.entries(identity).filter(([key]) => validColumns.includes(key))\n                );\n\n                // update identity\n                const query = `UPDATE identities SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')} WHERE identity_uid = $1`;\n                const params = [identity_uid, ...validColumns.map(column => validIdentity[column])];\n                const result = await repo.query(query, params);\n\n                if (result?.rowCount === 0) return null;\n\n                await repo.query('COMMIT'); // Commit the transaction\n                return await getIden({ identity_uid: identity_uid }, rethrow);\n\n        } catch (error) {\n                await repo.query('ROLLBACK'); // Rollback the transaction on error\n                handleError(error, 'updateIdentity', rethrow);\n        }\n}\n\nasync function createOrUpdateIdenRole(identityRole, rethrow) {\n        try {\n                const new_role = await getIdenRoleByUid(identityRole.identity_uid, identityRole.relation_id);\n                if (!new_role) return await createIdenRole(identityRole, rethrow);\n                else return await updateIdenRole(identityRole, rethrow);\n        } catch (error) {\n                handleError(error, 'createOrUpdateIdenRole', rethrow);\n        }\n}\n\nasync function updateIdenRole(identityRole, rethrow) {\n        try {\n                // Must have identity_uid and relation_id\n                if (identityRole.identity_uid && identityRole.relation_id) {\n                        // match identity_roles schema\n                        let validColumns = await matchValidColumns('identity_roles', Object.keys(identityRole));\n                        validColumns = validColumns.filter(column => column !== 'identity_uid'); // Exclude identity_uid\n                        const validIdentityRole = Object.fromEntries(\n                                Object.entries(identityRole).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // build query\n                        const query = `UPDATE identity_roles SET ${validColumns.map((column, index) => `${column} = $${index + 1}`).join(', ')} WHERE identity_uid = $${validColumns.length + 1} AND relation_id = $${validColumns.length + 2}`;\n                        const params = [...validColumns.map(column => validIdentityRole[column]), identityRole.identity_uid, identityRole.relation_id];\n\n                        const result = await repo.query(query, params);\n                        if (result?.rowCount === 0) return null;\n                        else return await getIdenRoleByUid(identityRole.identity_uid, identityRole.relation_id);\n                }\n                else throw error.HTTP_400(`Missing input of identity_uid: ${identityRole.identity_uid}, or relation_id: ${identityRole.relation_id}`);\n        } catch (error) {\n                handleError(error, 'updateIdenRole', rethrow);\n        }\n}\n\nasync function getIdenRoleByUid(identity_uid, relation_id) {\n        try {\n                const query = 'SELECT * FROM identity_roles WHERE identity_uid = $1 AND relation_id = $2';\n                const params = [identity_uid, relation_id];\n                const result = await repo.query(query, params);\n                if (result?.rows?.length === 0) return null;\n                else return {\n                        ...result.rows[0],\n                        className: 'IdentityRole'\n                };\n        } catch (error) {\n                handleError(error, 'getIdenRoleByUid');\n        }\n}\n\nasync function delIden(identity, rethrow) {\n        try {\n                const identity_uid = identity?.identity_uid;\n                if (!identity_uid) throw error.HTTP_400('Missing input of identity_uid');\n\n                await repo.query('BEGIN'); // Start a transaction\n\n                // delete identity_roles\n                const deleteRolesQuery = 'DELETE FROM identity_roles WHERE identity_uid = $1';\n                const params = [identity_uid];\n                await repo.query(deleteRolesQuery, params);\n\n                // delete identity\n                const deleteIdentityQuery = 'DELETE FROM identities WHERE identity_uid = $1';\n                await repo.query(deleteIdentityQuery, params);\n\n                await repo.query('COMMIT'); // Commit the transaction\n                return { success: true }; // Return a success response\n        } catch (error) {\n                await repo.query('ROLLBACK'); // Rollback the transaction on error\n                handleError(error, 'delIden', rethrow);\n        }\n}\n\n// SESSIONS\nasync function createSs(identity, session_data, rethrow) {\n        try {\n                // identity input could be string or object, either way, get identity_uid\n                const identity_uid = typeof identity === 'string' ? identity : identity.identity_uid;\n                if (!identity_uid) throw error.HTTP_400('Missing input of identity_uid');\n\n                // Check existing session\n                const existing_session = await getCurrentSs(identity, rethrow);\n                // if session exists and not expired, update session\n                if (existing_session && existing_session.session_expiry > new Date()) {\n                        // update session\n                        const updated_session = await updateCurrentSs({\n                                session_uid: existing_session.session_uid,\n                                session_data: session_data\n                        }, rethrow);\n                        return updated_session;\n                }\n                else {\n                        // create new session\n                        const validColumns = await matchValidColumns('sessions', Object.keys(session_data));\n                        const validSession = Object.fromEntries(\n                                Object.entries(session_data).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // create session\n                        const query = `INSERT INTO sessions (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = [...validColumns.map(column => validSession[column])];\n                        const result = await repo.query(query, params);\n                        if (result?.rowCount === 0) return null;\n                        else return await getCurrentSs(identity, rethrow);\n                }\n        } catch (error) {\n                handleError(error, 'createSession', rethrow);\n        }\n}\n\nasync function getCurrentSs(identity, rethrow) {\n        try {\n                const identity_uid = typeof identity === 'string' ? identity : identity?.identity_uid;\n                if (!identity_uid) throw error.HTTP_400('Missing input of identity_uid');\n\n                // find session by identity_uid not expired\n                const query = 'SELECT * FROM sessions WHERE identity_uid = $1 AND session_expiry > NOW()';\n                const params = [identity_uid];\n                const result = await repo.query(query, params);\n\n                // return session\n                if (result?.rows?.length === 0) return null;\n                else return {\n                        ...result.rows[0],\n                        className: 'Session'\n                };\n        } catch (error) {\n                handleError(error, 'getCurrentSs', rethrow);\n        }\n}\n\nasync function updateCurrentSs(session, rethrow) {\n        try {\n                if (!session?.session_uid) throw error.HTTP_400('Missing input of session_uid');\n                if (!session?.identity_uid) throw error.HTTP_400('Missing input of identity_uid');\n\n                // Security check identity request must match existing session\n                const existing_session = await getCurrentSs(session?.identity_uid, rethrow);\n                if (session?.session_uid === existing_session?.session_uid \n                        && session?.identity_uid === existing_session?.identity_uid\n                ) {\n                        // match session schema\n                        const validColumns = await matchValidColumns('sessions', Object.keys(session));\n                        const validSession = Object.fromEntries(\n                                Object.entries(session).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // update session\n                        const query = `UPDATE sessions SET ${validColumns.join(',')} = ${validColumns.map((_, index) => `$${index + 1}`).join(',')} WHERE session_uid = $1`;\n                        const params = [session.session_uid, ...validColumns.map(column => validSession[column])];\n                        await repo.query(query, params);\n\n                        // return updated session\n                        const updated_session = await getCurrentSs(session?.identity_uid, rethrow);\n                        return updated_session;\n                }\n                else throw error.HTTP_400('Invalid session request');\n\n        } catch (error) {\n                handleError(error, 'updateSession', rethrow);\n        }\n}\n\n// FUNCTION HELPERS\nasync function matchValidColumns(table_name, columns) {\n        try {\n                /** 1. Get table columns from server */\n                // Construct the SQL query to get the column names from the information schema\n                const validColumnsQuery = `SELECT column_name FROM information_schema.columns WHERE table_name = $1`;\n                const validColumnsParams = [table_name];\n\n                // Execute the SQL query;\n                const validColumnsResult = await repo.query(validColumnsQuery, validColumnsParams);\n\n                // Extract the column names from the query result\n                const validColumns = validColumnsResult.rows.map((row) => row.column_name);\n\n                /** 2. Match columns */\n                // Filter the input columns to include only valid columns\n                const matchedColumns = columns.filter((column) => validColumns.includes(column));\n\n                // Return the matched columns\n                return matchedColumns || []; // if no match return []\n        } catch (error) {\n                handleError(error, 'matchValidColumns');\n                return [];\n        }\n}\n\nasync function handleError(error, function_name, rethrow) {\n        node.warn(`[ IDEN REPO ERROR ] ${function_name}: ${error.stack}`);\n        if (rethrow) throw error;\n        else return null;\n}\n\nasync function generateIdenUid() {\n        // 'IDx' 5 random hexadecimal characters (0-9, a-f)\n        const uid = 'IDx' + [...Array(5)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');\n        return uid;\n}\n\nfunction convertPeerDB(peerInput) {\n        // convert peerInput to peerDb\n        const peerDb = {\n                ...(peerInput?.userId && { userId: String(peerInput.userId) }),\n                ...(peerInput?.chatId && { chatId: String(peerInput.chatId) }),\n                ...(peerInput?.channelId && { channelId: String(peerInput.channelId) }),\n                className: peerInput?.className,\n        };\n        if (!peerInput?.className || (!peerInput?.userId && !peerInput?.chatId && !peerInput?.channelId)) return null;\n        return peerDb;\n}\n\nasync function convertPeerTelegram(peerDb) {\n        // convert peerDb to peerTelegram\n        const peerTelegram = {\n                ...(peerDb?.userId && { userId: peerDb.userId }),\n                ...(peerDb?.chatId && { chatId: peerDb.chatId }),\n                ...(peerDb?.channelId && { channelId: peerDb.channelId }),\n                className : peerDb?.className,\n        };\n        return peerTelegram;\n}\n\nasync function testConnection() {\n        try {\n                const client = global.get('idenRepoClient');\n                const result = await client.query('SELECT 1');\n                if (result) return true; // return true if connected\n        } catch (error) {\n                return false;\n        }\n}\n\nasync function disconnect() {\n        const pool = global.get('idenRepoClient');\n        await pool.end();\n        global.set('idenRepoClient', undefined);\n}\n\nawait connect();\nconst repo = global.get('idenRepoClient');\nglobal.set('idenRepo', {\n        getIden,\n        getIdenByUid,\n        getIdenByTelegramPeer,\n        verifyPassword,\n        findRelationByIden,\n        getRelationByIden,\n        createIden,\n        createRelation,\n        createIdenRole,\n        updateIden,\n        updateIdenRole,\n        delIden,\n        testConnection,\n        disconnect\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 160,
        "wires": [
            [
                "e4b635b589f6fd61"
            ]
        ]
    },
    {
        "id": "e4b635b589f6fd61",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "Auth Cache",
        "func": "const authCache = {};\nglobal.set('authCache', authCache);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "6f632df2b33e8eba",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 945,
        "y": 300,
        "wires": [
            [
                "844b682f83f185a6"
            ]
        ],
        "l": false
    },
    {
        "id": "844b682f83f185a6",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "FileHub test connect",
        "func": "// create a new client\nconst repo = global.get('fileRepo');\nconst result = await repo.testConnection();\nnode.warn(result);\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 300,
        "wires": [
            []
        ]
    },
    {
        "id": "7c4f5bcf5691d11b",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1285,
        "y": 240,
        "wires": [
            [
                "1022bc22119fadf4"
            ]
        ],
        "l": false
    },
    {
        "id": "1022bc22119fadf4",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "labRepo Disconnect",
        "func": "// create a new client\nconst repo = global.get('fileRepo');\nawait repo.disconnect();\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "1143798f7d8e0f62",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "GoogleDrive",
        "func": "const { google } = global.get('googleapis');\nconst { OAuth2Client } = global.get('googleAuthLibrary');\nconst fs = global.get('fs').promises;\n\n// Nếu thay đổi các phạm vi này, xóa token.json.\nconst SCOPES = [\n    'https://www.googleapis.com/auth/drive', // write + read\n    'email', \n    'profile',\n];\n\n// Đường dẫn tuyệt đối đến token và credentials\nconst TOKEN_PATH = \"token.json\"; // Đường dẫn tuyệt đối đến token, nếu chưa có file sẽ tạo ở đây\n\nfunction loadCredentials() {\n    // const content = await fs.readFile(CREDENTIALS_PATH);\n    // const keys = JSON.parse(content);\n    const keys = JSON.parse(env.get('ggsec'))\n    return keys.installed || keys.web;\n}\n\nasync function saveToken(token) {\n    try {\n        await fs.writeFile(TOKEN_PATH, JSON.stringify(token, null, 2));\n        node.warn(`Token saved to ${TOKEN_PATH}`);\n    } catch (err) {\n        node.error(`Error saving token: ${err}`);\n        throw err;\n    }\n}\n\nasync function getAccessToken(oauth2Client) { // tên chưa phù hợp lắm -> getGGAuthUrl ,...\n    const authUrl = oauth2Client.generateAuthUrl({\n        access_type: 'offline', // có thể refresh token, không cần xác thực thủ công\n        prompt: 'consent',\n        scope: SCOPES,\n    });\n\n    node.warn('Authorize this app by visiting this URL:' + authUrl);\n    return authUrl; // Trả URL để người dùng truy cập cấp quyền\n}\n\n\nasync function getTokenFromCode(oauth2Client, code) {\n    try {\n        const { tokens } = await oauth2Client.getToken(code);\n        oauth2Client.setCredentials(tokens);\n\n        // Lưu token vào file\n        await saveToken(tokens);\n        node.warn('Token successfully retrieved and saved.');\n\n        return oauth2Client;\n    } catch (error) {\n        node.error('Error retrieving access token', error);\n        throw error;\n    }\n}\n\nasync function loadToken() {\n    try {\n        // Đọc nội dung từ file token\n        const read_token = await fs.readFile(TOKEN_PATH, 'utf8');\n        const token = JSON.parse(read_token);\n\n        return token; // Trả về token đã đọc\n    } catch (error) {\n        if (error.code === 'ENOENT') {\n            node.warn('No token file found. User needs to authenticate.');\n        } else {\n            node.error(`Error loading token: ${error.message}`);\n        }\n        return null; // Trả về null nếu không tìm thấy hoặc lỗi khác\n    }\n}\n\nasync function refreshAccessToken() {\n    try {    \n        // Đọc token từ file\n        const content = await fs.readFile(TOKEN_PATH);\n        const tokens = JSON.parse(content);\n\n        // Kiểm tra nếu refresh_token có sẵn\n        if (!tokens.refresh_token) {\n            throw new Error('No refresh token found in the saved token file.');\n        }\n\n        // Khởi tạo oauth mới\n        const keys = loadCredentials();\n        const oauth2Client = new OAuth2Client(keys.client_id, keys.client_secret, keys.redirect_uris[1]);\n\n        if (!oauth2Client) {\n            const keys = loadCredentials();\n            const oauth2Client = new OAuth2Client(keys.client_id, keys.client_secret, keys.redirect_uris[1]);\n            global.set('oauth2Client', oauth2Client);  // Lưu oauth2Client vào global\n        }\n\n        // Thiết lập refresh_token cho oauth2Client\n        oauth2Client.setCredentials({ refresh_token: tokens.refresh_token });\n\n        // Làm mới Access Token\n        const { credentials } = await oauth2Client.refreshAccessToken();\n        node.warn('Access token refreshed:' + credentials.access_token);\n\n        // Cập nhật Access Token trong file\n        await saveToken({ ...tokens, ...credentials });\n\n        return credentials.access_token;\n\n    } catch (error) {\n        node.error('Error refreshing access token:', error);\n        throw error;  // Quay lại lỗi nếu không thể làm mới token\n    }\n}\n\nconst setGgCredential = async () => {\n  const keys = await loadCredentials();  \n  const oauth2Client = new OAuth2Client(keys.client_id, keys.client_secret, keys.redirect_uris[0]);\n  const token = await loadToken();\n    // Kiểm tra định dạng token\n    if (!token.access_token || !token.refresh_token) {\n        throw new Error('Invalid token format: Missing access_token or refresh_token.');\n    }\n\n    if (!oauth2Client) {\n        throw new Error('OAuth2Client not initialized.');\n    }\n\n    // Thiết lập credentials\n    oauth2Client.setCredentials(token);\n    node.warn('Token loaded and set to OAuth2Client.');\n    node.warn({oauth2Client});\n\n  global.set('drive_api', {\n    oauth2Client,\n    getAccessToken: () => getAccessToken(oauth2Client),\n    getTokenFromCode: (code) => getTokenFromCode(oauth2Client, code),\n    refreshAccessToken,\n    loadToken\n  });\n\n  node.warn('Drive API initialized.');\n};\n\nawait setGgCredential();\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 340,
        "wires": [
            [
                "e410275b6944e3ee",
                "3c692d070e996071"
            ]
        ]
    },
    {
        "id": "e410275b6944e3ee",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "upload File",
        "func": "const { google } = global.get('googleapis');\nconst oauth2Client = global.get('drive_api').oauth2Client;\nnode.warn(\"set func gg upload file\");\n// Check token\nconst checkExpiryGoogleDriveToken = async () => {\n    const token = await global.get('drive_api').loadToken();\n\n    if (token && token.expiry_date > Date.now()) {\n        node.warn('GoogleDrive: expiry > now');\n    } else if (token && token.expiry_date < Date.now()) {\n        node.warn('GoogleDrive: expiry < now');\n        const refresh_token = await global.get('drive_api').refreshAccessToken();\n    } else {\n        node.warn('google drive token not found!');\n        return msg;\n    }\n}\n\nasync function getFolderIdByName(authClient, folderName) {\n try {\n    const drive = google.drive({ version: 'v3', auth: authClient });\n    //lấy danh sách folder có tên chứa 'folderName'\n    if (folderName.trim() !== '') {\n      const res = await drive.teamdrives.list({\n        q: `name contains '${folderName.trim()}'`,\n        fields: 'teamDrives(id, name)',\n      });\n\n    // Lấy folder đầu tiên tìm được\n      if (res.data.teamDrives && res.data.teamDrives.length > 0) {\n        node.warn(`Folder found: ${folderName}`);\n        return res.data.teamDrives[0].id;\n      } else {\n        // Không tìm thấy, tạo mới thư mục\n        const createRes = await drive.teamdrives.create({\n          requestId: `teamdrive-${Date.now()}`, // Yêu cầu ID duy nhất\n          resource: {\n            name: folderName,\n          },\n        });\n        node.warn({createRes})\n\n        node.warn(`Folder created: ${folderName}`);\n        return createRes.data.id;\n      }\n    } else {\n      throw new Error('Folder name cannot be empty.');\n    }\n  } catch (error) {\n    node.error('Error finding or creating folder:', error);\n    throw error;\n  }\n}\n\nasync function uploadFile( folderName = 'filehub', fileName, fileStream, mimeType , authClient = oauth2Client) {\n    try {\n        await checkExpiryGoogleDriveToken();\n        node.warn({authClient});\n        \n        // Lấy folder ID từ tên thư mục\n        const folderId = await getFolderIdByName(authClient, folderName);\n\n        const drive = google.drive({ version: 'v3', auth: authClient });\n\n        const fileMetadata = {\n            'name': fileName,  // Tên file trên Google Drive\n            'parents': [folderId], // ID thư mục đích\n        };\n\n        const media = {\n            mimeType: mimeType,\n            body: fileStream,  // Đọc file từ hệ thống\n        };\n\n        // Upload file lên Google Drive\n        const res = await drive.files.create({\n            resource: fileMetadata,\n            media: media,\n            fields: 'id, name, webViewLink',\n            supportsAllDrives: true, // Hỗ trợ Shared Drives\n        });\n\n        node.warn('File uploaded successfully. File ID: ' + res.data.id);\n        node.warn(res?.data);\n        return res?.data;\n    } catch (error) {\n        node.error('Error uploading file:'+ error);\n    }\n}\n\nconst drive = global.get('drive_api');\nglobal.set('drive_api', {\n  ...drive,\n  uploadFile,\n  checkExpiryGoogleDriveToken,\n})\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "3c692d070e996071",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "get file",
        "func": "const oauth2Client = global.get('drive_api').oauth2Client;\nconst { google } = global.get('googleapis');\n\n// Lấy danh sách toàn bộ file\nasync function listDriveFiles() {\n  try {\n    const drive = google.drive({ version: 'v3', auth: oauth2Client });\n    const folderId = '0AAP7DlYqRvmRUk9PVA';\n\n    // Gọi API để lấy danh sách file trong thư mục\n    const res = await drive.files.list({\n      q: `'${folderId}' in parents`,  // Điều kiện lọc file thuộc thư mục\n      fields: 'nextPageToken, files(id, name, mimeType)',  // Các trường cần lấy\n      spaces: 'drive',  // Chỉ tìm trong không gian Drive\n      supportsAllDrives: true,  // Hỗ trợ Shared Drive\n      includeItemsFromAllDrives: true,  // Bao gồm cả Shared Drive\n    });\n\n    return res.data.files\n  } catch (error) {\n    node.warn(error);\n  }\n}\n\n// Lấy danh sách file trong một folder (folderName)\nasync function listDriveFilesByFolderName(folderName) {\n\ttry {\n\t\tconst drive = google.drive({ version: 'v3', auth: oauth2Client });\n\n\t\t// Tìm thư mục theo tên\n\t\t// Lấy danh sách các Folder trong  Team Drives (Shared Drives)\n\t\tconst resFolders = await drive.teamdrives.list({\n\t\t\tfields: 'teamDrives(id, name)', // Các trường bạn muốn lấy\n\t\t});\n\n\t\tconst list_folders = resFolders.data.teamDrives;\n\t\t// [{id,name},...]\n\n\t\t// Tìm trong danh sách list_folders thư mục đầu tiền có tên folderName (vì có thể có nhiều thư mục cùng tên)\n\t\tlet folder = list_folders.find((folder) => folder.name === folderName); // Tìm thư mục theo tên\n\n\t\tif (folder) {\n\t\t\t// Lấy ID của thư mục đầu tiên tìm thấy\n\t\t\tconst folderId = folder.id;\n\n\t\t\t// Gọi API để lấy danh sách file trong thư mục (folder) tìm thấy\n\t\t\tconst res = await drive.files.list({\n\t\t\t\tq: `'${folderId}' in parents`, // Điều kiện lọc file thuộc thư mục\n\t\t\t\tfields: 'nextPageToken, files(id, name, mimeType)', // Các trường cần lấy\n\t\t\t\tspaces: 'drive', // Chỉ tìm trong không gian Drive\n\t\t\t\tsupportsAllDrives: true, // Hỗ trợ Shared Drive\n\t\t\t\tincludeItemsFromAllDrives: true, // Bao gồm cả Shared Drive\n\t\t\t});\n\n\t\t\tconst list_files = res.data.files;\n\n\t\t\tif (res.data.files.length === 0) {\n\t\t\t\tnode.warn(`Folder with name \"${folderName}\" is empty.`);\n\t\t\t}\n\n\t\t\t// TODO: Trả về path\n\t\t\tnode.warn('Files in folder:');\n\t\t\tnode.warn(list_files); // In danh sách các file trong thư mục\n\n\t\t\treturn list_files;\n\t\t} else {\n\t\t\tnode.warn(`Folder with name \"${folderName}\" not found.`);\n\t\t}\n\t} catch (error) {\n\t\tnode.warn('Error listing files by folder name:');\n\t\tnode.warn(error);\n\t}\n}\n\nasync function downloadFile(fileIdOrUrl,fileName,mimeType) {\n\ttry {\n\t\tconst fileId = urlToFileId(fileIdOrUrl);\n\n\t\tconst drive = google.drive({ version: 'v3', auth: oauth2Client });\n\t\tconst get_file = await drive.files.get(\n\t\t\t{\n\t\t\t\tfileId: fileId,\n\t\t\t\talt: 'media',\n\t\t\t},\n\t\t\t{ responseType: 'arraybuffer' } // Nhận dữ liệu dạng buffer\n\t\t);\n\n\t\tconst fileBuffer = Buffer.from(get_file.data); // Chuyển đổi sang Buffer\n\n\t\tconst res = {};\n\t\t// Cài đặt phản hồi HTTP\n\t\tres.headers = {\n\t\t\t'Content-Type': mimeType, // Loại nội dung\n\t\t\t'Content-Disposition': `attachment; filename=\"${fileName}\"`, // Tên file tải về\n\t\t};\n\t\t\n\t\tres.payload = fileBuffer; // Nội dung nhị phân\n\n\t\treturn msg; // Trả dữ liệu cho HTTP Response Node\n\t} catch (error) {\n\t\tmsg.payload = { error: error.message }; // Trả lỗi nếu có\n\t\tmsg.statusCode = 500; // HTTP lỗi\n\t\treturn msg;\n\t}\n}\n\nfunction urlToFileId(url) {\n\t// Biểu thức chính quy tìm ID từ webViewLink\n\tconst regex = /(?:\\/d\\/|id=)([\\w-]+)/;\n\tconst match = url.match(regex);\n\n\tif (match && match[1]) {\n\t\treturn match[1]; // Trả về ID nếu tìm thấy\n\t} else {\n\t\t// Trả về chính URL nếu không phải dạng hợp lệ\n\t\treturn url;\n\t}\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "f743403082220124",
        "type": "http in",
        "z": "7dba9e4b6a7d6c28",
        "name": "GET: check auth",
        "url": "/check_auth",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 1340,
        "y": 300,
        "wires": [
            [
                "8718b565e0fde575"
            ]
        ]
    },
    {
        "id": "8718b565e0fde575",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "check auth",
        "func": "const token = await global.get('drive_api').loadToken();\n\nif (token && token.expiry_date > Date.now()) {\n    node.warn('expiry > now');\n    msg.payload = `\n  <html>\n      <head>\n      <script type=\"text/javascript\">\n          window.close(); // Đóng cửa sổ sau khi hoàn tất\n      </script>\n      </head>\n      <body>\n          <h1>Đã hoàn thành thao tác!</h1>\n          <p>Vui lòng đóng cửa sổ này.</p>\n      </body>\n  </html>\n  `;\n\n    msg.headers = {\n        \"Content-Type\": \"text/html\"\n    };\n} else if (token && token.expiry_date < Date.now()) {\n    node.warn('expiry < now');\n    const refresh_token = await global.get('drive_api').refreshAccessToken();\n\n    msg.payload = `\n  <html>\n      <head>\n      <script type=\"text/javascript\">\n          window.close(); // Đóng cửa sổ sau khi hoàn tất\n      </script>\n      </head>\n      <body>\n          <h1>Đã hoàn thành thao tác!</h1>\n          <p>Vui lòng đóng cửa sổ này.</p>\n      </body>\n  </html>\n  `;\n\n    msg.headers = {\n        \"Content-Type\": \"text/html\"\n    };\n} else {\n    let authUrl = await global.get('drive_api').getAccessToken();\n\n    // TODO: báo cho admin để set file token.json\n    node.warn('token not exist');\n\n    msg.statusCode = 302; // Mã trạng thái chuyển hướng\n\n    // Chuyển hướng đến authUrl\n    msg.headers = {\n        location: authUrl\n    };\n\n    node.warn(authUrl);\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1530,
        "y": 300,
        "wires": [
            [
                "8b16bc1f5a151f74"
            ]
        ]
    },
    {
        "id": "8b16bc1f5a151f74",
        "type": "http response",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1700,
        "y": 300,
        "wires": []
    },
    {
        "id": "14c6f0ce1d89952a",
        "type": "http in",
        "z": "7dba9e4b6a7d6c28",
        "name": "call back get token",
        "url": "/google/getauth",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 1350,
        "y": 340,
        "wires": [
            [
                "ca1b14d023ee9f45"
            ]
        ]
    },
    {
        "id": "ca1b14d023ee9f45",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "set token",
        "func": "const code = msg.req.query.code;\nconst scope = msg.req.query.scope;\n\nnode.warn('Get code drive:');\n\nmsg.payload = { code, scope };\n\ntry {\n    const token = await global.get('drive_api').getTokenFromCode(code);\n\n    // Cập nhật trạng thái và phản hồi thành công\n    msg.statusCode = 302; // Mã trạng thái chuyển hướng\n    msg.headers = {\n        \"Content-Type\": \"text/html\"\n    };\n\n    msg.payload = `\n    <html>\n        <head>\n        <script type=\"text/javascript\">\n            window.close(); // Đóng cửa sổ sau khi hoàn tất\n        </script>\n        </head>\n        <body>\n            <h1>Đã hoàn thành thao tác!</h1>\n            <p>Cửa sổ sẽ tự động đóng sau khi hoàn tất thao tác.</p>\n        </body>\n    </html>\n  `;\n} catch (error) {\n    node.error('Error during token retrieval:', error);\n    msg.payload = {\n        error: 'Failed to retrieve token. Please try again.',\n    };\n    msg.statusCode = 500; // Nội dung lỗi\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1520,
        "y": 340,
        "wires": [
            [
                "39724a4e44c4cb04"
            ]
        ]
    },
    {
        "id": "39724a4e44c4cb04",
        "type": "http response",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1710,
        "y": 340,
        "wires": []
    },
    {
        "id": "0616a4e24162b838",
        "type": "comment",
        "z": "7dba9e4b6a7d6c28",
        "name": "google drive",
        "info": "- Tên project google trên /console.cloud.google.com : IRDOP Project\n- API service -> credentials -> mục OAuht 2.0 client ids có thông tin về webclient (gg_sec)\n\n- SCOPES: tương tự như quyền truy cập khi xác thực bằng tài khoản google:\n    -     'https://www.googleapis.com/auth/drive', // write + read\n    -     'profile','email' lấy thông tin tài khoản khi xác thực oauth2 \n\n- Authorized redirect URIs: danh sách callback url. sau khi xác thực bằng tài khoản google hợp lệ xong thì\nsẽ trả về url dựa trên uri được đưa vào oauth client, phần query của url đó chứa code dùng để lấy access_token\n\n- OAuth2Client: khởi tạo oauth2 dựa trên thông tin webclient (ggsec);\n\n- Access token: \n    -   tạo url để lấy code (param của func get token ) -> oauth2Client.getToken(code) return ra json;\n    -   sau khi có token thì thực hiện oauth2Client.setCredentials(token) -> set creden xong có thể thực hiện các thao tác trên google drive;\n    -   access token chỉ có hạn 1 tiếng, nên cần refresh lại sau khi hết hạn bằng refresh token có trong json\n        do refresh_token gần như không có hạn sử dụng (trừ khi rất lâu không dùng đến hoặc tạo ra quá 50 refresh token)\n        nên dữ liệu token json lưu tại file, khi refresh thì sẽ chỉ thay đổi giá trị access token ;\n\n- Thao tác với google drive qua const client = global.get('googleapis').drive({ version: 'v3', auth: authClient });\n    -   mỗi khi thực hiện thao tác cần check hạn của token (đọc file token_path), hết hạn thì refresh;\n    -   các thao tác file, folder như ở documentation của gg drive API hoặc hỏi AI tỉ lệ chính xác rất cao\n    -   hiện tại đang sử dụng shared drives của quantri@irdop để lưu file\n\n- Các GET trong node dùng để tạo lại file token.json thủ công trong trường hợp mất file token.json; \n",
        "x": 790,
        "y": 340,
        "wires": []
    },
    {
        "id": "a849a65e276ff4a8",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 980,
        "y": 600,
        "wires": [
            [
                "26a628a063cfafec"
            ]
        ]
    },
    {
        "id": "26a628a063cfafec",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "FileHub test save file",
        "func": "const oauth2 = global.get('drive_api');\n// global.get('drive_api').oauth2Client;\ntry{\n    await oauth2.checkExpiryGoogleDriveToken();\n    node.warn({ oauth2 });\n\n}catch{\n    node.warn({oauth2});\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 1200,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "89e9af936320f743",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 280,
        "wires": [
            [
                "15231732dbe799f3"
            ]
        ]
    },
    {
        "id": "b34386ba946ec421",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 340,
        "wires": [
            [
                "1143798f7d8e0f62"
            ]
        ]
    },
    {
        "id": "32fcc0fc54dcbbbe",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1430,
        "y": 600,
        "wires": [
            [
                "5e5f5e436c1cd5d7"
            ]
        ]
    },
    {
        "id": "5e5f5e436c1cd5d7",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "FileHub test get file",
        "func": "const { getFile } = global.get('fileHub');\ntry {\n        // create a file stream to filehub/file_7288954fc6eb47.csv\n        // const fs = global.get('fs').promises;\n        // const fileStream = fs.createReadStream('filehub/file_7288954fc6eb47.csv');\n        // node.warn(fileStream);\n\n        const file = { file_uid : 'file_7288954fc6eb47' };\n        const result = await getFile(file);\n        node.warn(result);\n} catch (err) {\n        node.error(err);\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 1640,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "98c80f2e31bc3d74",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "Telegram Layer",
        "func": "const tg_cache = {\n        isaInstance: {},\n        isaClient: {},\n        oatInstance: {},\n        oatClient: {},\n}\nglobal.set('tg_cache', tg_cache);\nglobal.set('tg_bot', {});\n\nclass Bot {\n        client;                  // telegram client instance\n        botPeer;                 // bot peerInfo\n\n        constructor(bot) {\n                this.botPeer = bot.peer;\n                this.client = bot.client;\n                const thisclient = this.client;\n        }\n\n        async init(client) {\n                try {\n                        this.client = client;\n                        return this.client;\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        async downloadMedia(message, callback) {\n                try {\n                        const mediaObject = message?.media;\n                        if (!mediaObject) return null;\n\n                        this.client.connect();                  // waking up the client\n\n                        const data = await this.client.downloadMedia(mediaObject, {\n                                progressCallback: (progress, total) => {\n                                        const percentage = (progress / total) * 100;\n                                        node.log(`Download Progress: ${percentage.toFixed(2)}%`);\n                                }\n                        });\n\n                        // this.client.disconnect();\n\n                        // Prepare file info\n                        const mimeType = mediaObject.photo ? 'image/png' :\n                                mediaObject.document ? mediaObject.document.mimeType : null;\n\n                        const fileName = mediaObject.document.attributes?.find(attr => attr.className === 'DocumentAttributeFilename')?.fileName;\n\n                        return {\n                                file_buffer: data,\n                                file_mime: mimeType,\n                                file_name: fileName\n                        };\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        isPrivateMessage(message) {\n                if (message?.peerId?.className === 'PeerUser') return true;\n                else return false;\n        }\n\n        async responseMessage(msgReceived, msgResponse) {\n                try {\n                        let sendingObject = {};\n                        let peer = msgReceived.peerId;\n\n                        // Prepare sending object\n                        if (typeof msgResponse === 'string') sendingObject.message = msgResponse;\n                        else if (typeof msgResponse === 'object' && msgResponse.message) sendingObject = msgResponse;\n                        else throw new Error('[ ERROR ] Bot cannot send message to user becasue invalid msgReceived object');\n\n                        // Send message\n                        const result = await this.client.sendMessage(peer, sendingObject);\n                        return result;\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        async selfMessaging(message) {\n                // check fromId same as bot peerInfo\n                return String(message?.fromId?.userId) === this.peerInfo.userId &&\n                        String(message.fromId?.className) === this.peerInfo.className;\n        }\n\n        static getPeerCode(peer) {\n                // return telegram peer's id in string format \n                if (peer.className === 'PeerUser') return String(peer.userId);\n                else if (peer.className === 'PeerChat') return String('-100' + peer.chatId);\n                else if (peer.className === 'PeerChannel') return String('-100' + peer.channelId);\n                else return null;\n        }\n}\n\nglobal.set('tg', {\n        Bot\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "telegram",
                "module": "telegram"
            },
            {
                "var": "mime",
                "module": "mime"
            }
        ],
        "x": 400,
        "y": 480,
        "wires": [
            [
                "b7bc51d52c5a44ed",
                "c42174e0940bd4c3"
            ]
        ],
        "icon": "node-red-node-telegrambot/telegram.png"
    },
    {
        "id": "b7bc51d52c5a44ed",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "ISA from telegram",
        "func": "const tg_cache = global.get('tg_cache');\nconst { Bot } = global.get('tg');\nconst Assistant = global.get('Assistant') //LabReportSubmitAssistant,SampleReceiptAssistant\n\nclass ISA extends Bot {\n        static relations = {\n                irdop_relation: {\n                        staff_admin: true,\n                        staff_superadmin: true,\n                        staff_customer_service: true,\n                },\n        }\n        static botPeer = {\n                userId: '7463030006',\n                className: 'PeerUser'\n        };\n        identity;\n        identity_uid;\n        peer;\n        channel;\n        peerCode;\n\n        available_commands = {\n                '/nkq': 'submit_test_result',\n                '/tnm': 'create_sample_receipt',\n                '/help': 'what_can_i_do',\n        }\n\n        context = {\n                context_id: null,\n                command: null,  // current context command\n                step: 0,     // current step of the command\n                is_busy: false,\n                is_available: true,\n                assistant: null,\n                is_still_thinking: false\n        }\n\n        constructor(userPeer, channelPeer) {\n                super({\n                        peer: ISA.botPeer,\n                        client: global.get('tg_cache')?.isaClient,\n                });   // calling parent class constructor\n                this.peer = userPeer;\n                this.channel = channelPeer;\n        }\n\n        async init() {\n                await super.init(global.get('tg_cache')?.isaClient);              // Tạo client nếu chưa có\n                const { getIdenByTelegramPeer } = global.get('idenRepo');\n                this.identity = await getIdenByTelegramPeer(this.peer);\n                this.identity_uid = this.identity?.identity_uid;\n                this.peerCode = Bot.getPeerCode(this.peer);                     // Lấy sẵn peerCode từ peerInfo\n        }\n\n        async response(message) {\n                try {\n                        let sendingObject = {};\n                        if (typeof message === 'string') sendingObject.message = message;\n                        else if (typeof message === 'object' && message.message) sendingObject = message;\n                        else throw new Error('[ ERROR ] ISA cannot send message to user becasue invalid msgReceived object');\n\n                        const result = await this.client.sendMessage(this.channel || this.peer, sendingObject);\n                        return result;\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        async newMessage(messages) {\n                try {\n                        // nếu user nhắn lệnh, xử lý lệnh\n                        if (this.isCommand(messages[0].message)) {\n                                await this.handleCommand(messages[0].message);\n                        }\n\n                        // Nếu đã có context, xử lý context\n                        await this.handleContext(messages);\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        isCommand(message) {\n                if (typeof message !== 'string') throw new Error('Message must be a string');\n                return message.startsWith('/');\n        }\n\n        async handleCommand(command) {\n                if (this.isCommand(command)) {\n                        this.reset_context();\n                        if (!this.available_commands[command]) {\n                                await this.response('Không biết lệnh này');\n                                this.reset_context();\n                                return;\n                        }\n\n                        return this.new_context(command);\n                }\n        }\n\n        async handleContext(messages) {\n                switch (this.context.command) {\n                        case '/nkq':\n                                await this.submit_test_result(messages);\n                                break;\n                        case '/tnm':\n                                await this.create_sample_receipt(messages);\n                                break;\n                        default:\n                                await this.response('Bạn cần làm gì bây giờ?');\n                                break;\n                }\n        }\n\n        async submit_test_result(messages) {\n                try {\n                        // ISA đang bận\n                        if (this.context.is_busy) {\n                                await this.im_busy();\n                                return;\n                        }\n\n                        // Tạo assistant nếu chưa có\n                        if (!this.context.assistant) this.context.assistant = new Assistant.LabReportSubmit(39); \n\n                        // ISA dành quyền xử lý\n                        this.context.is_busy = true;\n\n                        // 1: Prompt user nhập kết quả thử nghiệm và xử lý\n                        if (this.context.step === 0 || !this.context.step) {\n                                // await this.context.assistant.create();\n                                await this.response('Vui lòng gửi kết quả thử nghiệm');\n                                this.context.step = 1;\n                                this.context.is_busy = false;\n                                return;\n                        }\n                        // 2. Bridge user and assistant\n                        else if (this.context.step >= 1) {\n                                this.context.is_busy = true;    // ISA dành quyền xử lý\n                                let asst_response;              // Phản hồi của assistant\n                                let user_text = '';             // Text của user\n                                let user_medias = [];           // Media của user\n\n                                // Chuẩn bị dữ liệu cho assistant\n                                for (const message of messages) {\n                                        // Tải file từ Telegram\n                                        if (message?.media) {\n                                                let this_media = await this.downloadMedia(message);\n                                                this_media.created_by_uid = this.identity_uid;\n                                                const record = await global.get('fileHub').saveFileData(this_media, true); // rethrow error\n                                                user_medias.push(record);\n                                        }\n\n                                        // Nối text từ chuỗi tin nhắn của user\n                                        else if (message?.message) user_text = user_text + \" \\n \" + message.message;\n                                }\n                                if (user_medias.length > 0) {\n                                        // prompt không được để trống \n                                        user_text = 'Phân tích danh sách file, đưa ra mã mẫu và các kết quả của chất thử theo yêu cầu: ' + user_text;\n                                        await this.response(\"Bắt đầu xuất thông tin từ file ...\");\n                                }\n                                // Gửi dữ liệu tin nhắn của user đến assistant\n                                // asst_response = await this.context.assistant.newPrompt(user_medias, user_text, async (response) => {\n                                //         // Mảng giới hạn độ dài từng cột\n                                //         const maxLengths = [15, 30, 10, 10]; // uid: 15 ký tự, name: 30 ký tự, ...\n\n                                //         // Chuyển JSON thành bảng\n                                //         const table = jsonToTableWithMaxLength(response?.analyte_matches, maxLengths);\n                                        \n                                //         // // if assistant is still thinking\n                                //         // if (response?.user_message?.is_still_thinking) this.context.is_busy = true;\n                                //         const results = `${response?.analyte_matches.map(\n                                //                 analyte_match => `\\n${analyte_match.sample_uid} - ${analyte_match.test_name} - ${analyte_match.result_value} - ${analyte_match.result_unit}`\n                                //         )}`\n                                //         // nhắn tin tới user\n                                //         if (response?.user_message?.text) {\n                                //                 await this.response(`${response.user_message.text}\\n${results}`);\n                                //                 await this.response(table)\n                                //         }\n\n                                //         // // assistant prompt lại user\n                                //         // if (response?.user_message?.no_reply) {\n                                //         //         this.context.step = 1;\n                                //         //         this.context.is_busy = false;\n                                //         //         this.context.is_still_thinking = false;\n                                //         //         return;\n                                //         // }\n\n                                //         // Nếu assistant commit hoặc cancel kết quả -> reset context\n                                //         if (response?.type === 'commit_this_result' || response?.type === 'cancel_request') {\n                                //                 node.warn(\"reset context\");\n                                //                 this.reset_context();\n                                //                 return;\n                                //         }\n                                //         this.context.is_busy = false;\n\n                                // });\n                \n                        }\n\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        async what_can_i_do(messages) {\n                await this.response(\"Tôi là trợ lý nội bộ. Để nộp kết quả thử nghiệm nhắn: /nkq\");\n        }\n\n        reset_context() {\n                this.context.context_id = null;\n                this.context.command = null;\n                this.context.step = null;\n                this.context.is_busy = false;\n                this.context.is_available = true;\n                this.context.assistant = null;\n                this.context.is_still_thinking = false;\n        }\n\n        new_context(command) {\n                this.reset_context();\n\n                // set new context\n                this.context.context_id = Date.now();\n                this.context.command = command;\n        }\n\n        async im_busy() {\n                await this.response('ISA đang bận xử lý, vui lòng kiên nhẫn hoặc /start để bắt đầu lại');\n        }\n\n        static async getInstance(peer) {\n                try {\n                        // check permission\n                        const isAuthorized = await ISA.checkPermission(peer);\n                        if (!isAuthorized) return null;\n\n                        // lấy instance theo peerCode\n                        const peerCode = ISA.getPeerCode(peer);\n                        if (!peerCode) throw new Error('[ERROR] BotISA cannot get peerCode');\n\n                        // Trả về cache nếu có hoặc tạo mới instance và set cache\n                        const instance = ISA.getCache(peer) ? ISA.getCache(peer) : ISA.create_isa_instance(peer);\n                        ISA.setCache(peer, instance);\n                        return instance;\n\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        static async create_isa_instance(peer) {\n                const isa = new ISA(peer);\n                await isa.init();\n                return isa;\n        }\n\n        static async checkPermission(identityOrPeer) {\n                try {\n                        if (!this.relations) return true;                               // this bot is public\n                        if (this.relations && !identityOrPeer) return false;            // invalid identity found\n                        const AUTH = global.get('AUTH');\n                        let identity;\n\n                        // Lấy identity\n                        if (typeof identityOrPeer === 'string') identity = await AUTH.get_identity_by_uid(identityOrPeer);\n                        else if (identityOrPeer?.className) identity = await AUTH.get_identity_by_tg(identityOrPeer);\n                        else if (identityOrPeer?.identity_uid) identity = await AUTH.get_identity_by_uid(identityOrPeer.identity_uid);\n\n                        // lấy identity thất bại\n                        if (!identity) return false;\n\n                        // Check for matching relations\n                        for (const bot_relation of Object.keys(this.relations)) {\n                                if (identity[bot_relation]) {\n                                        for (const role of Object.keys(this.relations[bot_relation])) {\n                                                if (identity[bot_relation][role] && this.relations[bot_relation][role] == true) return true;\n                                        }\n                                }\n                        }\n\n                        // không có quyền\n                        return false;\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        static getCache(peer, expires = 1000 * 60 * 60 * 2) {\n                try {\n                        const peerCode = typeof peer === 'object' && peer.className ? ISA.getPeerCode(peer) : peer;\n                        const tg_cache = global.get('tg_cache');\n\n                        if (!tg_cache?.isaInstance) return null;\n                        if (!peerCode) throw new Error('[ERROR] BotISA cannot get cache without peer info');\n\n                        if (!tg_cache.isaInstance[peerCode] || Date.now() > tg_cache.isaInstance[peerCode].created_at + expires) {\n                                delete tg_cache.isaInstance[peerCode];\n                                return null;\n                        }\n                        return tg_cache.isaInstance[peerCode].value || null;\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        static setCache(peer, instance) {\n                try {\n                        // make sure using peer code\n                        const peerCode = typeof peer === 'object' && peer.className ? ISA.getPeerCode(peer) : peer;\n                        const tg_cache = global.get('tg_cache');\n\n                        if (!peerCode || !instance) throw new Error('[ERROR] BotISA requires both peerCode and instance value');\n                        if (!tg_cache) throw new Error('[ERROR] BotISA requires tg_cache library initialized');\n                        if (!tg_cache.isaInstance) tg_cache.isaInstance = {};\n\n                        tg_cache.isaInstance[peerCode] = {\n                                value: instance,\n                                created_at: Date.now(),\n                        };\n                        return tg_cache.isaInstance[peerCode].value;\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n\n        static selfMessaging(message) {\n                node.warn({message});\n                return String(message?.fromId?.userId) === ISA.botPeer.userId\n                        && String(message?.fromId?.className) === ISA.botPeer.className;\n        }\n\n        static async coldResponseMessage(messageReceived, text) {\n                // response mà không cần tạo instance\n                try {\n                        let client = global.get('tg_cache')?.isaClient;\n                        if (!client) {\n                                node.warn(\"Unable to cold response message because Telegram client is not available\");\n                                return;\n                        }\n                        const peer = messageReceived?.peerId;\n                        const message = { message: text };\n                        if (!peer) throw new Error('[ERROR] Message received does not have peerId');\n                        return await client.sendMessage(peer, message);\n                } catch (error) {\n                        node.warn(error.stack);\n                }\n        }\n}\n\nfunction jsonToTableWithMaxLength(jsonData, maxLengths) {\n    // Nếu dữ liệu đầu vào là object đơn lẻ, chuyển thành mảng chứa object đó\n    if (!Array.isArray(jsonData)) {\n        jsonData = [jsonData];\n    }\n\n    // Kiểm tra nếu mảng rỗng\n    if (jsonData.length === 0) {\n        return \"\"; // Trả về chuỗi rỗng nếu không có dữ liệu\n    }\n\n    // Lọc bỏ các key là \"id\"\n    const headers = Object.keys(jsonData[0]).filter((key) => key.toLowerCase() !== \"id\");\n\n    // Tạo dòng tiêu đề với khoảng cách tối đa\n    const headerRow = headers\n        .map((header, index) => padText(header, maxLengths[index]))\n        .join(' | ');\n\n    const addRepeat = (index) => {\n        if( index === maxLengths.length - 1 || index === 0 ) return 1 \n                                                        else return 2 \n        }\n\n    // Tạo dòng phân cách\n    const separator = headers.map((_, index) => '-'.repeat(maxLengths[index] + addRepeat(index) )).join('|');\n\n    // Tạo các dòng dữ liệu\n    const rows = jsonData.map((row) => {\n        const wrappedColumns = headers.map((header, index) =>\n            wrapText(String(row[header] || \"\"), maxLengths[index])\n        );\n\n        // Ghép các cột lại, đảm bảo các dòng được căn chỉnh\n        return mergeRows(wrappedColumns, maxLengths);\n    });\n\n    // Gộp tất cả thành một bảng\n    return [headerRow, separator, ...rows].join('\\n');\n}\n\n// Hàm cắt chuỗi thành nhiều dòng nếu vượt quá maxLength\nfunction wrapText(text, maxLength) {\n    const lines = [];\n    while (text.length > maxLength) {\n        lines.push(text.slice(0, maxLength)); // Cắt một đoạn có độ dài tối đa\n        text = text.slice(maxLength); // Cập nhật phần còn lại\n    }\n    lines.push(text); // Thêm dòng cuối cùng\n    return lines;\n}\n\n// Hàm căn chỉnh dòng của mỗi cột\nfunction mergeRows(wrappedColumns, maxLengths) {\n    const numRows = Math.max(...wrappedColumns.map((col) => col.length));\n    const paddedRows = [];\n\n    for (let i = 0; i < numRows; i++) {\n        const row = wrappedColumns\n            .map((col, index) =>\n                padText(col[i] || '', maxLengths[index]) // Đệm chuỗi để đảm bảo độ dài\n            )\n            .join(' | ');\n        paddedRows.push(row);\n    }\n\n    return paddedRows.join('\\n');\n}\n\n// Hàm đệm chuỗi để đảm bảo độ dài cố định\nfunction padText(text, maxLength) {\n    return text.padEnd(maxLength, ' '); // Đệm khoảng trắng ở bên phải\n}\n\n// init ISA BOT client\nasync function initISA() {\n        try {\n                // skip if already initialized\n                if (tg_cache?.isaClient?.__version__) {\n                        node.warn(\"Telegram ISA bot client already initialized\");\n                        return tg_cache.isaClient;\n                }\n\n                const { Api, TelegramClient } = global.get('telegram');\n                tg_cache.isaClient = new TelegramClient(\n                        'isa',\n                        22024369,\n                        '806bc37467da40f1b3dec1f98b1d74d5',\n                        { connectionRetries: 5 }\n                );\n                await tg_cache.isaClient.start({ botAuthToken: '7463030006:AAHXL4AkzdtOqWXDN9cghVC0l4b29l6Mmpc' });\n                tg_cache.isaClient.session.save();\n                node.warn(\"[ SUCCESS ] Telegram ISA bot client initialized\");\n                return tg_cache.isaClient;\n        } catch (error) {\n                node.warn(error.stack);\n        }\n}\nawait initISA();\n\nglobal.get('tg_bot').ISA = ISA;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 480,
        "wires": [
            []
        ],
        "icon": "node-red-node-telegrambot/telegram.png"
    },
    {
        "id": "ae7ca6abad98b48a",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "Restart TG",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 480,
        "wires": [
            [
                "98c80f2e31bc3d74"
            ]
        ]
    },
    {
        "id": "c42174e0940bd4c3",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "OAT from telegram",
        "func": "const tg_cache = global.get('tg_cache');\nconst { Bot } = global.get('tg');\n\n// zalo OA-telegram bot\nclass OAT {\n        // Permission settings\n        static relations = {\n                irdop_relation: {\n                        staff_bot: true,\n                        staff_customer_service: true,\n                }\n        }\n\n        // Telegram data\n        static botPeer = {};\n        static channelPeer = {channelId: \"2295380821\", className: \"PeerChannel\"};\n        tgClient = {};\n        tgTopic = {};\n\n        // Zalo data\n        static app_id; oa_id;\n        zalo_user_id;\n\n        // Context data\n        context = { zalo_user_id: null, topic_id: null, };\n\n        constructor() {\n                this.tgClient = global.get('tg_cache')?.oatClient;\n        }\n\n        async init() {\n                // Add your initialization logic here if needed\n        }\n\n        static async getInstance(tgMessage, zalo_event) {\n                if (tgMessage && !zalo_event) {\n                }\n                else if (zalo_event && !tgMessage) {\n                }\n                else {\n                        throw new Error(\"Invalid arguments\");\n                }\n        }\n\n        async createTgTopic(tgMessage, zalo_event) {\n                // create new topic\n                const { Api } = global.get('telegram');\n                // this.tgTopic = await this.tgClient.invoke(new Api.channels.CreateForumTopic({\n                //         channel: OAT.channelPeer,\n                //         title: \"New topic\",\n                //         icon_color: 0,\n                //         icon_emoji_id: 0,\n                // }));\n                node.warn({tgTopic: this.tgTopic});\n                node.warn({Api});\n                return this.tgTopic;\n        }\n\n        static getText(zalo_event) {\n                const textingEvents = [\"anonymous_send_text\", \"oa_send_anonymous_text\"];\n                if (textingEvents.includes(zalo_event?.event_name)) {\n                        return zalo_event?.message?.text;\n                }\n                else return null;\n        }\n}\n\n\n// Init OAT bot\nasync function initOAT() {\n        try {\n                // Already initialized\n                if (tg_cache?.oatClient?.__version__) {\n                        node.warn(\"[ INFO ] Telegram OAT bot client already initialized\");\n                        return tg_cache.oatClient;\n                }\n\n                // Create new telegram client\n                const { Api, TelegramClient } = global.get('telegram');\n                tg_cache.oatClient = new TelegramClient(\n                        'oa_zalo_bot',\n                        22024369,\n                        '806bc37467da40f1b3dec1f98b1d74d5',\n                        { connectionRetries: 5 }\n                );\n                await tg_cache.oatClient.start({ botAuthToken: '8142388543:AAEQFPMRrlbo0SdgOfrIyqHDsizZN2MjD0w' });\n                tg_cache.oatClient.session.save();\n\n                node.warn(\"[ SUCCESS ] Telegram OAT bot client initialized\");\n                return tg_cache.oatClient;\n        } catch (error) {\n                node.warn(error.stack);\n        }\n}\nawait initOAT();\nconst tg_bot = global.get('tg_bot').OAT = OAT;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 520,
        "wires": [
            []
        ],
        "icon": "node-red-node-telegrambot/telegram.png"
    },
    {
        "id": "2a7de89ea59313c3",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "Zalo OA",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 600,
        "wires": [
            [
                "505925a198a9f07b"
            ]
        ]
    },
    {
        "id": "505925a198a9f07b",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "OAT from Zalo OA",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "30532c442c55f6e4",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 910,
        "y": 480,
        "wires": [
            [
                "4a63b8a92ce3e569"
            ]
        ]
    },
    {
        "id": "4a63b8a92ce3e569",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "Create topic",
        "func": "const { OAT } = global.get('tg_bot');\n\n\nconst oat = new OAT();\noat.createTgTopic();\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "c369eb47ba0e32d9",
        "type": "inject",
        "z": "7dba9e4b6a7d6c28",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 780,
        "y": 740,
        "wires": [
            [
                "1cd957815fea9997"
            ]
        ]
    },
    {
        "id": "1cd957815fea9997",
        "type": "function",
        "z": "7dba9e4b6a7d6c28",
        "name": "function 13",
        "func": "const thing = global.get('ERROR').HTTP_400;\nnode.warn({thing});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1020,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "2d0a9ce41514f415",
        "type": "inject",
        "z": "90c138ec34557557",
        "name": "Main",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.001",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 100,
        "wires": [
            [
                "cc43bd49c8749500"
            ]
        ]
    },
    {
        "id": "cc43bd49c8749500",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "Auth Repository",
        "func": "const { Pool } = global.get('pg');\nconst error = global.get('ERROR');\n\n// CONNECTING TO AUTH DB\n(async () => {\n        try {\n                const pool = new Pool(JSON.parse(env.get('identityDB')));\n                if (await testConnection()) {\n                        node.warn('[ INFO ] IDEN DB pool already connected');\n                }\n                else {\n                        await pool.connect();\n                        node.warn('[ SUCCESS ] IDEN DB pool connected');\n                }\n                global.set('idenRepoClient', pool);\n        } catch (error) {\n                // Log additional information about the error\n                node.warn(`[ IDEN REPO ERROR ] IDEN DB connection failed:\\n ${error.stack}`);\n        }\n})();\n\nconst repo = global.get('idenRepoClient');\n\n// CRUD FUNCTIONS\nasync function verifyPassword(identity, tryingPassword, rethrow) {\n        try {\n                const bcrypt = global.get('bcrypt');\n                const email = identity?.email;\n                const identity_uid = identity?.identity_uid;\n\n                if (!tryingPassword || (!email && !identity_uid)) throw error.HTTP_400('Missing inputs');\n\n                // Lấy identity qua email\n\n                // Lấy password đã hash\n                const hashedPassword = await getIdenHashedPassword(identity, rethrow);\n                if (!hashedPassword) throw error.HTTP_403('Access Denied');\n\n                // So sánh password\n                const isMatch = await bcrypt.compare(tryingPassword, hashedPassword);\n                if (!isMatch) throw error.HTTP_403('Access Denied');        \n\n                // return  full identity\n                const full_identity = await getIden(identity, rethrow);\n                return full_identity;\n        } catch (error) {\n                handleError(error, 'verifyPassword', rethrow);\n        }\n}\n\nasync function getIden(identity, rethrow) {\n        try {\n                const identity_uid = identity?.identity_uid;\n                const email = identity?.email;\n                if (!identity_uid && !email) throw error.HTTP_400('Missing input of uid or email');\n\n                // query by any or all of uid and email\n                let query = 'SELECT * FROM identities WHERE ';\n                const params = [];\n                const conditions = [];\n\n                if (identity_uid) {\n                        conditions.push(`identity_uid = $${params.length + 1}`);\n                        params.push(identity_uid);\n                }\n                if (email) {\n                        conditions.push(`email = $${params.length + 1}`);\n                        params.push(email);\n                }\n\n                query += conditions.join(' AND ');\n\n                const result = await repo.query(query, params);\n\n                if (result?.rows?.length === 0) return null;\n                else {\n                        const identity = result.rows[0];\n                        delete identity.password;\n                        const relations = await getRelationByIden(identity);\n\n                        // Merging key-value pairs from relations into the identity object\n                        relations.forEach(relation => {\n                            Object.entries(relation).forEach(([key, value]) => {\n                                identity[key] = value; // Assign each key-value pair to identity\n                            });\n                        });\n\n                        identity.className = 'Identity';\n                        return identity;\n                }\n        } catch (error) {\n                handleError(error, 'getIden', rethrow);\n        }\n}\n\nasync function getIdenByUid(uid, rethrow) {\n        try {\n                const query = 'SELECT * FROM identities WHERE identity_uid = $1';\n                const params = [uid];\n                const result = await repo.query(query, params);\n\n                if (result?.rows?.length === 0) return null;\n                else {\n                        const identity = result.rows[0];\n                        delete identity.password;\n                        const relations = await getRelationByIden(identity);\n                        Object.assign(identity, relations);\n                        return identity;\n                }\n        } catch (error) {\n                handleError(error, 'getIdentityByUid', rethrow);\n        }\n}\n\nasync function getIdenHashedPassword(identity, rethrow) {\n        try {\n                const identity_record = await getIden(identity, rethrow);\n                if (!identity_record) throw error.HTTP_404('Access Denied');\n\n                // get hashed\n                const query = 'SELECT password FROM identities WHERE identity_uid = $1';\n                const params = [identity_record.identity_uid];\n                const result = await repo.query(query, params);\n\n                // return hashed\n                if (result?.rows?.length === 0) throw error.HTTP_404('Access Denied');\n                else return result.rows[0].password;\n        } catch (error) {\n                handleError(error, 'getIdenHashedPassword', rethrow);\n        }\n}\n\nasync function getRelation(relationId, rethrow) {\n        try {\n                const query = `SELECT * FROM relations WHERE id = $1`;\n                const params = [relationId];\n                const result = await repo.query(query, params);\n                if (result?.rows?.length === 0) return null;\n                else return result.rows[0];\n        } catch (error) {\n                handleError(error, 'getRelation', rethrow);\n        }\n}\n\nasync function getRelationByName(relationName, rethrow) {\n        try {\n                const query = `SELECT * FROM relations WHERE relation_name = $1`;\n                const params = [relationName];\n                const result = await repo.query(query, params);\n                return result?.rows[0];\n        } catch (error) {\n                handleError(error, 'getRelationByName', rethrow);\n        }\n}\n\nasync function getRelationByIden(identity, rethrow) {\n        try {\n                const identity_uid = identity?.identity_uid;\n                if (!identity_uid) throw error.HTTP_400('Missing input of identity_uid');\n\n                // Get all unique relations and their roles of identity in one query\n                const query = `\n                    SELECT DISTINCT r.*, ir.roles \n                    FROM relations r\n                    JOIN identity_roles ir ON r.id = ir.relation_id \n                    WHERE ir.identity_uid = $1\n                `;\n                const params = [identity_uid];\n                const result = await repo.query(query, params);\n                \n                // Check if any relations were found\n                if (!result.rows || result.rows.length === 0) {\n                    return []; // Return an empty array if no relations found\n                }\n\n                // Extract relations and roles from the result\n                const relationNameRoles = result.rows.map(row => {\n                    return {\n                        [row.relation_name]: row.roles // Directly assign roles as a JSONB object\n                    };\n                });\n                return relationNameRoles;\n        } catch (error) {\n                handleError(error, 'findIdenRelation', rethrow);\n        }\n}\n\nasync function findRelationByIden(identity_uid, rethrow) {\n        try {\n                // Query to find relations and roles for a given identity\n                const query = `\n                        SELECT r.relation_name, ir.roles\n                        FROM identity_roles ir\n                        JOIN relations r ON ir.relation_id = r.id\n                        WHERE ir.identity_uid = $1\n                `;\n                const params = [identity_uid];\n                const result = await repo.query(query, params);\n\n                if (result.rows.length === 0) return null;\n\n                // Reduce the result rows to an object with relation names as keys and roles as values\n                const relations = result.rows.reduce((acc, row) => {\n                        acc[row.relation_name] = row.roles;\n                        return acc;\n                }, {});\n\n                return relations;\n        } catch (error) {\n                if (rethrow) throw error;\n                else return null;\n        }\n}\n\nasync function getIdenByTelegramPeer(peerInput, rethrow) {\n        try {\n                // convert peerInput to peerDb\n                const peerDb = convertPeerDB(peerInput);\n\n                if (!peerDb) return null;\n\n                // find identity_uid by telegram_peer JSONB and return full identity\n                const query = 'SELECT * FROM identities WHERE telegram_peer @> $1';\n                const params = [JSON.stringify(peerDb)];\n                const result = await repo.query(query, params);\n\n                if (result?.rows?.length === 0) return null;\n                else {\n                        const full_identity = await getIden({ identity_uid: result.rows[0].identity_uid });\n                        return full_identity;\n                }\n        } catch (error) {\n                handleError(error, 'getIdenByTelegramPeer', rethrow);\n        }\n}\n\nasync function createIden(identity, rethrow) {\n        try {\n                await repo.query('BEGIN'); // Start a transaction\n                const bcrypt = global.get('bcrypt');\n\n                if (identity?.identity_name && identity?.email) {\n                        identity.identity_uid = await generateIdenUid();\n                        identity.password = await bcrypt.hash(identity.password, 12);\n                        identity.security = {};\n                        delete identity.discord_snowflake;      // not implemented yet\n\n                        // nếu có telegram_peer, tạo peer\n                        if (identity?.telegram_peer && Object.keys(identity.telegram_peer).length > 1) {\n                                const peerDb = convertPeerDB(identity.telegram_peer);\n                                if (!peerDb) throw error.HTTP_400(`Invalid input of telegram_peer: ${JSON.stringify(identity.telegram_peer)}`);\n                                identity.telegram_peer = peerDb;\n                        }\n\n                        // Match Identity Schema\n                        const validColumns = await matchValidColumns('identities', Object.keys(identity));\n\n                        const validIdentity = Object.fromEntries(\n                                Object.entries(identity).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Check if the number of valid columns matches the number of parameters\n                        if (validColumns.length !== Object.keys(validIdentity).length) {\n                        throw error.HTTP_400('Mismatch between columns and parameters');\n                        }\n\n                        // Tạo Identity Record\n                        const query = `INSERT INTO identities (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = validColumns.map(column => validIdentity[column]);\n                        const result = await repo.query(query, params);\n\n                        // Tạo Relation và Role\n                        // lấy tất cả key có _relation\n                        const relations = Object.keys(identity).filter(key => key.endsWith('_relation'));\n\n                        // Lấy relation record và tạo role cho relation và iden\n                        for (const relation of relations) {\n                                let relation_record = await getRelationByName(relation);\n                                if (!relation_record) {\n                                        relation_record = await createRelation({ relation_name: relation });\n                                        if (!relation_record) throw error.HTTP_400(`Failed to create relation: ${relation}`);\n                                }\n                                // sau đó tạo role cho relation và iden\n                                const new_role = await createIdenRole({ \n                                        identity_uid: result.rows[0].identity_uid, \n                                        relation_id: relation_record.id, \n                                        roles: identity[relation] });\n                                if (!new_role) throw error.HTTP_400(`Failed to create role: ${relation}`);\n                        }\n\n                        await repo.query('COMMIT'); // Commit the transaction\n\n                        // lấy về tổng hợp identity\n                        const new_identity = await getIdenByUid(result.rows[0].identity_uid);\n                        // Trả về kết quả\n                        if (!new_identity) return null;\n                        else return {\n                                ...new_identity,\n                                className: 'Identity'\n                        };\n                }\n                else throw error.HTTP_400(`Missing input of name: ${identity.identity_name}, email: ${identity.email}, or password`);\n        } catch (error) {\n                await repo.query('ROLLBACK'); // Rollback the transaction on error\n                handleError(error, 'createIden', rethrow);\n        }\n}\n\nasync function createRelation(relation, rethrow) {\n        try {\n                if (relation.relation_name) {\n                        const validColumns = await matchValidColumns('relations', Object.keys(relation));\n                        const validRelation = Object.fromEntries(\n                                Object.entries(relation).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        const query = `INSERT INTO relations (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = [...validColumns.map(column => validRelation[column])];\n                        const result = await repo.query(query, params);\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'Relation'\n                        };\n                }\n                else throw error.HTTP_400(`Missing input of name: ${relation.relation_name}`);\n        } catch (error) {\n                if (rethrow) throw error;\n                else return null;\n        }\n}\n\nasync function createIdenRole(identityRole, rethrow) {\n        try {\n                // Must have identity_uid and relation_id\n                if (identityRole.identity_uid && identityRole.relation_id) {\n                        const validColumns = await matchValidColumns('identity_roles', Object.keys(identityRole));\n                        const validIdentityRole = Object.fromEntries(\n                                Object.entries(identityRole).filter(([key]) => validColumns.includes(key))\n                        );\n\n                        // Dựng query và thực thi\n                        const query = `INSERT INTO identity_roles (${validColumns.join(',')}) VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')}) RETURNING *`;\n                        const params = [...validColumns.map(column => validIdentityRole[column])];\n                        const result = await repo.query(query, params);\n\n                        // Trả về kết quả\n                        if (result?.rowCount === 0) return null;\n                        else return {\n                                ...result.rows[0],\n                                className: 'IdentityRole'\n                        };\n                }\n                else throw error.HTTP_400(`Missing input of identity_uid: ${identityRole.identity_uid}, or relation_id: ${identityRole.relation_id}`);\n        } catch (error) {\n                handleError(error, 'createIdentityRole', rethrow);\n        }\n}\n\nasync function delIden(identity, rethrow) {\n        try {\n                const identity_uid = identity?.identity_uid;\n                if (!identity_uid) throw error.HTTP_400('Missing input of identity_uid');\n\n                await repo.query('BEGIN'); // Start a transaction\n\n                // delete identity_roles\n                const deleteRolesQuery = 'DELETE FROM identity_roles WHERE identity_uid = $1';\n                const params = [identity_uid];\n                await repo.query(deleteRolesQuery, params);\n\n                // delete identity\n                const deleteIdentityQuery = 'DELETE FROM identities WHERE identity_uid = $1';\n                await repo.query(deleteIdentityQuery, params);\n\n                await repo.query('COMMIT'); // Commit the transaction\n                return { success: true }; // Return a success response\n        } catch (error) {\n                await repo.query('ROLLBACK'); // Rollback the transaction on error\n                handleError(error, 'delIden', rethrow);\n        }\n}\n\n// FUNCTION HELPERS\nasync function matchValidColumns(table_name, columns) {\n        try {\n                /** 1. Get table columns from server */\n                // Construct the SQL query to get the column names from the information schema\n                const validColumnsQuery = `SELECT column_name FROM information_schema.columns WHERE table_name = $1`;\n                const validColumnsParams = [table_name];\n\n                // Execute the SQL query;\n                const validColumnsResult = await repo.query(validColumnsQuery, validColumnsParams);\n\n                // Extract the column names from the query result\n                const validColumns = validColumnsResult.rows.map((row) => row.column_name);\n\n                /** 2. Match columns */\n                // Filter the input columns to include only valid columns\n                const matchedColumns = columns.filter((column) => validColumns.includes(column));\n\n                // Return the matched columns\n                return matchedColumns || []; // if no match return []\n        } catch (error) {\n                handleError(error, 'matchValidColumns');\n                return [];\n        }\n}\n\nasync function handleError(error, function_name, rethrow) {\n        node.warn(`[ IDEN REPO ERROR ] ${function_name}: ${error.stack}`);\n        if (rethrow) throw error;\n        else return null;\n}\n\nasync function generateIdenUid() {\n        // 'IDx' 5 random hexadecimal characters (0-9, a-f)\n        const uid = 'IDx' + [...Array(5)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');\n        return uid;\n}\n\nfunction convertPeerDB(peerInput) {\n        // convert peerInput to peerDb\n        const peerDb = {\n                ...(peerInput?.userId && { userId: String(peerInput.userId) }),\n                ...(peerInput?.chatId && { chatId: String(peerInput.chatId) }),\n                ...(peerInput?.channelId && { channelId: String(peerInput.channelId) }),\n                className: peerInput?.className,\n        };\n        if (!peerInput?.className || (!peerInput?.userId && !peerInput?.chatId && !peerInput?.channelId)) return null;\n        return peerDb;\n}\n\nasync function convertPeerTelegram(peerDb) {\n        // convert peerDb to peerTelegram\n        const peerTelegram = {\n                ...(peerDb?.userId && { userId: peerDb.userId }),\n                ...(peerDb?.chatId && { chatId: peerDb.chatId }),\n                ...(peerDb?.channelId && { channelId: peerDb.channelId }),\n                className : peerDb?.className,\n        };\n        return peerTelegram;\n}\n\nasync function testConnection() {\n        try {\n                const client = global.get('idenRepoClient');\n                const result = await client.query('SELECT 1');\n                if (result) return true; // return true if connected\n        } catch (error) {\n                return false;\n        }\n}\n\nasync function disconnect() {\n        const pool = global.get('idenRepoClient');\n        await pool.end();\n        global.set('idenRepoClient', undefined);\n}\n\nglobal.set('idenRepo', {\n        getIden,\n        getIdenByUid,\n        getIdenByTelegramPeer,\n        verifyPassword,\n        findRelationByIden,\n        getRelationByIden,\n        createIden,\n        createRelation,\n        createIdenRole,\n        delIden,\n        testConnection,\n        disconnect\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 100,
        "wires": [
            [
                "2147317cbbcbaff7"
            ]
        ]
    },
    {
        "id": "2147317cbbcbaff7",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "Auth Cache",
        "func": "const authCache = {};\nglobal.set('authCache', authCache);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "62bbd125396287cf",
        "type": "comment",
        "z": "90c138ec34557557",
        "name": "PostgreSQL",
        "info": "-- PostgreSQL\n-- table for identity\nCREATE TABLE identities (\n    id SERIAL PRIMARY KEY,\n    identity_uid VARCHAR(20) NOT NULL,\n    identity_name VARCHAR(255) NOT NULL,\n    identity_contact TEXT,\n    email VARCHAR(255) NOT NULL,\n    password VARCHAR(255) NOT NULL\n    security JSONB,\n);\n\nCREATE TABLE relations (\n    id SERIAL PRIMARY KEY,\n    relation_name VARCHAR(255) NOT NULL,\n    relation_description TEXT,\n);\n\nCREATE TABLE identity_roles (\n    id SERIAL PRIMARY KEY,\n    identity_id INT NOT NULL REFERENCES identities(id),\n    relation_id INT NOT NULL REFERENCES relations(id),\n    roles JSONB,\n);",
        "x": 590,
        "y": 60,
        "wires": []
    },
    {
        "id": "c1ea6e6ecff71f3d",
        "type": "inject",
        "z": "90c138ec34557557",
        "name": "Test",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 570,
        "y": 160,
        "wires": [
            [
                "e5f9853c5260678a"
            ]
        ]
    },
    {
        "id": "e5f9853c5260678a",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "Iden DB Connection",
        "func": "// test connection from external node\nconst { testConnection } = global.get('idenRepo');\nnode.warn(`IDENTITY Database connection: ${await testConnection()}`);\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "8dab04af3ba52bfd",
        "type": "inject",
        "z": "90c138ec34557557",
        "name": "new-iden",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 240,
        "wires": [
            [
                "d7a96ec77f828217"
            ]
        ]
    },
    {
        "id": "d7a96ec77f828217",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "done",
        "func": "const { createIden } = global.get('idenRepo');\n\ntry {\n        // const xtruong = await createIden({\n        //         identity_name: 'Xuan Truong',\n        //         email: 'abc@xuantruong.xyz',\n        //         password: 'password123',\n\n        //         irdop_relation: {       // a relation flag always end with _relation\n        //                 staff: true,\n        //                 staff_admin: true,\n        //                 staff_superadmin: true,\n        //                 staff_LabResultReport: true,\n        //         },\n                \n        //         telegram_peer: {\n        //                 userId: \"660522892\",\n        //                 className: \"PeerUser\"\n        //         }\n        // });\n        // node.warn(xtruong);\n\n        // const ttu = await createIden({ \n        //         identity_name: 'Tran Quan Tu',\n        //         email: 'TranQuangTu@irdop.org',\n        //         password: 'password#3', // hashed password\n        //         irdop_relation: {\n        //                 staff: true,\n        //                 staff_admin: true,\n        //                 staff_superadmin: true,\n        //         },\n        //         telegram_peer: {\n        //                 userId: \"6069072545\",\n        //                 className: \"PeerUser\"\n        //         }\n        // });\n        // node.warn(ttu);\n\n        const cServiceChannel = await createIden ({\n                identity_name: 'Customer Service Telegram Channel',\n                email: 'cServiceTelegramChanel@telegram.irdop.org',\n                password: 'aa11',\n                telegram_peer: {channelId:\"2295380821\",className:\"PeerChannel\"}\n        })\n        node.warn(cServiceChannel);\n}\ncatch (error) {\n        node.warn(error.stack);\n}\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "42d6ff772ca7890f",
        "type": "inject",
        "z": "90c138ec34557557",
        "name": "get-iden-uid",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 280,
        "wires": [
            [
                "ee0ec26796f564e7"
            ]
        ]
    },
    {
        "id": "ee0ec26796f564e7",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "done",
        "func": "const { getIdenByUid } = global.get('idenRepo');\ntry {\n        const iden = await getIdenByUid('IDxfbc9a');\n        node.warn(iden);\n} catch (error) {\n        node.warn(error.stack);\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "f93de9182456c0cc",
        "type": "inject",
        "z": "90c138ec34557557",
        "name": "log-in",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 360,
        "wires": [
            [
                "90cf90300ec15b21"
            ]
        ]
    },
    {
        "id": "90cf90300ec15b21",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "done",
        "func": "const { verifyPassword } = global.get('idenRepo');\n\ntry {\n        // with email\n        const isMatch = await verifyPassword({ email: 'abc@xuantruong.xyza' }, 'password123');\n\n        // with uid\n        //const isMatch = await verifyPassword({ identity_uid: 'IDx12345' }, 'password123');\n        node.warn(isMatch);\n} catch (error) {\n        node.error(error.stack);\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "3b824188409d36ab",
        "type": "inject",
        "z": "90c138ec34557557",
        "name": "get-iden",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 320,
        "wires": [
            [
                "afb16c3f49215d22"
            ]
        ]
    },
    {
        "id": "afb16c3f49215d22",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "done",
        "func": "const { getIden } = global.get('idenRepo');\n\ntry {\n        const iden = await getIden({ identity_uid: 'IDxe4202' });\n        //const iden = await getIden({ email: 'abc@xuantruong.xyz' });\n        //const iden = await getIden({ identity_uid: 'IDx6ac6b', email: 'abc@xuantruong.xyz' });\n        node.warn(iden);\n} catch (error) {\n        node.warn(error.stack);\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "f735a99cb44d4aed",
        "type": "inject",
        "z": "90c138ec34557557",
        "name": "del-iden",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 400,
        "wires": [
            [
                "12a2d5c16d40bd7d"
            ]
        ]
    },
    {
        "id": "12a2d5c16d40bd7d",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "done",
        "func": "const { delIden } = global.get('idenRepo');\n\ntry {\n        const result = await delIden({ identity_uid: 'IDxded51' });\n        node.warn(result);\n} catch (error) {\n        node.warn(error.stack);\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "58476bb916893689",
        "type": "inject",
        "z": "90c138ec34557557",
        "name": "get-iden-peer",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 440,
        "wires": [
            [
                "91e3b6cbe9219209"
            ]
        ]
    },
    {
        "id": "91e3b6cbe9219209",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "done",
        "func": "const { getIdenByTelegramPeer } = global.get('idenRepo');\n\ntry {\n        const peerId = {\n                        userId: \"6069072545\",\n                        className: \"PeerUser\"\n                };\n        const iden = await getIdenByTelegramPeer(peerId);\n        node.warn(iden);\n} catch (error) {\n        node.warn(error.stack);\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "53d8497b0b549f8e",
        "type": "inject",
        "z": "90c138ec34557557",
        "name": "update-iden",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 490,
        "y": 240,
        "wires": [
            [
                "fd93d6754669a1b3"
            ]
        ]
    },
    {
        "id": "fd93d6754669a1b3",
        "type": "function",
        "z": "90c138ec34557557",
        "name": "done",
        "func": "const { updateIden } = global.get('idenRepo');\n\nconst identity = await updateIden({\n        identity_uid: 'IDxfbc9a',\n        irdop_relation: {\n                staff: true,\n                staff_customer_service : true\n        },\n});\n\nnode.warn(identity);",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "518bea544ce6dfdf",
        "type": "telegram client receiver",
        "z": "7a1fb64c865d34db",
        "d": true,
        "name": "ISA BOT",
        "bot": "4e2aeff839f1c074",
        "sendrawevents": false,
        "sendnewmessage": true,
        "sendeditedmessage": false,
        "senddeletedmessage": false,
        "sendalbum": true,
        "sendcallbackquery": false,
        "x": 175,
        "y": 120,
        "wires": [
            []
        ],
        "l": false
    },
    {
        "id": "8eabad261d9c88ad",
        "type": "function",
        "z": "7a1fb64c865d34db",
        "name": "ISA event",
        "func": "const tg = global.get('tg');\nconst { ISA } = global.get('tg_bot');\nconst AUTH = global.get('AUTH');\n\n// Variable declarations\nlet myMessages, myChats, mySenders, myEvents, myOriginalUpdates;\nlet botEventType = msg.payload.type;\nlet myPeerId, myFromId, senderIdentity;\n\n// Handle different bot event types\nif (botEventType === 'NewMessage') {\n    // Destructure payload for clarity\n    const { message, chat, sender, event } = msg.payload;\n\n    myMessages = [message];\n    myChats = [chat];\n    mySenders = [sender];\n    myEvents = [event];\n    myPeerId = myMessages[0].peerId;\n    myFromId = myMessages[0].fromId;\n} else if (botEventType === 'Album') {\n    // Destructure payload for clarity\n    const { messages, event } = msg.payload;\n\n    myMessages = messages;\n    myEvents = event;\n    myPeerId = myMessages[0].peerId;\n    myFromId = myMessages[0].fromId;\n}\n\ntry {\n    // self messing\n    if (ISA.selfMessaging(myMessages[0])) return msg;\n\n    // Print out identity \n    const { getIdenByTelegramPeer } = global.get('idenRepo');\n    const iden = await getIdenByTelegramPeer(myPeerId);\n    node.warn(iden);\n    \n    // get isa instance\n    const isa = await ISA.getInstance(myPeerId, myFromId);\n\n    if (!isa) {\n        await ISA.coldResponseMessage(myMessages[0], 'Bạn chưa được cấp quyền sử dụng bot này');\n        return msg;\n    }\n\n    // if message is a group message, skip\n    if (myMessages[0].groupedId && myMessages.length === 1) return msg;\n\n    await isa.newMessage(myMessages);\n    return msg;\n} catch (error) {\n    node.warn(error.stack);\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "3fe141f67734311d",
        "type": "function",
        "z": "7a1fb64c865d34db",
        "name": "log",
        "func": "const tg_cache = global.get('tg_cache');\nnode.warn(tg_cache)\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "deb0ea33c1bd1e60",
        "type": "inject",
        "z": "7a1fb64c865d34db",
        "name": "Log ISA",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 730,
        "y": 120,
        "wires": [
            [
                "3fe141f67734311d"
            ]
        ]
    },
    {
        "id": "a5a7c2e849845891",
        "type": "function",
        "z": "7a1fb64c865d34db",
        "name": "Clear tg cache",
        "func": "let tg_cache = {}\nglobal.set('tg_cache', tg_cache);\ntg_cache = {\n    isaInstance: {},\n    isaClient: {},\n}\n\nnode\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "6cb8bde8c1c6551e",
        "type": "inject",
        "z": "7a1fb64c865d34db",
        "name": "Log ISA",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 730,
        "y": 160,
        "wires": [
            [
                "a5a7c2e849845891"
            ]
        ]
    },
    {
        "id": "802bb0cf4e3ad1a1",
        "type": "debug",
        "z": "7a1fb64c865d34db",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 350,
        "y": 80,
        "wires": []
    },
    {
        "id": "eac8c64b989325ba",
        "type": "http in",
        "z": "7a1fb64c865d34db",
        "name": "GET: check auth",
        "url": "/check_auth",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 760,
        "y": 220,
        "wires": [
            [
                "103bace9baf4a98a"
            ]
        ]
    },
    {
        "id": "103bace9baf4a98a",
        "type": "function",
        "z": "7a1fb64c865d34db",
        "name": "check auth",
        "func": "const token = await global.get('drive_api').loadToken();\n\nif (token && token.expiry_date > Date.now()) {\n    node.warn('expiry > now');\n    msg.payload = `\n  <html>\n      <head>\n      <script type=\"text/javascript\">\n          window.close(); // Đóng cửa sổ sau khi hoàn tất\n      </script>\n      </head>\n      <body>\n          <h1>Đã hoàn thành thao tác!</h1>\n          <p>Vui lòng đóng cửa sổ này.</p>\n      </body>\n  </html>\n  `;\n\n    msg.headers = {\n        \"Content-Type\": \"text/html\"\n    };\n} else if (token && token.expiry_date < Date.now()) {\n    node.warn('expiry < now');\n    const refresh_token = await global.get('drive_api').refreshAccessToken();\n\n    msg.payload = `\n  <html>\n      <head>\n      <script type=\"text/javascript\">\n          window.close(); // Đóng cửa sổ sau khi hoàn tất\n      </script>\n      </head>\n      <body>\n          <h1>Đã hoàn thành thao tác!</h1>\n          <p>Vui lòng đóng cửa sổ này.</p>\n      </body>\n  </html>\n  `;\n\n    msg.headers = {\n        \"Content-Type\": \"text/html\"\n    };\n} else {\n    let authUrl = await global.get('drive_api').getAccessToken();\n\n    // TODO: báo cho admin để set file token.json\n    node.warn('token not exist');\n\n    msg.statusCode = 302; // Mã trạng thái chuyển hướng\n\n    // Chuyển hướng đến authUrl\n    msg.headers = {\n        location: authUrl\n    };\n\n    node.warn(authUrl);\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 220,
        "wires": [
            [
                "b985c7884523237f"
            ]
        ]
    },
    {
        "id": "b985c7884523237f",
        "type": "http response",
        "z": "7a1fb64c865d34db",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1120,
        "y": 220,
        "wires": []
    },
    {
        "id": "02e63cd1a5e6d96e",
        "type": "http in",
        "z": "7a1fb64c865d34db",
        "name": "call back get token",
        "url": "/google/getauth",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 770,
        "y": 260,
        "wires": [
            [
                "0ef1f25181f021d5"
            ]
        ]
    },
    {
        "id": "0ef1f25181f021d5",
        "type": "function",
        "z": "7a1fb64c865d34db",
        "name": "set token",
        "func": "const code = msg.req.query.code;\nconst scope = msg.req.query.scope;\n\nnode.warn('Get code drive:');\n\nmsg.payload = { code, scope };\n\ntry {\n    const token = await global.get('drive_api').getTokenFromCode(code);\n\n    // Cập nhật trạng thái và phản hồi thành công\n    msg.statusCode = 302; // Mã trạng thái chuyển hướng\n    msg.headers = {\n        \"Content-Type\": \"text/html\"\n    };\n\n    msg.payload = `\n    <html>\n        <head>\n        <script type=\"text/javascript\">\n            window.close(); // Đóng cửa sổ sau khi hoàn tất\n        </script>\n        </head>\n        <body>\n            <h1>Đã hoàn thành thao tác!</h1>\n            <p>Cửa sổ sẽ tự động đóng sau khi hoàn tất thao tác.</p>\n        </body>\n    </html>\n  `;\n} catch (error) {\n    node.error('Error during token retrieval:', error);\n    msg.payload = {\n        error: 'Failed to retrieve token. Please try again.',\n    };\n    msg.statusCode = 500; // Nội dung lỗi\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 260,
        "wires": [
            [
                "b33a4cb5cceee2c8"
            ]
        ]
    },
    {
        "id": "b33a4cb5cceee2c8",
        "type": "http response",
        "z": "7a1fb64c865d34db",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 260,
        "wires": []
    },
    {
        "id": "e506fcb505beb39a",
        "type": "inject",
        "z": "7a1fb64c865d34db",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 260,
        "y": 260,
        "wires": [
            [
                "f8089233c0d9fc21"
            ]
        ]
    },
    {
        "id": "f8089233c0d9fc21",
        "type": "function",
        "z": "7a1fb64c865d34db",
        "name": "function 9",
        "func": "const bots = global.get('tg_bot');\n\nnode.warn({bots});",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "mime",
                "module": "mime"
            }
        ],
        "x": 460,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "2f9ff7cea2cc1bcf",
        "type": "inject",
        "z": "7a1fb64c865d34db",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 240,
        "y": 200,
        "wires": [
            [
                "6535edc671f9c156"
            ]
        ]
    },
    {
        "id": "6535edc671f9c156",
        "type": "function",
        "z": "7a1fb64c865d34db",
        "name": "function 11",
        "func": "const { ISA } = global.get('tg_bot');\nconst peer = msg.payload.message.peerId;\n\ntry {\n        let isa = new ISA(peer);\n        node.warn({ISA});\n        const isSelfMessaging = ISA.selfMessaging(msg.payload.message);\n\n        node.warn(isSelfMessaging);\n\n        if (isSelfMessaging) {\n                node.warn(\"Self messaging\");\n        }\n        else {\n                isa.response(\"Hello\");\n        }\n\n        return msg;\n} catch (error) {\n        node.warn(error);\n        return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "9e2410aeb3b6e9dc",
        "type": "telegram client receiver",
        "z": "7a1fb64c865d34db",
        "d": true,
        "name": "",
        "bot": "acac4ace959569ed",
        "sendrawevents": false,
        "sendnewmessage": true,
        "sendeditedmessage": false,
        "senddeletedmessage": false,
        "sendalbum": true,
        "sendcallbackquery": false,
        "x": 390,
        "y": 440,
        "wires": [
            [
                "b526312f8f2e9b29"
            ]
        ]
    },
    {
        "id": "b526312f8f2e9b29",
        "type": "function",
        "z": "7a1fb64c865d34db",
        "name": "function 12",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "4d1c4112eae14a37",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "main()",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.001",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 140,
        "wires": [
            [
                "b893109eec9a9ab2"
            ]
        ]
    },
    {
        "id": "b893109eec9a9ab2",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "layer0",
        "func": "const { Pool } = global.get('pg');\n\n// DATABASE CLIENT\n// TODO: create client protocol\n\n// Create a new connection pool with the given configuration\nconst pool = new Pool({\n\tuser: env.get('PG_IRDOP_USER'), // USERNAME\n\thost: env.get('PG_IRDOP_HOST'), // HOST\n\tdatabase: env.get('PG_IRDOP_DB'), // DATABASE NAME\n\tpassword: env.get('PG_IRDOP_PW'), // PASSWORD\n\tport: env.get('PG_IRDOP_PORT'), // PORT\n});\n(async () => {\n\ttry {\n\t\t// Attempt to connect to the database\n\t\t// const client = await pool.connect();\n\t\t// Set the connected client in the global scope\n\t\tglobal.set('repoClient', pool);\n\t\t// Log a success message\n\t\tnode.warn('[ COMPLETED ] airdopDB connected');\n\t} catch (error) {\n\t\t// Log an error message if the connection fails\n\t\tnode.warn('[ ERROR ] airdopDB connection failed ' + error.message);\n\t\tconsole.error(error);\n\t}\n})();\n\nconst repoClient = global.get('repoClient'); // Postgres client\nconst cache = global.get('cache'); // Cache object\n\n// CRUD & CACHE FUNCTIONS\nasync function getReceipt(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Validate ID\n\t\t\t// Query the database for the receipt with the given ID\n\t\t\tconst query = `SELECT * FROM receipts WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Check if the result contains any rows\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Receipt',\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn null; // Return null if no rows are found\n\t\t\t}\n\t\t}\n\t\tthrow new Error(`Invalid receipt id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getReceipt', rethrow);\n\t}\n}\n\nasync function getSample(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Validate ID\n\t\t\tconst query = `SELECT * FROM samples WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update Cache & Return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Sample',\n\t\t\t\t};\n\t\t\t} else return null;\n\t\t}\n\t\tthrow new Error(`Invalid sample id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getSample', rethrow);\n\t}\n}\n\nasync function getAnalyte(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Query\n\t\t\tconst query = `SELECT * FROM tests WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update cache and return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Test',\n\t\t\t\t};\n\t\t\t} else return null;\n\t\t}\n\t\tthrow new Error(`Invalid test id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getAnalyte', rethrow);\n\t}\n}\n\nasync function getClient(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Query\n\t\t\tconst query = `SELECT * FROM clients WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update Cache & Return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0)\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Client',\n\t\t\t\t};\n\t\t\telse return null;\n\t\t}\n\t\tthrow new Error(`Invalid client id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getClient', rethrow);\n\t}\n}\n\nasync function getReceiptPrice(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Validate ID\n\t\t\t// Query\n\t\t\tconst query = `SELECT * FROM receipt_prices WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update Cache & Return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'ReceiptPrice',\n\t\t\t\t};\n\t\t\t} else return null;\n\t\t}\n\t\tthrow new Error(`Invalid receipt price id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getReceiptPrice', rethrow);\n\t}\n}\n\nasync function getAnalyteProtocol(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Query\n\t\t\tconst query = `SELECT * FROM lib_protocols WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update Cache & Return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Protocol',\n\t\t\t\t};\n\t\t\t} else return null;\n\t\t}\n\t\tthrow new Error(`Invalid protocol id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getProtocol', rethrow);\n\t}\n}\n\nasync function getSampleAnalyte(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Validate ID\n\t\t\t// Query\n\t\t\tconst query = `SELECT * FROM test_order WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update Cache & Return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'TestOrder',\n\t\t\t\t};\n\t\t\t} else return null;\n\t\t}\n\t\tthrow new Error(`Invalid test order id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getSampleAnalyte', rethrow);\n\t}\n}\n\nasync function getSampleReport(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Validate ID\n\t\t\t// Query\n\t\t\tconst query = `SELECT * FROM sample_report WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update Cache & Return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SampleReport',\n\t\t\t\t};\n\t\t\t} else return null;\n\t\t}\n\t\tthrow new Error(`Invalid sample report id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getSampleReport', rethrow);\n\t}\n}\n\nasync function getSampleReportTest(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Validate ID\n\t\t\t// Query\n\t\t\tconst query = `SELECT * FROM sample_report_tests WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update Cache & Return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SampleReportTest',\n\t\t\t\t};\n\t\t\t} else return null;\n\t\t}\n\t\tthrow new Error(`Invalid sample report test id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getSampleReportTest', rethrow);\n\t}\n}\n\nasync function getUser(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Validate ID\n\t\t\t// Query\n\t\t\tconst query = `SELECT * FROM users WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update Cache & Return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'User',\n\t\t\t\t};\n\t\t\t} else return null;\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid user id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getUser', rethrow);\n\t}\n}\n\nasync function getDepartment(id, rethrow) {\n\t//TODO\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t// Validate ID\n\t\t\t// Query\n\t\t\tconst query = `SELECT * FROM lib_dept WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Update Cache & Return\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Department',\n\t\t\t\t};\n\t\t\t} else return null;\n\t\t}\n\t\tthrow new Error(`Invalid department id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'getDepartment', rethrow);\n\t}\n}\n\nasync function findSamplesByReceiptId(receipt_id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(receipt_id) && receipt_id > 0) {\n\t\t\t// Validate ID\n\t\t\t// Query\n\t\t\tconst query = `SELECT id FROM samples WHERE sample_receipt_id = $1`;\n\t\t\tconst params = [receipt_id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\treturn result.rows.map((row) => row.id); // Return list/array of sample IDs, if null:[]\n\t\t}\n\t\tthrow new Error(`Invalid receipt id: ${receipt_id}`);\n\t} catch (error) {\n\t\thandleError(error, 'findSamplesByReceiptId', rethrow);\n\t}\n}\n\nasync function getReceiptPriceByReceiptId(receipt_id, rethrow) {\n\ttry {\n\t\tif (!Number.isInteger(receipt_id) || receipt_id <= 0)\n\t\t\tthrow new Error('Cannot find receipt price: Invalid receipt ID');\n\t\tconst query = `SELECT * FROM receipt_prices WHERE sample_receipt_id = $1`;\n\t\tconst params = [receipt_id];\n\t\tconst result = await repoClient.query(query, params);\n\n\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\treturn result.rows[0]; // Return receipt price object\n\t\t} else return null;\n\t} catch (error) {\n\t\thandleError(error, 'findReceiptPriceByReceiptId', rethrow);\n\t}\n}\n\nasync function getSamplePriceBySampleId(sample_id, rethrow) {\n\ttry {\n\t\tif (!Number.isInteger(sample_id) || sample_id <= 0) throw new Error('Cannot find sample price: Invalid sample ID');\n\t\tconst query = `SELECT * FROM sample_prices WHERE sample_id = $1`;\n\t\tconst params = [sample_id];\n\t\tconst result = await repoClient.query(query, params);\n\n\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\treturn result.rows[0]; // Return sample price object\n\t\t} else return null;\n\t} catch (error) {\n\t\thandleError(error, 'findSamplePriceBySampleId', rethrow);\n\t}\n}\n\nasync function getSamplePrice(id, rethrow) {\n\ttry {\n\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Cannot find sample price: Invalid sample ID');\n\t\tconst query = `SELECT * FROM sample_prices WHERE id = $1`;\n\t\tconst params = [id];\n\t\tconst result = await repoClient.query(query, params);\n\n\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\treturn result.rows[0]; // Return sample price object\n\t\t} else return null;\n\t} catch (error) {\n\t\thandleError(error, 'findSamplePriceById', rethrow);\n\t}\n}\n\nasync function findSampleAnalytesBySampleId(sample_id, rethrow) {\n\ttry {\n\t\tif (!Number.isInteger(sample_id) || sample_id <= 0) throw new Error('Cannot find test orders: Invalid sample ID');\n\t\tconst query = `SELECT id FROM test_order WHERE sample_id = $1`;\n\t\tconst params = [sample_id];\n\t\tconst result = await repoClient.query(query, params);\n\n\t\treturn result.rows.map((row) => row.id); // Return list/array of test order IDs, if null:[]\n\t} catch (error) {\n\t\thandleError(error, 'findSampleAnalytesBySampleId', rethrow);\n\t}\n}\n\n// UPDATE FUNCTIONS\nasync function setReceipt(receipt, rethrow) {\n\ttry {\n\t\t// Input validation\n\t\tif (!(typeof receipt === 'object' && receipt.id && Number.isInteger(receipt.id) && receipt.id > 0)) {\n\t\t\tthrow new Error(`Invalid receipt: missing or invalid ID`);\n\t\t}\n\n\t\t// Validate columns against database schema\n\t\tconst validColumns = await matchValidColumns('receipts', Object.keys(receipt));\n\t\tif (validColumns.length !== Object.keys(receipt).length) {\n\t\t\tthrow new Error(`Invalid receipt columns: ${Object.keys(receipt).join(', ')}`);\n\t\t}\n\n\t\t// Construct and execute update query\n\t\tconst query = `\n\t\t\tUPDATE receipts\n\t\t\tSET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n\t\t\tWHERE id = $1\n\t\t\tRETURNING *`; // Add RETURNING * to get the updated record\n\t\tconst params = [receipt.id, ...validColumns.map((column) => receipt[column])];\n\n\t\tconst result = await repoClient.query(query, params);\n\n\t\t// Handle no rows updated\n\t\tif (!result || result.rowCount === 0) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Receipt with ID ${receipt.id} not found`,\n\t\t\t\tdata: null,\n\t\t\t};\n\t\t}\n\n\t\t// Return success response with updated data\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: 'Receipt updated successfully',\n\t\t\tdata: {\n\t\t\t\t...result.rows[0],\n\t\t\t\tclassName: 'Receipt',\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\thandleError(error, 'setReceipt', rethrow);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessage: error.message,\n\t\t\tdata: null,\n\t\t};\n\t}\n}\n\nasync function setSample(sample, rethrow) {\n\ttry {\n\t\tif (typeof sample === 'object' && sample.id && Number.isInteger(sample.id) && sample.id > 0) {\n\t\t\t/** 1. Validate sample */\n\t\t\tconst validColumns = await matchValidColumns('samples', Object.keys(sample));\n\t\t\tif (validColumns.length !== Object.keys(sample).length) {\n\t\t\t\tthrow new Error(`Invalid sample columns: ${Object.keys(sample).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Query to server */\n\t\t\tconst query = `\n                    UPDATE samples\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [sample.id, ...validColumns.map((column) => sample[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Return result */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...sample,\n\t\t\t\t\tclassName: 'Sample',\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid sample: ${sample}`);\n\t} catch (error) {\n\t\thandleError(error, 'setSample', rethrow);\n\t}\n}\n\nasync function setTest(test, rethrow) {\n\ttry {\n\t\tif (typeof test === 'object' && test.id && Number.isInteger(test.id) && test.id > 0) {\n\t\t\t/** 1. Validate test */\n\t\t\tconst validColumns = await matchValidColumns('tests', Object.keys(test));\n\t\t\tif (validColumns.length !== Object.keys(test).length) {\n\t\t\t\tthrow new Error(`Invalid test columns: ${Object.keys(test).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Query to server */\n\t\t\tconst query = `\n                    UPDATE tests\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [test.id, ...validColumns.map((column) => test[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Return result */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...test,\n\t\t\t\t\tclassName: 'Test',\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid test: ${test}`);\n\t} catch (error) {\n\t\thandleError(error, 'setTest', rethrow);\n\t}\n}\n\nasync function setClient(client, rethrow) {\n\ttry {\n\t\tif (typeof client === 'object' && client.id && Number.isInteger(client.id) && client.id > 0) {\n\t\t\t/** 1. Validate client */\n\t\t\tconst validColumns = await matchValidColumns('clients', Object.keys(client));\n\t\t\tif (validColumns.length !== Object.keys(client).length) {\n\t\t\t\tthrow new Error(`Invalid client columns: ${Object.keys(client).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Query to server */\n\t\t\tconst query = `\n                    UPDATE clients\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [client.id, ...validColumns.map((column) => client[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Return result */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\treturn {\n\t\t\t\t\t...client,\n\t\t\t\t\tclassName: 'Client',\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid client: ${client}`);\n\t} catch (error) {\n\t\thandleError(error, 'setClient', rethrow);\n\t}\n}\n\nasync function setSampleAnalyte(sampleAnalyte, rethrow) {\n\ttry {\n\t\tif (\n\t\t\ttypeof sampleAnalyte === 'object' &&\n\t\t\tsampleAnalyte.id &&\n\t\t\tNumber.isInteger(sampleAnalyte.id) &&\n\t\t\tsampleAnalyte.id > 0\n\t\t) {\n\t\t\t/** 1. Validate test order */\n\t\t\tconst validColumns = await matchValidColumns('test_order', Object.keys(sampleAnalyte));\n\t\t\tif (validColumns.length !== Object.keys(sampleAnalyte).length) {\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(sampleAnalyte).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Query to server */\n\t\t\tconst query = `\n                    UPDATE test_order\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [sampleAnalyte.id, ...validColumns.map((column) => sampleAnalyte[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedTestOrder = {\n\t\t\t\t\t...sampleAnalyte,\n\t\t\t\t\tclassName: 'TestOrder',\n\t\t\t\t};\n\t\t\t\tcache.setSampleAnalyte(updatedTestOrder); // Set cache\n\t\t\t\treturn updatedTestOrder; // Return test order\n\t\t\t} else return null;\n\t\t} else throw new Error(`Invalid test order: ${sampleAnalyte}`);\n\t} catch (error) {\n\t\thandleError(error, 'setTestOrder', rethrow);\n\t}\n}\n\nasync function setProtocol(protocol, rethrow) {\n\ttry {\n\t\tif (typeof protocol === 'object' && protocol.id && Number.isInteger(protocol.id) && protocol.id > 0) {\n\t\t\t/** 1. Validate protocol */\n\t\t\tconst validColumns = await matchValidColumns('lib_protocols', Object.keys(protocol));\n\t\t\tif (validColumns.length !== Object.keys(protocol).length) {\n\t\t\t\tthrow new Error(`Invalid protocol columns: ${Object.keys(protocol).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Query to server */\n\t\t\tconst query = `\n                    UPDATE lib_protocols\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [protocol.id, ...validColumns.map((column) => protocol[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedProtocol = {\n\t\t\t\t\t...protocol,\n\t\t\t\t\tclassName: 'Protocol',\n\t\t\t\t};\n\t\t\t\tcache.setProtocol(updatedProtocol); // Set cache\n\t\t\t\treturn updatedProtocol; // Return protocol\n\t\t\t} else return null;\n\t\t} else throw new Error(`Invalid protocol: ${protocol}`);\n\t} catch (error) {\n\t\thandleError(error, 'setProtocol', rethrow);\n\t}\n}\n\nasync function setReceiptPrice(receiptPrice, rethrow) {\n\ttry {\n\t\tif (\n\t\t\ttypeof receiptPrice === 'object' &&\n\t\t\treceiptPrice.id &&\n\t\t\tNumber.isInteger(receiptPrice.id) &&\n\t\t\treceiptPrice.id > 0\n\t\t) {\n\t\t\t/** 1. Validate receipt price */\n\t\t\tconst validColumns = await matchValidColumns('receipt_prices', Object.keys(receiptPrice));\n\t\t\tif (validColumns.length !== Object.keys(receiptPrice).length) {\n\t\t\t\tthrow new Error(`Invalid receipt price columns: ${Object.keys(receiptPrice).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    UPDATE receipt_prices\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\n\t\t\tconst params = [receiptPrice.id, ...validColumns.map((column) => receiptPrice[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedReceiptPrice = {\n\t\t\t\t\t...receiptPrice,\n\t\t\t\t\tclassName: 'ReceiptPrice',\n\t\t\t\t};\n\t\t\t\tcache.setReceiptPrice(updatedReceiptPrice); // Set cache\n\t\t\t\treturn updatedReceiptPrice; // Return receipt price\n\t\t\t} else return null;\n\t\t} else throw new Error(`Invalid receipt price: ${receiptPrice}`);\n\t} catch (error) {\n\t\thandleError(error, 'setReceiptPrice', rethrow);\n\t}\n}\n\nasync function getSampleReportBySampleId(sample_id, rethrow) {\n\ttry {\n\t\tif (!Number.isInteger(sample_id) || sample_id <= 0) throw new Error('Cannot find sample report: Invalid sample ID');\n\t\tconst query = `SELECT * FROM sample_report WHERE sample_id = $1`;\n\t\tconst params = [sample_id];\n\t\tconst result = await repoClient.query(query, params);\n\n\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\treturn result.rows[0]; // Return sample report object\n\t\t} else return null;\n\t} catch (error) {\n\t\thandleError(error, 'findSampleReportBySampleId', rethrow);\n\t}\n}\n\nasync function setSampleReport(sampleReport, rethrow) {\n\ttry {\n\t\tif (\n\t\t\ttypeof sampleReport === 'object' &&\n\t\t\tsampleReport.id &&\n\t\t\tNumber.isInteger(sampleReport.id) &&\n\t\t\tsampleReport.id > 0\n\t\t) {\n\t\t\t/** 1. Validate sample report */\n\t\t\tconst validColumns = await matchValidColumns('sample_report', Object.keys(sampleReport));\n\t\t\tif (validColumns.length !== Object.keys(sampleReport).length) {\n\t\t\t\tthrow new Error(`Invalid sample report columns: ${Object.keys(sampleReport).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Query to server */\n\t\t\tconst query = `\n                    UPDATE sample_report\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [sampleReport.id, ...validColumns.map((column) => sampleReport[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedSampleReport = {\n\t\t\t\t\t...sampleReport,\n\t\t\t\t\tclassName: 'SampleReport',\n\t\t\t\t};\n\t\t\t\tcache.setSampleReport(updatedSampleReport); // Set cache\n\t\t\t\treturn updatedSampleReport; // Return sample report\n\t\t\t} else return null;\n\t\t} else throw new Error(`Invalid sample report: ${sampleReport}`);\n\t} catch (error) {\n\t\thandleError(error, 'setSampleReport', rethrow);\n\t}\n}\n\nasync function setSampleReportTest(sampleReportTest, rethrow) {\n\ttry {\n\t\t// Check if the sampleReportTest is a valid object and has a valid id\n\t\tif (\n\t\t\ttypeof sampleReportTest === 'object' &&\n\t\t\tsampleReportTest.id &&\n\t\t\tNumber.isInteger(sampleReportTest.id) &&\n\t\t\tsampleReportTest.id > 0\n\t\t) {\n\t\t\t/** 1. Validate sample report test */\n\t\t\tconst validColumns = await matchValidColumns('sample_report_tests', Object.keys(sampleReportTest));\n\t\t\tif (validColumns.length !== Object.keys(sampleReportTest).length) {\n\t\t\t\t// Throw an error if there are invalid columns\n\t\t\t\tthrow new Error(`Invalid sample report test columns: ${Object.keys(sampleReportTest).join(', ')}`);\n\t\t\t}\n\n\t\t\t/** 2. Query to server */\n\t\t\tconst query = `\n                    UPDATE sample_report_tests\n                    SET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n                    WHERE id = $1\n                `;\n\t\t\tconst params = [sampleReportTest.id, ...validColumns.map((column) => sampleReportTest[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tconst updatedSampleReportTest = {\n\t\t\t\t\t...sampleReportTest,\n\t\t\t\t\tclassName: 'SampleReportTest',\n\t\t\t\t};\n\t\t\t\tcache.setSampleReportTest(updatedSampleReportTest); // Set cache\n\t\t\t\treturn updatedSampleReportTest; // Return sample report test\n\t\t\t} else return null;\n\t\t} else throw new Error(`Invalid sample report test: ${sampleReportTest}`);\n\t} catch (error) {\n\t\t// Handle any errors that occur during the operation\n\t\thandleError(error, 'setSampleReportTest', rethrow);\n\t}\n}\n\n// DELETE FUNCTIONS\nasync function delReceipt(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM receipts WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tcache.delReceipt(id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid receipt id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delReceipt', rethrow);\n\t}\n}\n\nasync function delSample(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM samples WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tcache.delSample(id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid sample id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delSample', rethrow);\n\t}\n}\n\nasync function delSampleAnalyte(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM sample_analytes WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tcache.delSampleAnalyte(id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid sample analyte id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delSampleAnalyte', rethrow);\n\t}\n}\n\nasync function delTest(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM tests WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tcache.delTest(id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid test id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delTest', rethrow);\n\t}\n}\n\nasync function delClient(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM clients WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tcache.delClient(id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid client id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delClient', rethrow);\n\t}\n}\n\nasync function delTestOrder(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM test_order WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tcache.delTestOrder(id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid test order id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delTestOrder', rethrow);\n\t}\n}\n\nasync function delProtocol(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst query = `DELETE FROM lib_protocols WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tcache.delProtocol(id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid protocol id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delProtocol', rethrow);\n\t}\n}\n\nasync function delReceiptPrice(id, rethrow) {\n\ttry {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\t/** 1. Query to server */\n\t\t\tconst query = `DELETE FROM receipt_prices WHERE id = $1`;\n\t\t\tconst params = [id];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 2. Update cache */\n\t\t\tif (result && result.rowCount > 0) {\n\t\t\t\tcache.delReceiptPrice(id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tthrow new Error(`Invalid receipt price id: ${id}`);\n\t} catch (error) {\n\t\thandleError(error, 'delReceiptPrice', rethrow);\n\t}\n}\n\n// MATCH FUNCTIONS\nasync function matchValidColumns(table_name, columns) {\n\ttry {\n\t\t/** 1. Get table columns from server */\n\t\t// Construct the SQL query to get the column names from the information schema\n\t\tconst validColumnsQuery = `SELECT column_name FROM information_schema.columns WHERE table_name = $1`;\n\t\tconst validColumnsParams = [table_name];\n\n\t\t// Execute the SQL query\n\t\tconst validColumnsResult = await repoClient.query(validColumnsQuery, validColumnsParams);\n\n\t\t// Extract the column names from the query result\n\t\tconst validColumns = validColumnsResult.rows.map((row) => row.column_name);\n\n\t\t/** 2. Match columns */\n\t\t// Filter the input columns to include only valid columns\n\t\tconst matchedColumns = columns.filter((column) => validColumns.includes(column));\n\n\t\t// Return the matched columns\n\t\treturn matchedColumns; // if no match return []\n\t} catch (error) {\n\t\t// Handle any errors that occur during the operation\n\t\thandleError(error, 'matchValidColumns');\n\t}\n}\n\n//ADD FUNCTIONS\nasync function newReceipt(receipt, rethrow) {\n\t/**\n\t * @param {Object} receipt\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\t// Validate the receipt object\n\t\tif (validateReceipt(receipt)) {\n\t\t\t// Generate a new UID if it doesn't already exist\n\t\t\tif (!receipt.receipt_uid) receipt.receipt_uid = await getNextUID();\n\n\t\t\t/** 1. Validate receipt columns */\n\t\t\t// Validate the columns of the receipt object against the database schema\n\t\t\tconst validColumns = await matchValidColumns('receipts', Object.keys(receipt));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid receipt columns: ${Object.keys(receipt).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\t// Construct the SQL query to insert the receipt into the database\n\t\t\tconst query = `\n                    INSERT INTO receipts (${validColumns.join(',')}) \n                    VALUES (${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                    RETURNING *`;\n\t\t\t// Prepare the parameters for the SQL query\n\t\t\tconst params = validColumns.map((column) => receipt[column]);\n\n\t\t\t// Execute the SQL query\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t// Return the newly created receipt\n\t\t\treturn result.rows[0];\n\t\t} else {\n\t\t\t// Throw an error if the receipt object is invalid\n\t\t\tthrow new Error('Invalid receipt object');\n\t\t}\n\t} catch (error) {\n\t\t// Handle any errors that occur during the operation\n\t\thandleError(error, 'newReceipt', rethrow);\n\t}\n\n\tfunction validateReceipt(receipt) {\n\t\t// Check if the receipt object is valid\n\t\tif (typeof receipt === 'object' && Object.keys(receipt).length > 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync function getNextUID() {\n\t\t// Get the current date\n\t\tconst currentDate = new Date();\n\t\tconst currentYear = currentDate.getFullYear().toString().slice(-2);\n\t\tconst currentWeek = String(\n\t\t\tMath.floor(\n\t\t\t\t(currentDate.getTime() - new Date(currentDate.getFullYear(), 0, 1).getTime()) / (1000 * 60 * 60 * 24 * 7),\n\t\t\t) + 1,\n\t\t).padStart(2, '0');\n\t\tconst currentDay = String(currentDate.getDate()).padStart(2, '0');\n\n\t\t// Get the last receipt UID from the database\n\t\tconst query = `SELECT receipt_uid FROM receipts ORDER BY id DESC LIMIT 1`;\n\t\tconst result = await repoClient.query(query);\n\t\tconst lastUID = result.rows[0].receipt_uid || 'PPT.YYWWDD-01';\n\t\tconst nextIndex =\n\t\t\tlastUID.slice(8, 10) !== currentWeek ? '01' : String(Number(lastUID.slice(11)) + 1).padStart(2, '0');\n\t\tconst nextReceiptUID = `PPT.${currentYear}${currentWeek}${currentDay}-${nextIndex}`;\n\n\t\t// Return the next receipt UID\n\t\treturn nextReceiptUID;\n\t}\n}\n\nasync function newSample(sample, rethrow) {\n\t/**\n\t * @param {Object} sample\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateSample(sample)) {\n\t\t\tif (!sample.sample_uid) sample.sample_uid = await getNextUID(); // Nếu uid đã có (populate task) thì không cần tạo mới\n\n\t\t\t/** 1. Validate sample columns */\n\t\t\tconst validColumns = await matchValidColumns('samples', Object.keys(sample));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid sample columns: ${Object.keys(sample).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO samples (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => sample[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst sample = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Sample',\n\t\t\t\t};\n\t\t\t\tcache.samples[sample.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: sample,\n\t\t\t\t};\n\t\t\t\treturn cache.samples[sample.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tthrow new Error(`Invalid sample: ${sample}`);\n\t} catch (error) {\n\t\thandleError(error, 'newSample', rethrow);\n\t}\n\n\tfunction validateSample(sample) {\n\t\tif (typeof sample === 'object' && Object.keys(sample).length > 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync function getNextUID() {\n\t\t// Get current day, week and year\n\t\tconst currentDate = new Date();\n\t\tconst currentYear = currentDate.getFullYear().toString().slice(-2);\n\t\tconst currentWeek = String(\n\t\t\tMath.floor(\n\t\t\t\t(currentDate.getTime() - new Date(currentDate.getFullYear(), 0, 1).getTime()) / (1000 * 60 * 60 * 24 * 7),\n\t\t\t) + 1,\n\t\t).padStart(2, '0');\n\t\tconst currentDay = String(currentDate.getDate()).padStart(2, '0');\n\n\t\t// Get next receipt UID\n\t\tconst query = `SELECT sample_uid FROM samples ORDER BY id DESC LIMIT 1`;\n\t\tconst result = await repoClient.query(query);\n\t\tconst lastUID = result.rows[0].sample_uid || 'PPT.YYWWDD-01';\n\t\tconst nextIndex =\n\t\t\tlastUID.slice(5, 7) !== currentWeek ? '01' : String(Number(lastUID.slice(10)) + 1).padStart(2, '0');\n\t\tconst nextReceiptUID = `SP.${currentYear}${currentWeek}${currentDay}-${nextIndex}`;\n\n\t\treturn nextReceiptUID;\n\t}\n}\n\nasync function newTest(test, rethrow) {\n\t/**\n\t * @param {Object} test\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateTest(test)) {\n\t\t\t// Test không có uid\n\t\t\t// if (!test.test_uid) test.test_uid = await getNextUID(); // Nếu uid đã có (populate task) thì không cần tạo mới\n\n\t\t\t/** 1. Validate test columns */\n\t\t\tconst validColumns = await matchValidColumns('tests', Object.keys(test));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid test columns: ${Object.keys(test).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO tests (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\n\t\t\tconst params = [...validColumns.map((column) => test[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst test = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Test',\n\t\t\t\t};\n\t\t\t\tcache.tests[test.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: test,\n\t\t\t\t};\n\t\t\t\treturn cache.tests[test.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tthrow new Error(`Invalid test: ${test}`);\n\t} catch (error) {\n\t\thandleError(error, 'newTest', rethrow);\n\t}\n\n\tfunction validateTest(test) {\n\t\tif (\n\t\t\ttypeof test === 'object' &&\n\t\t\tObject.keys(test).length > 0\n\t\t\t// &&\n\t\t\t// test.id === undefined &&\n\t\t\t// test.test_name.trim().length > 0\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newClient(client, rethrow) {\n\t/**\n\t * @param {Object} client\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateClient(client)) {\n\t\t\t/** 1. Validate client columns */\n\t\t\tif (!client.client_uid) client.client_uid = `CL.${crypto.randomUUID().substr(0, 8)}`;\n\t\t\tconst validColumns = await matchValidColumns('clients', Object.keys(client));\n\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid client columns: ${Object.keys(client).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO clients (${validColumns.join(',')}) \n                    VALUES (  ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => client[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst client = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'Client',\n\t\t\t\t};\n\t\t\t\tcache.clients[client.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: client,\n\t\t\t\t};\n\t\t\t\treturn cache.clients[client.id].value;\n\t\t\t}\n\n\t\t\treturn client;\n\t\t}\n\t\tthrow new Error(`Invalid client: ${client}`);\n\t} catch (error) {\n\t\thandleError(error, 'newClient', rethrow);\n\t}\n\n\tfunction validateClient(client) {\n\t\tif (\n\t\t\ttypeof client === 'object' &&\n\t\t\tObject.keys(client).length > 0\n\t\t\t// &&\n\t\t\t// client.id === undefined &&\n\t\t\t// client.client_name.trim().length > 0\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function addSampleAnalyte(testOrder, rethrow) {\n\t/**\n\t * @param {Object} testOrder\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateTestOrder(testOrder)) {\n\t\t\t/** 1. Validate test order columns */\n\t\t\tconst validColumns = await matchValidColumns('test_order', Object.keys(testOrder));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(testOrder).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO test_order (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => testOrder[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst testOrder = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'TestOrder',\n\t\t\t\t};\n\t\t\t\tcache.testOrder[testOrder.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: testOrder,\n\t\t\t\t};\n\t\t\t\treturn cache.testOrder[testOrder.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'addSampleAnalyte', rethrow);\n\t}\n\n\tfunction validateTestOrder(testOrder) {\n\t\tif (\n\t\t\ttypeof testOrder === 'object' &&\n\t\t\tObject.keys(testOrder).length > 0\n\t\t\t// && testOrder.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newUser(user, rethrow) {\n\t/**\n\t * @param {Object} user\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateUser(user)) {\n\t\t\t/** 1. Validate user columns */\n\t\t\tconst validColumns = await matchValidColumns('users', Object.keys(user));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid user columns: ${Object.keys(user).join(', ')}`);\n\n\t\t\t/** 2. Send to server */\n\t\t\tconst query = `\n                    INSERT INTO users (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => user[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\t/** 3. Update cache */\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst user = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'User',\n\t\t\t\t};\n\t\t\t\tcache.users[user.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: user,\n\t\t\t\t};\n\t\t\t\treturn cache.users[user.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newUser', rethrow);\n\t}\n\n\tfunction validateUser(user) {\n\t\tif (\n\t\t\ttypeof user === 'object'\n\t\t\t// && Object.keys(user).length > 0\n\t\t\t// && user.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newReceiptPrice(receiptPrice, rethrow) {\n\t/**\n\t * @param {Object} receiptPrice\n\t * @returns {Promise<Object>}\n\t */\n\ttry {\n\t\tif (validateReceiptPrice(receiptPrice)) {\n\t\t\t/** 1. Validate receipt price columns */\n\t\t\tconst validColumns = await matchValidColumns('receipt_prices', Object.keys(receiptPrice));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(receiptPrice).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO receipt_prices (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => receiptPrice[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst insertReceiptPrice = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'ReceiptPrice',\n\t\t\t\t};\n\t\t\t\tcache.receiptPrices[insertReceiptPrice.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: receiptPrice,\n\t\t\t\t};\n\t\t\t\treturn cache.receiptPrices[insertReceiptPrice.id].value;\n\t\t\t}\n\t\t\treturn result.rows[0];\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newReceiptPrice', rethrow);\n\t}\n\n\tfunction validateReceiptPrice(receiptPrice) {\n\t\tif (\n\t\t\ttypeof receiptPrice === 'object' &&\n\t\t\tObject.keys(receiptPrice).length > 0\n\t\t\t// && receiptPrice.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newLibProtocol(libProtocols, rethrow) {\n\ttry {\n\t\tif (validateLibProtocols(libProtocols)) {\n\t\t\tconst validColumns = await matchValidColumns('lib_protocols', Object.keys(libProtocols));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(libProtocols).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO lib_protocols (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => libProtocols[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst libProtocols = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'LibProtocol',\n\t\t\t\t};\n\t\t\t\tcache.libProtocols[libProtocols.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: libProtocols,\n\t\t\t\t};\n\t\t\t\treturn cache.libProtocols[libProtocols.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newLibProtocol', rethrow);\n\t}\n\n\tfunction validateLibProtocols(libProtocols) {\n\t\tif (\n\t\t\ttypeof libProtocols === 'object'\n\t\t\t// && Object.keys(libProtocols).length > 0\n\t\t\t// && libProtocols.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newLibDept(libDept, rethrow) {\n\ttry {\n\t\tif (validateLibDept(libDept)) {\n\t\t\tconst validColumns = await matchValidColumns('lib_dept', Object.keys(libDept));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid test order columns: ${Object.keys(libDept).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO lib_dept (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => libDept[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst libDept = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'LibDept',\n\t\t\t\t};\n\t\t\t\tcache.libDept[libDept.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: libDept,\n\t\t\t\t};\n\t\t\t\treturn cache.libDept[libDept.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newLibDept', rethrow);\n\t}\n\n\tfunction validateLibDept(libDept) {\n\t\tif (\n\t\t\ttypeof libDept === 'object'\n\t\t\t// && Object.keys(libDept).length > 0 &&\n\t\t\t// libDept.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newLibLab(libLab, rethrow) {\n\ttry {\n\t\tif (validateLibLab(libLab)) {\n\t\t\tconst validColumns = await matchValidColumns('lib_lab', Object.keys(libLab));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid test order columns: ${Object.keys(libLab).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO lib_lab (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => libLab[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst libLab = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'LibLab',\n\t\t\t\t};\n\t\t\t\tcache.libLab[libLab.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: libLab,\n\t\t\t\t};\n\t\t\t\treturn cache.libLab[libLab.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newLibLab', rethrow);\n\t}\n\n\tfunction validateLibLab(libLab) {\n\t\tif (\n\t\t\ttypeof libLab === 'object'\n\t\t\t// && Object.keys(libLab).length > 0 &&\n\t\t\t// libLab.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newSamplePrice(samplePrices, rethrow) {\n\ttry {\n\t\tif (validateSamplePrices(samplePrices)) {\n\t\t\tconst validColumns = await matchValidColumns('sample_prices', Object.keys(samplePrices));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(samplePrices).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO sample_prices (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => samplePrices[column])];\n\t\t\tlet result = await repoClient.query(query, params);\n\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst samplePrices = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SamplePrice',\n\t\t\t\t};\n\t\t\t\tcache.samplePrices[samplePrices.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: samplePrices,\n\t\t\t\t};\n\t\t\t\treturn cache.samplePrices[samplePrices.id].value;\n\t\t\t}\n\t\t\treturn result.rows[0];\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newSamplePrice', rethrow);\n\t}\n\n\tfunction validateSamplePrices(samplePrices) {\n\t\tif (\n\t\t\ttypeof samplePrices === 'object' &&\n\t\t\tObject.keys(samplePrices).length > 0\n\t\t\t// && samplePrices.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newSampleReport(sampleReport, rethrow) {\n\ttry {\n\t\tif (validateSampleReport(sampleReport)) {\n\t\t\t// if (sampleReport.id) delete sampleReport.id;\n\t\t\t// CHECK\n\t\t\tif (!sampleReport.report_uid) sampleReport.report_uid = await nextSampleReportUID();\n\t\t\tconst validColumns = await matchValidColumns('sample_report', Object.keys(sampleReport));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(sampleReport).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO sample_report (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => sampleReport[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst sampleReport = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SampleReport',\n\t\t\t\t};\n\t\t\t\tcache.sampleReports[sampleReport.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: sampleReport,\n\t\t\t\t};\n\t\t\t\treturn cache.sampleReports[sampleReport.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newSampleReport', rethrow);\n\t}\n\n\tfunction validateSampleReport(sampleReport) {\n\t\tif (\n\t\t\ttypeof sampleReport === 'object' &&\n\t\t\tObject.keys(sampleReport).length > 0\n\t\t\t//  && sampleReport.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync function nextSampleReportUID() {\n\t\t// Get current day, week and year\n\t\tconst currentDate = new Date();\n\t\tconst currentYear = currentDate.getFullYear().toString().slice(-2);\n\t\tconst currentWeek = String(\n\t\t\tMath.floor(\n\t\t\t\t(currentDate.getTime() - new Date(currentDate.getFullYear(), 0, 1).getTime()) / (1000 * 60 * 60 * 24 * 7),\n\t\t\t) + 1,\n\t\t).padStart(2, '0');\n\t\tconst currentDay = String(currentDate.getDate()).padStart(2, '0');\n\t\tconst currentMonth = String(currentDate.getMonth() + 1).padStart(2, '0');\n\n\t\t// Get next receipt UID\n\t\tconst query = `SELECT report_uid FROM sample_report ORDER BY id DESC LIMIT 1`;\n\t\tconst result = await repoClient.query(query);\n\t\tconst lastUID = result.rows[0].report_uid || 'PPT.YYWWMM-DD01';\n\t\tconst nextIndex =\n\t\t\tlastUID.slice(6, 8) !== currentWeek ? '01' : String(Number(lastUID.slice(12)) + 1).padStart(2, '0');\n\t\tconst nextReceiptUID = `PPT.${currentYear}${currentWeek}${currentMonth}-${currentDay}${nextIndex}`;\n\n\t\treturn nextReceiptUID;\n\t}\n}\n\nasync function newSampleReportTest(sampleReportTest, rethrow) {\n\ttry {\n\t\tif (validateSampleReportTest(sampleReportTest)) {\n\t\t\tconst validColumns = await matchValidColumns('sample_report_tests', Object.keys(sampleReportTest));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid test order columns: ${Object.keys(sampleReportTest).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO sample_report_tests (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => sampleReportTest[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst sampleReportTest = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'SampleReportTest',\n\t\t\t\t};\n\t\t\t\tcache.sampleReportTest[sampleReportTest.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: sampleReportTest,\n\t\t\t\t};\n\t\t\t\treturn cache.sampleReportTest[sampleReportTest.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newSampleReportTest', rethrow);\n\t}\n\n\tfunction validateSampleReportTest(sampleReportTest) {\n\t\tif (\n\t\t\ttypeof sampleReportTest === 'object' &&\n\t\t\tObject.keys(sampleReportTest).length > 0\n\t\t\t// &&\tsampleReportTest.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newLabRole(labRole, rethrow) {\n\ttry {\n\t\tif (validateLabRole(labRole)) {\n\t\t\tconst validColumns = await matchValidColumns('user_lab_roles', Object.keys(labRole));\n\t\t\tif (validColumns.length === 0)\n\t\t\t\tthrow new Error(`Invalid User Lab Role columns: ${Object.keys(labRole).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO user_lab_roles (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\n                                    RETURNING *\n                `;\n\t\t\tconst params = [...validColumns.map((column) => labRole[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst labRole = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'LabRole',\n\t\t\t\t};\n\t\t\t\tcache.labRole[labRole.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: labRole,\n\t\t\t\t};\n\t\t\t\treturn cache.labRole[labRole.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newLabRole', rethrow);\n\t}\n\n\tfunction validateLabRole(labRole) {\n\t\tif (\n\t\t\ttypeof labRole === 'object' &&\n\t\t\tObject.keys(labRole).length > 0\n\t\t\t// && labRole.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nasync function newUserDept(userDept, rethrow) {\n\ttry {\n\t\tif (validateUserDept(userDept)) {\n\t\t\tconst validColumns = await matchValidColumns('user_depts', Object.keys(userDept));\n\t\t\tif (validColumns.length === 0) throw new Error(`Invalid User Dept columns: ${Object.keys(userDept).join(', ')}`);\n\t\t\tconst query = `\n                    INSERT INTO user_depts (${validColumns.join(',')}) \n                    VALUES ( ${validColumns.map((_, index) => `$${index + 1}`).join(',')})\t\t\t\t\n                    RETURNING *\n\n                `;\n\t\t\tconst params = [...validColumns.map((column) => userDept[column])];\n\t\t\tconst result = await repoClient.query(query, params);\n\t\t\tif (result && Array.isArray(result.rows) && result.rows.length > 0) {\n\t\t\t\tconst userDept = {\n\t\t\t\t\t...result.rows[0],\n\t\t\t\t\tclassName: 'UserDept',\n\t\t\t\t};\n\t\t\t\tcache.userDept[userDept.id] = {\n\t\t\t\t\tcached_at: Date.now(),\n\t\t\t\t\tvalue: userDept,\n\t\t\t\t};\n\t\t\t\treturn cache.userDept[userDept.id].value;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\thandleError(error, 'newUserDept', rethrow);\n\t}\n\n\tfunction validateUserDept(userDept) {\n\t\tif (\n\t\t\ttypeof userDept === 'object' &&\n\t\t\tObject.keys(userDept).length > 0\n\t\t\t// && userDept.id === undefined\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nfunction handleError(error, functionName, rethrow) {\n\tnode.warn(`[ CAUGHT ERROR ] @layer0.js  ${functionName}() - ${JSON.stringify(error)}`);\n\tnode.warn(error);\n\t// API response\n\terror.statusCode = 500; // Internal Server Error\n\terror.errorMessage = 'Internal Server Error';\n\tif (rethrow) throw error;\n}\n\nconst ERROR = {\n\tHTTP_400: (message = 'Bad Request') => {\n\t\tconst error = new Error(message);\n\t\terror.statusCode = 400;\n\t\terror.errorName = 'Bad Request';\n\t\treturn error;\n\t},\n\tHTTP_401: (message = 'Unauthorized') => {\n\t\tconst error = new Error(message);\n\t\terror.statusCode = 401;\n\t\terror.errorName = 'Unauthorized';\n\t\treturn error;\n\t},\n\tHTTP_403: (message = 'Forbidden') => {\n\t\tconst error = new Error(message);\n\t\terror.statusCode = 403;\n\t\terror.errorName = 'Forbidden';\n\t\treturn error;\n\t},\n\tHTTP_404: (message = 'Not Found') => {\n\t\tconst error = new Error(message);\n\t\terror.statusCode = 404;\n\t\terror.errorName = 'Not Found';\n\t\treturn error;\n\t},\n\tHTTP_500: (message = 'Internal Server Error') => {\n\t\tconst error = new Error(message);\n\t\terror.statusCode = 500;\n\t\terror.errorName = 'Internal Server Error';\n\t\treturn error;\n\t},\n\tHTTP_503: (message = 'Service Unavailable') => {\n\t\tconst error = new Error(message);\n\t\terror.statusCode = 503;\n\t\terror.errorName = 'Service Unavailable';\n\t\treturn error;\n\t}\n}\n\n//export functions\nconst layer0 = {\n\tgetReceipt,\n\tsetReceipt,\n\tgetSample,\n\tsetSample,\n\tgetAnalyte,\n\tsetTest,\n\tgetClient,\n\tgetReceiptPrice,\n\tgetSampleReport,\n\tgetSampleReportTest,\n\tgetUser,\n\tnewClient,\n\tsetClient,\n\tnewReceipt,\n\tnewTest,\n\tnewSample,\n\taddSampleAnalyte,\n\tnewUser,\n\tnewReceiptPrice,\n\tnewLibProtocol,\n\tnewLibDept,\n\tnewLibLab,\n\tnewSamplePrice,\n\tnewLabRole,\n\tnewUserDept,\n\tdelReceipt,\n\tdelSample,\n\tdelTest,\n\tdelClient,\n\tdelTestOrder,\n\tdelProtocol,\n\tdelReceiptPrice,\n\tsetReceiptPrice,\n\tsetProtocol,\n\tsetSampleReport,\n\tsetSampleReportTest,\n\tnewSampleReport,\n\tnewSampleReportTest,\n\tfindSamplesByReceiptId,\n\tgetReceiptPriceByReceiptId,\n\tgetSamplePriceBySampleId,\n\tfindSampleAnalytesBySampleId,\n\tgetSampleAnalyte,\n\tgetSampleReportBySampleId,\n\tgetDepartment,\n\tgetSamplePrice,\n\tgetAnalyteProtocol,\n\tsetSampleAnalyte,\n\tERROR,\n};\n\nglobal.set('layer0', layer0);\n\nglobal.set('bcrypt', bcrypt);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "bcrypt",
                "module": "bcrypt"
            },
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 330,
        "y": 140,
        "wires": [
            [
                "41f21d405706fdf9"
            ]
        ]
    },
    {
        "id": "1433a20f7944ae6c",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "table layer",
        "func": "class Receipt {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#repoClient = global.get('repoClient'); // Client repo\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\t// Addons\n\t#addons = ['client', 'receipt_by_user', 'samples', 'receipt_prices'];\n\n\tconstructor(receipt_id) {\n\t\tthis.id = receipt_id;\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst receipt_inst = new Receipt(id); // create a return instance\n\t\t\treturn await receipt_inst.loadInstance(); // load instance with the receipt data\n\t\t} else throw new Error('Cannot get receipt: Invalid param Receipt ID');\n\t}\n\n\tstatic async getRecentReceipts() {\n\t\ttry {\n\t\t\tconst xanoRes = await global.get('xano').xn_get_recent_receipts();\n\t\t\tif (xanoRes && xanoRes.status === 200) {\n\t\t\t\tconst receipts = xanoRes.data; // [{id: 1}, {id: 2}, ...]\n\t\t\t\tconst receipt_ids = receipts.map((receipt) => receipt.id); // [1, 2, ...]\n\t\t\t\tconst recent_receipts = await Receipt.bulkGet(receipt_ids); // Get full receipt objects by list ids\n\t\t\t\t// Set cache\n\t\t\t\tglobal.get('cache').setRecentReceipts(receipt_ids);\n\t\t\t\treturn recent_receipts;\n\t\t\t} else return [];\n\t\t} catch (error) {\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async search(query) {\n\t\ttry {\n\t\t\t// Validate query\n\t\t\tif (!query || typeof query !== 'string') throw new Error('Invalid search query');\n\n\t\t\t// Search in Xano\n\t\t\tif (global.get('xano').bridge_api) {\n\t\t\t\tconst xanoRes = await global.get('xano').search_receipts(query);\n\t\t\t\tif (xanoRes && xanoRes.status === 200) {\n\t\t\t\t\tconst ids = xanoRes.data.map((receipt) => receipt.id);\n\t\t\t\t\tnode.warn(ids);\n\t\t\t\t\tconst receipts = await Receipt.bulkGet(ids);\n\n\t\t\t\t\treturn receipts;\n\t\t\t\t} else return [];\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new Error(`Cannot search receipt: ${error}`);\n\t\t}\n\t}\n\n\tstatic async bulkGet(ids) {\n\t\ttry {\n\t\t\t// Validate IDs\n\t\t\tif (!Array.isArray(ids)) throw new Error('Cannot get receipts: input must be an array');\n\t\t\tif (!ids.length) return [];\n\n\t\t\tconst result = [];\n\t\t\tconst logMessages = []; // Array to store log messages\n\n\t\t\t// Get data for each receipt id\n\t\t\t// promises array to store all promises\n\t\t\tconst promises = ids.map(async (id) => {\n\t\t\t\ttry {\n\t\t\t\t\tlet receiptFull = global.get('cache').getReceiptFull(id);\n\t\t\t\t\tif (receiptFull) {\n\t\t\t\t\t\t// logMessages.push(`${id} - Cache`);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst receipt = new Receipt(id);\n\t\t\t\t\t\treceiptFull = await receipt.jsonFullXano();\n\t\t\t\t\t\t// logMessages.push(`${id} - Xano`);\n\t\t\t\t\t}\n\t\t\t\t\treturn receiptFull;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogMessages.push(`${id} - Error`);\n\t\t\t\t\tnode.warn(error.stack);\n\t\t\t\t\treturn { id };\n\t\t\t\t}\n\t\t\t});\n\t\t\t// Loop through promises array in chunks of 10\n\t\t\tfor (let i = 0; i < promises.length; i += 20) {\n\t\t\t\t// execute 10 promises concurrently\n\t\t\t\tconst bulkPromises = await Promise.allSettled(promises.slice(i, i + 20));\n\t\t\t\tbulkPromises.forEach((promise) => {\n\t\t\t\t\tif (promise.status === 'fulfilled') {\n\t\t\t\t\t\tresult.push(promise.value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.push(promise.reason);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (logMessages?.length > 0) node.warn(logMessages);\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async create(receipt_object) {\n\t\ttry {\n\t\t\t// Validate inputs\n\t\t\ttableHelper.receiptValidate(receipt_object, true);\n\n\t\t\t// Variables declaration\n\t\t\tlet newReceipt;\n\n\t\t\t// TODO: Add to layer0\n\t\t\t// Add to Xano\n\t\t\tif (global.get('xano').bridge_api) {\n\t\t\t\tconst xanoRes = await global.get('xano').add_receipt({ receipt: receipt_object });\n\t\t\t\tif (xanoRes && xanoRes.status === 200) newReceipt = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// set cache and return receipt instance\n\t\t\tif (newReceipt) {\n\t\t\t\tglobal.get('cache').setReceipt(newReceipt);\n\t\t\t\treturn await Receipt.get(newReceipt.id);\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync createSample(sample_object) {\n\t\ttry {\n\t\t\tsample_object.sample_receipt_id = this.id;\n\t\t\tconst newSample = await Sample.create(sample_object);\n\t\t\treturn newSample;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'addSample');\n\t\t}\n\t}\n\n\tasync update(receipt_object) {\n\t\tawait this.#lazyLoader();\n\t\ttry {\n\t\t\tlet updated_receipt_object;\n\n\t\t\t// Update layer0\n\t\t\t// if (this.#layer0) {\n\t\t\t// \tupdated_receipt_object = await this.#layer0.setReceipt(receipt_object);\n\t\t\t// }\n\n\t\t\t// Update Xano\n\t\t\tif (this.#xano.bridge_api) {\n\t\t\t\tconst xanoRes = await this.#xano.update_receipt(receipt_object);\n\t\t\t\tif (xanoRes && xanoRes.status === 200) updated_receipt_object = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// Update Variables\n\t\t\tif (updated_receipt_object) {\n\t\t\t\tthis.#data = updated_receipt_object; // Update this instance\n\t\t\t\tthis.#cache.setReceipt(updated_receipt_object); // Update cache\n\t\t\t\tconst receiptFull = await this.jsonFullXano(); // Update receiptFull cache\n\t\t\t\tthis.#cache.setReceiptFull(receiptFull);\n\t\t\t}\n\n\t\t\treturn updated_receipt_object;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'update');\n\t\t}\n\t}\n\n\tasync delete(id = this.id) {\n\t\ttry {\n\t\t\t// TODO:\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'delete');\n\t\t}\n\t}\n\n\tasync getSamples() {\n\t\tawait this.#lazyLoader();\n\t\tconst samples = await Sample.findByReceiptId(this.id); // Get samples instances\n\n\t\treturn samples;\n\t}\n\n\tasync getClient() {\n\t\tawait this.#lazyLoader();\n\t\tif (this.client_id) return await Client.get(this.client_id);\n\t\telse return null;\n\t}\n\n\tasync getReceiptByUser() {\n\t\tawait this.#lazyLoader();\n\t\tif (this.receipt_by_user_id) return await User.get(this.receipt_by_user_id);\n\t\telse return null;\n\t}\n\n\tasync getReceiptPrice() {\n\t\tawait this.#lazyLoader();\n\t\t// receipt_price_id is not available in receipt object => receipt.id is used as receipt_price_id\n\t\t// if (this.receipt_price_id) return await ReceiptPrice.getByReceiptId(this.id);\n\t\tif (this.id) return await ReceiptPrice.get(this.id);\n\t\telse return null;\n\t}\n\n\tasync loadInstance() {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id; // Prevent changing the instance ID\n\t\t\tlet receipt_object; // Receipt object\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Invalid receipt ID');\n\n\t\t\t// Try cache\n\t\t\treceipt_object = this.#cache.getReceipt(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!receipt_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (!receipt_object && this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_receipt_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) {\n\t\t\t\t\t\treceipt_object = xanoRes.data;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (receipt_object) {\n\t\t\t\t\tthis.#cache.setReceipt(receipt_object);\n\t\t\t\t\tthis.#data = this.#cache.setReceipt(receipt_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance\n\t\t\tif (receipt_object) {\n\t\t\t\tthis.#data = receipt_object; // Save to instance raw data\n\t\t\t\tthis.#initialized = true; // Set initialized to true\n\t\t\t\tObject.assign(this, receipt_object); // Assign data to instance\n\t\t\t\tthis.#setupGetters(); // Setup getters\n\t\t\t\treturn this; // Return this class\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'load_instance');\n\t\t}\n\t}\n\n\tasync json() {\n\t\tawait this.#lazyLoader();\n\t\tif (!this.#data) throw new Error('Cannot get receipt: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\tasync jsonFullXano() {\n\t\tawait this.#lazyLoader();\n\n\t\t// Packaging full JSON object in Xano Format (including nested objects)\n\t\tconst client = await this.getClient(); // client\n\t\tlet receipt_by_user;\n\t\tif (this.receipt_by_user_id > 0) receipt_by_user = await this.getReceiptByUser(); // receipt_by_user\n\n\t\tconst samples = await this.getSamples(); // samples[]\n\t\tconst receipt_prices = await this.getReceiptPrice(); // receipt_prices\n\n\t\t// Packaging full samples objects\n\t\tconst samples_json = [];\n\t\tfor (const sample of samples) {\n\t\t\tif (!sample ) {\n\t\t\t\tnode.warn(samples);\n\t\t\t\tcontinue\n        \t}\n\t\t\tlet createdBy;\n\t\t\tif (sample?.created_by_id > 0) createdBy = await sample.getCreatedBy(); // created_by\n\n\t\t\tconst reports = await sample.getReports(); // reports\n\t\t\tconst listReports = [];\n\t\t\t\t\n\t\t\tif (reports && Array.isArray(reports) && reports.length > 0) {\n\t\t\t\t\tfor (const report of reports) {\n\t\t\t\t\t\tconst jsonReport = await report.json();\n\t\t\t\t\t\tlistReports.push(jsonReport);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tconst samplePrices = await sample.getSamplePrices(); // sample_prices\n\n\t\t\tconst sampleAnalytes = await sample.getAnalytes(); // test_orders (array)\n\n\t\t\t// Packaging full sampleAnalytes objects\n\t\t\tconst sampleAnalytes_json = [];\n\t\t\tfor (const sampleAnalyte of sampleAnalytes) {\n\t\t\t\tconst assignedDept = await sampleAnalyte.getAssignedDept(); // assigned_to_dept TODO\n\t\t\t\tconst protocol = await sampleAnalyte.getProtocol(); // protocol\n\t\t\t\tlet result_submitted_by;\n\t\t\t\tif (sampleAnalyte.result_submitted_by_id > 0)\n\t\t\t\t\tresult_submitted_by = await User.get(sampleAnalyte.result_submitted_by_id); // result_submitted_by\n\n\t\t\t\t// const testedBy = await sampleAnalyte.getTestedByUser(); // tested_by\n\t\t\t\tlet testedBy;\n\t\t\t\tif (sampleAnalyte.tested_by_user_id > 0) testedBy = await User.get(sampleAnalyte.tested_by_user_id); // tested_by\n\t\t\t\tsampleAnalytes_json.push({\n\t\t\t\t\t...(await sampleAnalyte.json()), // analyte properties\n\t\t\t\t\t...(assignedDept && { assigned_to_dept: await assignedDept.json() }), // assigned_to_dept\n\t\t\t\t\t...(protocol && { protocol: await protocol.json() }), // protocol\n\t\t\t\t\t...(result_submitted_by && { result_submitted_by: await result_submitted_by.json() }), // result_submitted_by\n\t\t\t\t\t...(testedBy && { tested_by: await testedBy.json() }), // tested_by\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsamples_json.push({\n\t\t\t\t...(await sample.json()), // sample properties\n\t\t\t\t...(createdBy && { created_by: await createdBy.json() }), // created_by\n\t\t\t\t...(reports && { reports: listReports }), // reports\n\t\t\t\t...(samplePrices && { sample_prices: await samplePrices.json() }), // sample_prices\n\t\t\t\t...(sampleAnalytes && { test_orders: sampleAnalytes_json }), // test_orders\n\t\t\t});\n\t\t}\n\n\t\tconst fullXano = {\n\t\t\t...(await this.json()),\n\t\t\t...(client && { client: await client.json() }), // client addon\n\t\t\t...(receipt_by_user && { receipt_by_user: await receipt_by_user.json() }), // receipt_by_user addon\n\t\t\t...(receipt_prices && { receipt_prices: await receipt_prices.json() }), // receipt_prices addon\n\t\t\t...(samples && { samples: samples_json }), // samples addon\n\t\t};\n\n\t\t// Set cache\n\t\tif (fullXano) this.#cache.setReceiptFull(fullXano);\n\n\t\treturn fullXano;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance(); // Quick Checking ID\n\t\telse throw new Error('Cannot get receipt: instance is not initialized');\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\t// Handle the error\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - Receipt.${method_name}() - ${error}`);\n\t\tnode.warn(error.stack);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass Sample {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\t#analytes = [];\n\n\t// Addons\n\t#addons = ['created_by', 'sample_prices', 'test_orders'];\n\n\tconstructor(sample_id) {\n\t\tthis.id = sample_id;\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id)) {\n\t\t\tconst sample = new Sample(id); // Create a new sample instance\n\t\t\treturn await sample.loadInstance(); // Load the instance with the sample data\n\t\t} else throw new Error('Cannot get sample: Invalid param Sample ID');\n\t}\n\n\tstatic async getByUid(uid) {\n\t\tif (uid && typeof uid === 'string') {\n\t\t\t// TODO: A235g34\n\t\t} else throw new Error('Cannot get sample: Invalid param Sample UID');\n\t}\n\n\tstatic async create(sample_object) {\n\t\ttry {\n\t\t\t// Validate sample_object\n\t\t\ttableHelper.sampleValidate(sample_object, true);\n\n\t\t\t// Variables declaration\n\t\t\tlet newSample;\n\n\t\t\t// TODO: Add to layer0\n\t\t\t// Send to Xano\n\t\t\tif (global.get('xano').bridge_api) {\n\t\t\t\tconst xanoRes = await global.get('xano').add_sample({ sample: sample_object });\n\t\t\t\tif (xanoRes && xanoRes.status === 200) newSample = xanoRes.data;\n\t\t\t}\n\n\t\t\t// Set cache and return sample instance\n\t\t\tif (newSample) {\n\t\t\t\tglobal.get('cache').setSample(newSample);\n\t\t\t\treturn await Sample.get(newSample.id);\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async getProcessingSamples(userTokenOrId) {\n\t\t/**\n\t\t *\n\t\t * 1. Get list sample from xano\n\t\t *  xn_get_processing_samples()\n\t\t *   structure: samples = [\n\t\t * {\n\t\t * \tid: id of sample,\n\t\t * \treceipt: id of receipt,\n\t\t * \ttest_orders: [id of test_orders],\n\t\t * }, {\n\t\t *\n\t\t * }, ...]\n\t\t *\n\t\t * 2. get full informaton of each sample\n\t\t * 3. set cache processing sample for each sample (user_token.split('.')[1] as key)\n\t\t * 4. return list of sample\n\t\t */\n\n\t\ttry {\n\t\t\t// Get processing samples from cache\n\t\t\tconst processingSamples = global.get('cache').getProcessingSamples(userTokenOrId);\n\t\t\tif (processingSamples) return processingSamples;\n\n\t\t\t// Get from Postgress\n\t\t\tif (Number.isInteger(userTokenOrId)) {\n\t\t\t\t// TODO: Postgress\n\t\t\t} else {\n\t\t\t\t// Get processing samples from Xano\n\t\t\t\tconst xanoRes = await global.get('xano').xn_get_processing_samples(userTokenOrId, true);\n\t\t\t\tif (xanoRes && xanoRes.status === 200) {\n\t\t\t\t\tconst samples = xanoRes.data;\n\t\t\t\t\tconst fullSamples = [];\n\n\t\t\t\t\t// Get full information of each sample\n\t\t\t\t\tfor (const sample of samples) {\n\t\t\t\t\t\tif (sample.test_orders) {\n\t\t\t\t\t\t\t// Get sample\n\t\t\t\t\t\t\tconst sampleInst = new Sample(sample.id);\n\t\t\t\t\t\t\tconst jsonSample = await sampleInst.json();\n\n\t\t\t\t\t\t\t// Get receipt\n\t\t\t\t\t\t\tconst receipt = await Receipt.get(sample.sample_receipt_id);\n\t\t\t\t\t\t\tconst jsonReceipt = await receipt.json();\n\n\t\t\t\t\t\t\t// Get test_orders\n\t\t\t\t\t\t\tlet test_orders = [];\n\t\t\t\t\t\t\tfor (const sample_analyte of sample.test_orders) {\n\t\t\t\t\t\t\t\tlet protocol;\n\t\t\t\t\t\t\t\tif (sample_analyte.protocol_id) {\n\t\t\t\t\t\t\t\t\tprotocol = await AnalyteProtocol.get(sample_analyte.protocol_id);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttest_orders.push({\n\t\t\t\t\t\t\t\t\t...sample_analyte,\n\t\t\t\t\t\t\t\t\tprotocol: protocol ? await protocol.json() : null,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfullSamples.push({\n\t\t\t\t\t\t\t\t...jsonSample,\n\t\t\t\t\t\t\t\treceipt: jsonReceipt,\n\t\t\t\t\t\t\t\ttest_orders: test_orders,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set cache processing samples\n\t\t\t\t\tglobal.get('cache').setProcessingSamples(userTokenOrId, fullSamples);\n\n\t\t\t\t\t// Return list of samples\n\t\t\t\t\treturn fullSamples;\n\t\t\t\t} else {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new Error(`Cannot get processing samples: ${error}`);\n\t\t}\n\t}\n\n\tasync update(sample_object) {\n\t\ttry {\n\t\t\t//lazy loader\n\t\t\tawait this.#lazyLoader();\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(this.id) || this.id <= 0) throw new Error('Invalid sample ID');\n\n\t\t\tlet updated_sample_object;\n\n\t\t\t// TODO: Update layer0\n\n\t\t\t// Update Xano\n\t\t\tif (this.#xano.bridge_api) {\n\t\t\t\tconst xanoRes = await this.#xano.update_sample(sample_object);\n\t\t\t\tif (xanoRes && xanoRes.status === 200) updated_sample_object = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// Update cache\n\t\t\tif (updated_sample_object) {\n\t\t\t\tthis.#data = updated_sample_object;\n\t\t\t\tthis.#cache.setSample(updated_sample_object);\n\t\t\t\t// Set cache ReceiptFull\n\t\t\t\tconst receipt = await Receipt.get(updated_sample_object.sample_receipt_id);\n\t\t\t\tconst receiptFull = await receipt.jsonFullXano();\n\t\t\t\tthis.#cache.setReceiptFull(receiptFull);\n\t\t\t}\n\n\t\t\treturn updated_sample_object;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'update');\n\t\t}\n\t}\n\n\tasync createSampleAnalyte(analyte_object) {\n\t\t/** Create a new Sample Analyte to this sample instance\n\t\t * @param {object} analyte_object - The analyte object to create\n\t\t * @returns {object} newSampleAnalyteObj - The new sample analyte object\n\t\t */\n\t\tawait this.#lazyLoader();\n\t\ttry {\n\t\t\t// Validate analyte_object\n\t\t\tif (!analyte_object || typeof analyte_object !== 'object') throw new Error('Invalid analyte object');\n\n\t\t\t// Variable declaration\n\t\t\tlet newSampleAnalyteObj;\n\t\t\tlet newSampleAnalyteIns;\n\n\t\t\t// copy over analyte properties from lib_test_id or analyte_id if given\n\t\t\tif (analyte_object.lib_test_id || analyte_object.analyte_id) {\n\t\t\t\tnewSampleAnalyteObj = await Analyte.convertSampleAnalyte(\n\t\t\t\t\tanalyte_object.lib_test_id || analyte_object.analyte_id,\n\t\t\t\t\tthis.id,\n\t\t\t\t\tthis.sample_receipt_id || this.receipt_id,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tnewSampleAnalyteIns = await SampleAnalyte.create(newSampleAnalyteObj);\n\t\t\tif (newSampleAnalyteIns) {\n\t\t\t\tthis.#analytes.push(newSampleAnalyteIns);\n\t\t\t\treturn await newSampleAnalyteIns.json();\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'createSampleAnalyte');\n\t\t}\n\t}\n\n\tasync delete() {\n\t\t// TODO (delete from cache, xano AND layer 0 )\n\t\t//delete cascade: sampleAnalytes, samplePrices, sampleReports\n\t\ttry {\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(this.id) || this.id <= 0) throw new Error('Invalid sample ID');\n\n\t\t\t// Delete layer0\n\t\t\t// if (this.#layer0) {\n\t\t\t// \tawait this.#layer0.delSample(this.id);\n\t\t\t// }\n\n\t\t\t// Delete Xano\n\t\t\tif (this.#xano.bridge_api) {\n\t\t\t\tawait this.#xano.delete_sample({ sample: await this.json() });\n\t\t\t}\n\n\t\t\t// Delete cache\n\t\t\tthis.#cache.delSample(this.id);\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'delete');\n\t\t}\n\t}\n\n\tasync loadInstance() {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id;\n\t\t\tlet sample_object;\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id)) throw new Error('Invalid sample ID');\n\n\t\t\t// try cache\n\t\t\tsample_object = this.#cache.getSample(id);\n\n\t\t\t// if cache is missed try other resources\n\t\t\tif (!sample_object) {\n\t\t\t\t// TODO: Layer0\n\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (!sample_object && this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_sample_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) sample_object = xanoRes.data;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (sample_object) {\n\t\t\t\t\tthis.#cache.setSample(sample_object);\n\t\t\t\t\tthis.#data = this.#cache.setSample(sample_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// setup instance if data is found else return null\n\t\t\tif (sample_object) {\n\t\t\t\tthis.#data = sample_object; // Save to instance raw data\n\t\t\t\tObject.assign(this, sample_object); // Assign data to instance\n\t\t\t\tthis.#initialized = true; // Set initialized to true\n\t\t\t\tthis.#setupGetters(); // Setup getters\n\t\t\t\treturn this; // Return this class\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'load_instance');\n\t\t}\n\t}\n\n\tstatic async findByReceiptId(receiptOrId) {\n\t\ttry {\n\t\t\t// Validate ID\n\t\t\tconst receipt_id = Number.isInteger(receiptOrId) ? receiptOrId : receiptOrId.id;\n\t\t\tif (!Number.isInteger(receipt_id) || receipt_id <= 0) throw new Error('Cannot find samples: Invalid receipt ID');\n\n\t\t\t// Variable declaration\n\t\t\tlet sample_ids = [];\n\t\t\tlet hasRedPg = false;\n\t\t\tconst layer0 = global.get('layer0'); // Postgres connector layer\n\t\t\tconst xano = global.get('xano');\n\n\t\t\t// Try search layer0\n\t\t\t// sample_ids = await layer0.findSamplesByReceiptId(receipt_id);\n\t\t\t// if (sample_ids && Array.isArray(sample_ids) && sample_ids.length) hasRedPg = true;\n\n\t\t\t// Try search xano if layer0 has no result\n\t\t\tif (!hasRedPg && xano && xano.bridge_api) {\n\t\t\t\tconst xanoRes = await xano.find_samples_by_receipt_id(receipt_id);\n\t\t\t\tif (xanoRes && xanoRes.status === 200)\n\t\t\t\t\tsample_ids = xanoRes.data.map((sample) => {\n\t\t\t\t\t\treturn sample.id;\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\t// if found sample_ids, run all Sample.get() operations concurrently\n\t\t\tif (sample_ids && Array.isArray(sample_ids) && sample_ids.length) {\n\t\t\t\tconst sample_classes = [];\n\t\t\t\tfor (const sample_id of sample_ids) {\n\t\t\t\t\tconst sample = await Sample.get(sample_id);\n\t\t\t\t\tsample_classes.push(sample);\n\t\t\t\t}\n\t\t\t\treturn sample_classes;\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getCreatedBy() {\n\t\tawait this.#lazyLoader();\n\t\tif (this.created_by_id) return this.created_by_id ? await User.get(this.created_by_id) : null;\n\t}\n\n\tasync getSamplePrices() {\n\t\tawait this.#lazyLoader();\n\t\treturn await SamplePrice.getBySampleId(this.id);\n\t}\n\n\tasync getAnalytes(json = false) {\n\t\tawait this.#lazyLoader();\n\t\tconst analytes = await SampleAnalyte.findBySampleId(this.id);\n\t\tthis.#analytes = analytes;\n\t\treturn json ? analytes.map((analyte) => analyte.json()) : analytes;\n\t}\n\n\tasync getReports() {\n\t\tawait this.#lazyLoader();\n\t\tconst reports = await SampleReport.findBySampleId(this.id);\n\t\treturn reports\n\t}\n\n\tasync json() {\n\t\tawait this.#lazyLoader();\n\t\tif (!this.#data) throw new Error('Cannot get sample: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\tasync getFullXano() {\n\t\treturn this;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance(); // Quick Checking ID\n\t\telse throw new Error('Cannot get sample: instance is not initialized');\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\t// Handle the error\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - Sample.${method_name}() - ${error}`);\n\t\tnode.warn(error);\n\t\t// API response\n\t\terror.statusCode = 500; // Internal Server Error\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass SampleAnalyte {\n\t#initialized = false;\n\t#layer0 = null; // TODO: global.get('layer0'); // Postgres layer\n\t#cache = global.get('cache'); // Cache layer\n\t#xano = global.get('xano'); // Xano layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(sample_analyte_id, data) {\n\t\tthis.id = sample_analyte_id;\n\t\tif (data) {\n\t\t\tthis.#data = data;\n\t\t\tthis.#initialized = true;\n\t\t}\n\t}\n\n\tstatic async get(id) {\n\t\tconst sampleAnalyte = new SampleAnalyte(id);\n\t\treturn await sampleAnalyte.loadInstance();\n\t}\n\n\tstatic async create(sampleAnalyte_object) {\n\t\ttry {\n\t\t\ttableHelper.validateSampleAnalyte(sampleAnalyte_object, true);\n\t\t\tlet newSampleAnalyte;\n\n\t\t\t// TODO: Add to layer0\n\t\t\t// Add to Xano\n\t\t\tif (global.get('xano').bridge_api) {\n\t\t\t\tconst xanoRes = await global.get('xano').add_sample_analyte({ sample_analyte: sampleAnalyte_object });\n\t\t\t\tif (xanoRes && xanoRes.status === 200) newSampleAnalyte = xanoRes.data;\n\t\t\t}\n\n\t\t\t// Set cache and return sampleAnalyte instance\n\t\t\tif (newSampleAnalyte) {\n\t\t\t\tglobal.get('cache').setSampleAnalyte(newSampleAnalyte);\n\t\t\t\treturn await SampleAnalyte.get(newSampleAnalyte.id);\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthrow new Error(`Cannot add sample analyte: ${error}`);\n\t\t}\n\t}\n\n\tasync update(sampleAnalyte_object) {\n\t\t// TODO (update cache, xano AND layer 0 )\n\t\ttry {\n\t\t\t// Lazy loader\n\t\t\tawait this.#lazyLoader();\n\t\t\tsampleAnalyte_object.id = this.id;\n\n\t\t\t// Validate sampleAnalyte_object\n\t\t\tif (!sampleAnalyte_object || typeof sampleAnalyte_object !== 'object')\n\t\t\t\tthrow new Error('Invalid sample analyte object');\n\n\t\t\tlet updated_sampleAnalyte_object;\n\t\t\t// Update layer0\n\t\t\t// if (this.#layer0) {\n\t\t\t// \tupdated_sampleAnalyte_object = await this.#layer0.setSampleAnalyte(sampleAnalyte_object);\n\t\t\t// }\n\n\t\t\t// Update Xano\n\t\t\tif (this.#xano.bridge_api) {\n\t\t\t\tconst xanoRes = await this.#xano.update_test_order({ sample_analyte: sampleAnalyte_object });\n\t\t\t\tif (xanoRes && xanoRes.status === 200) updated_sampleAnalyte_object = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// Update cache\n\t\t\tif (updated_sampleAnalyte_object) {\n\t\t\t\tthis.#cache.setSampleAnalyte(updated_sampleAnalyte_object);\n\n\t\t\t\t// Duyệt qua từng key (user token) và value (userProcessingSamples) trong object\n\t\t\t\tObject.entries(this.#cache.processingSamples).forEach(([token, userSample]) => {\n\t\t\t\t\t// Lấy value từ userSample\n\t\t\t\t\tconst userProcessingSamples = userSample.value;\n\n\t\t\t\t\t// Tìm sample theo sample_id\n\t\t\t\t\tconst sample = userProcessingSamples.find((sample) => sample.id === updated_sampleAnalyte_object.sample_id);\n\n\t\t\t\t\tif (sample) {\n\t\t\t\t\t\t// Tìm index của test_order theo id\n\t\t\t\t\t\tconst indexTestOrder = sample.test_orders.findIndex((test) => test.id === updated_sampleAnalyte_object.id);\n\n\t\t\t\t\t\tif (indexTestOrder >= 0) {\n\t\t\t\t\t\t\t// Cập nhật giá trị trong test_orders tại index tìm được\n\t\t\t\t\t\t\tsample.test_orders[indexTestOrder] = updated_sampleAnalyte_object;\n\t\t\t\t\t\t\tnode.warn(`Test order updated for token: ${token}, sample_id: ${sample.id}`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode.warn(`Test not found in processing sample for token: ${token}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.warn(`Sample not found for token: ${token}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// update cache receipt full\n\t\t\t\tconst receiptId = updated_sampleAnalyte_object.sample_receipt_id;\n\t\t\t\tif (receiptId) {\n\t\t\t\t\tconst receipt = new Receipt(receiptId);\n\t\t\t\t\tconst fullReceipt = await receipt.jsonFullXano();\n\t\t\t\t\tthis.#cache.setReceiptFull(fullReceipt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn updated_sampleAnalyte_object;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'update');\n\t\t}\n\t}\n\n\tasync editFee(fee) {\n\t\ttry {\n\t\t\t// Lazy loader\n\t\t\tawait this.#lazyLoader();\n\n\t\t\tlet updated_sampleAnalyte_object = await this.json();\n\n\t\t\tupdated_sampleAnalyte_object.fee = fee;\n\t\t\tdelete updated_sampleAnalyte_object.created_at;\n\n\t\t\t//TODO: Update layer0\n\n\t\t\t// Update Xano\n\t\t\tif (this.#xano.bridge_api) {\n\t\t\t\tconst xanoRes = await this.#xano.update_fee({\n\t\t\t\t\tsample_analyte: updated_sampleAnalyte_object,\n\t\t\t\t\tfee: fee,\n\t\t\t\t});\n\t\t\t\tif (xanoRes && xanoRes.status === 200) updated_sampleAnalyte_object = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// Update cache\n\t\t\t// this.#cache.setSampleAnalyte(updated_sampleAnalyte_object);\n\t\t\tif (updated_sampleAnalyte_object) {\n\t\t\t\tthis.#cache.setSampleAnalyte(updated_sampleAnalyte_object);\n\n\t\t\t\t//update cache receipt full\n\t\t\t\tconst receiptId = updated_sampleAnalyte_object.sample_receipt_id;\n\t\t\t\tif (receiptId) {\n\t\t\t\t\tconst receipt = new Receipt(receiptId);\n\t\t\t\t\tconst fullReceipt = await receipt.jsonFullXano();\n\t\t\t\t\tthis.#cache.setReceiptFull(fullReceipt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await this.loadInstance();\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'updateFee');\n\t\t}\n\t}\n\n\tasync delete() {\n\t\tawait this.#lazyLoader();\n\t\ttry {\n\t\t\t// Delete layer0\n\t\t\tconst objectDelete = await this.json();\n\t\t\tif (!objectDelete.sample_id && !objectDelete.sample_receipt_id)\n\t\t\t\tthrow new Error('Delete sample analyte: Invalid sample analyte object');\n\n\t\t\t// if (this.#layer0) {\n\t\t\t// \tawait this.#layer0.delTestOrder(this.id);\n\t\t\t// }\n\n\t\t\t// Delete Xano\n\t\t\tif (this.#xano.bridge_api) {\n\t\t\t\tawait this.#xano.delete_sample_analyte({ sample_analyte: objectDelete });\n\t\t\t}\n\n\t\t\t// Delete cache\n\t\t\tthis.#cache.delSampleAnalyte(this.id);\n\t\t\t//update cache receipt full\n\t\t\tconst receiptId = objectDelete.sample_receipt_id;\n\t\t\t// update\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'delete');\n\t\t}\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id; // Prevent changing the instance ID\n\t\t\tlet sampleAnalyte_object; // sampleAnalyte object\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Cannot load sample analyte: Invalid sample analyte ID');\n\n\t\t\t// Try local cache\n\t\t\tsampleAnalyte_object = this.#cache.getSampleAnalyte(id);\n\n\t\t\t// Try Other Resources\n\t\t\tif (!sampleAnalyte_object) {\n\t\t\t\t// TODO: try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_test_order_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) sampleAnalyte_object = xanoRes.data;\n\t\t\t\t\telse return null;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (sampleAnalyte_object) {\n\t\t\t\t\tthis.#cache.setSampleAnalyte(sampleAnalyte_object);\n\t\t\t\t\tthis.#data = this.#cache.setSampleAnalyte(sampleAnalyte_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance\n\t\t\tif (sampleAnalyte_object) {\n\t\t\t\tthis.#data = sampleAnalyte_object; // Save to instance raw data\n\t\t\t\tthis.#initialized = true; // Set initialized to true\n\t\t\t\tObject.assign(this, sampleAnalyte_object); // Assign data to instance\n\t\t\t\tthis.#setupGetters(); // Setup getters\n\t\t\t\treturn this; // Return this class\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'load_instance');\n\t\t}\n\t}\n\n\tstatic async findBySampleId(sample_id) {\n\t\ttry {\n\t\t\tlet sample_analytes = [];\n\t\t\tlet hasRedPg = false;\n\t\t\tconst layer0 = global.get('layer0'); // Postgres connector layer\n\t\t\tconst xano = global.get('xano');\n\n\t\t\t// Try search layer0\n\t\t\t// sample_analytes = await layer0.findSampleAnalytesBySampleId(sample_id);\n\t\t\t// if (sample_analytes && Array.isArray(sample_analytes) && sample_analytes.length) hasRedPg = true;\n\n\t\t\t// Try search xano if layer0 has no result\n\t\t\tif (!hasRedPg && xano && xano.bridge_api) {\n\t\t\t\tconst xanoRes = await xano.find_test_orders_by_sample_id(sample_id);\n\t\t\t\tif (xanoRes && xanoRes.status === 200) sample_analytes = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// if found sample_analytes, run all SampleAnalyte.get() operations concurrently\n\t\t\tif (sample_analytes && Array.isArray(sample_analytes)) {\n\t\t\t\tconst sampleAnalyte_classes = sample_analytes.map((sample_analyte) => {\n\t\t\t\t\t// Set cache\n\t\t\t\t\tglobal.get('cache').setSampleAnalyte(sample_analyte);\n\t\t\t\t\t// Create a new SampleAnalyte instance\n\t\t\t\t\tconst sampleAnalyte = new SampleAnalyte(sample_analyte.id, sample_analyte);\n\t\t\t\t\tObject.assign(sampleAnalyte, sample_analyte);\n\t\t\t\t\t// sampleAnalyte.#initialized = true;\n\t\t\t\t\treturn sampleAnalyte;\n\t\t\t\t});\n\t\t\t\treturn sampleAnalyte_classes;\n\t\t\t} else return [];\n\t\t} catch (error) {\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async getByUid(sample_uid) {\n\t\tif (sample_uid && typeof sample_uid === 'string') {\n\t\t\ttry {\n\t\t\t\t// Get sample data from Xano\n\t\t\t\tconst xanoRes = await global.get('xano').get_sample_analytes_by_uid(sample_uid);\n\t\t\t\tif (xanoRes && xanoRes.status === 200) {\n\t\t\t\t\tconst sampleAnalytes = xanoRes.data;\n\t\t\t\t\treturn sampleAnalytes;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} catch (error) {\n\t\t\t\tnode.warn(error.stack);\n\t\t\t\terror.statusCode = 500;\n\t\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getAssignedDept() {\n\t\tawait this.#lazyLoader();\n\t\tif (this.assigned_to_dept_id) {\n\t\t\treturn await Departments.get(this.assigned_to_dept_id);\n\t\t} else return null;\n\t}\n\n\tasync getProtocol() {\n\t\tawait this.#lazyLoader();\n\t\tif (this.protocol_id) {\n\t\t\treturn await AnalyteProtocol.get(this.protocol_id);\n\t\t} else return null;\n\t}\n\n\tasync getTestedByUser() {\n\t\tawait this.#lazyLoader();\n\t\tif (this.tested_by_user_id) {\n\t\t\treturn await User.get(this.tested_by_user_id);\n\t\t} else return null;\n\t}\n\n\tasync getResultSubmittedByUser() {\n\t\tawait this.#lazyLoader();\n\t\tif (this.result_submitted_by_id) {\n\t\t\treturn await User.get(this.result_submitted_by_id);\n\t\t} else return null;\n\t}\n\n\tasync setResult(result) {\n\t\t/**\n\t\t * result = {\n\t\t * \tresult_value: string,\n\t\t * \tresult_unit: string,\n\t\t * \ttested_by_user_id: number,\n\t\t * \tresult_submitted_by_id: number,\n\t\t * \tresult_submitted_at: timestamp,\n\t\t * }\n\t\t */\n\t\tawait this.#lazyLoader();\n\t\ttry {\n\t\t\t// Validate result\n\t\t\tif (!result || typeof result !== 'object') throw new Error('Invalid result object');\n\t\t\tif (!result.result_value) {\n\t\t\t\tconst error = new Error('Invalid result object: result_value is required');\n\t\t\t\terror.statusCode = 400;\n\t\t\t\terror.errorMessage = 'Bad Request';\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\t// Making sure only these keys are allowed\n\t\t\tconst result_validated = {\n\t\t\t\tresult_value: result.result_value,\n\t\t\t\tresult_unit: result.result_unit,\n\t\t\t\ttested_by_user_id: result.tested_by_user_id,\n\t\t\t\tresult_submitted_by_id: result.result_submitted_by_id,\n\t\t\t\tresult_submitted_at: result.result_submitted_at,\n\t\t\t};\n\n\t\t\t// TODO: Update to layer0\n\t\t\tif (this.#layer0) {\n\t\t\t}\n\n\t\t\t// Update to Xano\n\t\t\tif (this.#xano && this.#xano.bridge_api) {\n\t\t\t\tawait this.#xano.update_test_order(result_validated);\n\t\t\t}\n\n\t\t\t// Set result\n\t\t\tthis.result = result;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'setResult');\n\t\t}\n\t}\n\n\tasync setProtocol(protocol_obj) {\n\t\tawait this.#lazyLoader();\n\t\tif (!protocol_obj || typeof protocol_obj !== 'object') throw new Error('Invalid protocol object');\n\n\t\t// Variable declaration\n\t\tlet updated_analyte_obj;\n\t\tlet protocol_obj_validated;\n\t\tconst protocol_id = protocol_obj.id || protocol_obj.protocol_id;\n\n\t\t// Lấy protocol data\n\t\tif (protocol_id) {\n\t\t\tconst protocolIns = new AnalyteProtocol(protocol_id);\n\t\t\tprotocol_obj_validated = {\n\t\t\t\tprotocol_id: protocol_id,\n\t\t\t\tvlas: protocolIns.vlas,\n\t\t\t\toutsourced: protocolIns.outsourced,\n\t\t\t\tprotocol_source: protocolIns.protocol_source,\n\t\t\t\tprotocol_value: protocolIns.protocol_value,\n\t\t\t};\n\t\t} else {\n\t\t\tprotocol_obj_validated = {\n\t\t\t\tprotocol_id: protocol_obj.id,\n\t\t\t\tvlas: protocol_obj.vlas,\n\t\t\t\toutsourced: protocol_obj.outsourced,\n\t\t\t\tprotocol_source: protocol_obj.protocol_source,\n\t\t\t\tprotocol_value: protocol_obj.protocol_value,\n\t\t\t};\n\t\t}\n\n\t\t// TODO: Update to layer0\n\n\t\t// Update to Xano\n\t\tif (this.#xano && this.#xano.bridge_api) {\n\t\t\tupdated_analyte_obj = await this.#xano.update_test_order(protocol_obj_validated);\n\t\t}\n\n\t\t// update cache and local data\n\t\tthis.#cache.setSampleAnalyte(updated_analyte_obj);\n\t\tthis.#data = updated_analyte_obj;\n\n\t\treturn updated_analyte_obj;\n\t}\n\n\tasync json() {\n\t\tawait this.#lazyLoader();\n\t\tif (!this.#data) throw new Error('Cannot get sample analyte: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance();\n\t\telse throw new Error('Cannot get sample analyte: instance is not initialized');\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - SampleAnalyte.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass Analyte {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(analyte_id) {\n\t\tthis.id = analyte_id;\n\t}\n\n\tstatic async create(analyte_object) {\n\t\ttry {\n\t\t\t// Validate analyte_object\n\t\t\tif (!analyte_object || typeof analyte_object !== 'object') throw new Error('Invalid analyte object');\n\n\t\t\t// Add to layer0\n\t\t\tif (global.get('layer0').newTest) {\n\t\t\t\tconst resLayer0 = await global.get('layer0').newTest(analyte_object);\n\t\t\t\tanalyte_object = resLayer0;\n\t\t\t}\n\n\t\t\t// Add to Xano\n\t\t\tif (global.get('xano').bridge_api && global.get('xano').add_anlyte) {\n\t\t\t\tconst xanoRes = await global.get('xano').add_anlyte({ analyte: analyte_object });\n\t\t\t\tif (xanoRes && xanoRes.status === 200) analyte_object = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// Add to cache\n\t\t\tglobal.get('cache').setAnalyte(analyte_object);\n\n\t\t\treturn analyte_object;\n\t\t} catch (error) {\n\t\t\tthrow new Error(`Cannot add analyte: ${error}`);\n\t\t}\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst analyte = new Analyte(id);\n\t\t\treturn await analyte.loadInstance();\n\t\t} else throw new Error('Cannot get analyte: Invalid param Analyte ID');\n\t}\n\n\tstatic async searchAnalytes(search_params) {\n\t\t// TODO: find analytes in layer0 first, if not found, then search in xano\n\t}\n\n\tstatic async convertSampleAnalyte(analyte_id, sample_id, receipt_id) {\n\t\t// get analyte object\n\t\tconst instanceAnalyte = await Analyte.get(analyte_id);\n\t\tconst objectAnalyte = await instanceAnalyte.json();\n\n\t\t// if analyte is not found, return null\n\t\tif (!objectAnalyte) return null;\n\n\t\t// create sample analyte object\n\t\tconst objectSampleAnalyte = {\n\t\t\tsample_id: sample_id,\n\t\t\tsample_receipt_id: receipt_id,\n\t\t\tlib_test_id: analyte_id,\n\t\t};\n\n\t\t// copy all keys from analyte object to sample analyte object\n\t\tconst keysToCopy = [\n\t\t\t'test_name',\n\t\t\t'test_name_secondary',\n\t\t\t'std_ref',\n\t\t\t'fee',\n\t\t\t'protocol_id',\n\t\t\t'vlas',\n\t\t\t'outsource',\n\t\t\t'protocol_source',\n\t\t\t'result_unit',\n\t\t\t'protocol_value',\n\t\t];\n\n\t\tfor (const key of keysToCopy) {\n\t\t\tobjectSampleAnalyte[key] = instanceAnalyte[key];\n\t\t}\n\n\t\tobjectSampleAnalyte.assigned_to_dept_id = objectAnalyte.dept_id;\n\n\t\t// return sample analyte object\n\t\treturn objectSampleAnalyte;\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id;\n\t\t\tlet analyte_object;\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Cannot load analyte: Invalid analyte ID');\n\n\t\t\t// Try cache\n\t\t\tanalyte_object = this.#cache.getAnalyte(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!analyte_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_analyte_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) analyte_object = xanoRes.data;\n\t\t\t\t\telse return null;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (analyte_object) {\n\t\t\t\t\tthis.#cache.setAnalyte(analyte_object);\n\t\t\t\t\tthis.#data = this.#cache.setAnalyte(analyte_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance if data is found\n\t\t\tif (analyte_object) {\n\t\t\t\tthis.#data = analyte_object;\n\t\t\t\tthis.#initialized = true;\n\t\t\t\tObject.assign(this, analyte_object);\n\t\t\t\tthis.#setupGetters();\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'loadInstance');\n\t\t}\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync json() {\n\t\tawait this.#lazyLoader();\n\t\tif (!this.#data) throw new Error('Cannot get analyte: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance();\n\t\telse throw new Error('Cannot get analyte: instance is not initialized');\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - Analyte.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass SamplePrice {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(sample_price_id) {\n\t\tthis.id = sample_price_id;\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst samplePrice = new SamplePrice(id);\n\t\t\treturn await samplePrice.loadInstance();\n\t\t} else throw new Error('Cannot get sample price: Invalid param Sample Price ID');\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id;\n\t\t\tlet sample_price_object;\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Cannot load sample price: Invalid sample price ID');\n\n\t\t\t// Try cache\n\t\t\tsample_price_object = this.#cache.getSamplePrice(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!sample_price_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_sample_price_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) sample_price_object = xanoRes.data;\n\t\t\t\t\telse return null;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (sample_price_object) {\n\t\t\t\t\tthis.#cache.setSamplePrice(sample_price_object);\n\t\t\t\t\tthis.#data = this.#cache.setSamplePrice(sample_price_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance if data is found\n\t\t\tif (sample_price_object) {\n\t\t\t\tthis.#data = sample_price_object;\n\t\t\t\tthis.#initialized = true;\n\t\t\t\tObject.assign(this, sample_price_object);\n\t\t\t\tthis.#setupGetters();\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'loadInstance');\n\t\t}\n\t}\n\n\tstatic async getBySampleId(sample_id) {\n\t\ttry {\n\t\t\tif (!Number.isInteger(sample_id) || sample_id <= 0)\n\t\t\t\tthrow new Error('Cannot find sample price: Invalid sample ID');\n\t\t\tconst layer0 = global.get('layer0');\n\t\t\t// Get sample price object\n\t\t\tlet sample_price_object = await layer0.getSamplePriceBySampleId(sample_id);\n\t\t\t// try xano\n\t\t\tif (!sample_price_object && global.get('xano') && global.get('xano').bridge_api) {\n\t\t\t\tconst xanoRes = await global.get('xano').get_sample_price_by_sample_id(sample_id);\n\t\t\t\tif (xanoRes && xanoRes.status === 200) sample_price_object = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\t\t\t// return instance\n\t\t\tconst instanceSamplePrice = new SamplePrice(sample_price_object.id);\n\t\t\tawait instanceSamplePrice.loadInstance();\n\t\t\treturn instanceSamplePrice;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - SamplePrice.getBySampleId()`);\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync json() {\n\t\tawait this.#lazyLoader();\n\t\tif (!this.#data) throw new Error('Cannot get sample price: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - SamplePrice.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance();\n\t\telse throw new Error('Cannot get sample price: instance is not initialized');\n\t}\n}\n\nclass ReceiptPrice {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(receipt_price_id) {\n\t\tthis.id = receipt_price_id;\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst receiptPrice = new ReceiptPrice(id);\n\t\t\treturn await receiptPrice.loadInstance();\n\t\t} else throw new Error('Cannot get receipt price: Invalid param Receipt Price ID');\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id;\n\t\t\tlet receipt_price_object;\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Cannot load receipt price: Invalid receipt price ID');\n\n\t\t\t// Try cache\n\t\t\treceipt_price_object = this.#cache.getReceiptPrice(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!receipt_price_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_receipt_price_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) receipt_price_object = xanoRes.data;\n\t\t\t\t\telse return null;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (receipt_price_object) {\n\t\t\t\t\tthis.#cache.setReceiptPrice(receipt_price_object);\n\t\t\t\t\tthis.#data = this.#cache.setReceiptPrice(receipt_price_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance if data is found\n\t\t\tif (receipt_price_object) {\n\t\t\t\tthis.#data = receipt_price_object;\n\t\t\t\tthis.#initialized = true;\n\t\t\t\tObject.assign(this, receipt_price_object);\n\t\t\t\tthis.#setupGetters();\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'loadInstance');\n\t\t}\n\t}\n\n\tstatic async getByReceiptId(receipt_id) {\n\t\ttry {\n\t\t\tif (!Number.isInteger(receipt_id) || receipt_id <= 0)\n\t\t\t\tthrow new Error('Cannot find receipt price: Invalid receipt ID');\n\t\t\tconst layer0 = global.get('layer0');\n\t\t\t// Get receipt price object\n\t\t\tconst receipt_price_object = await layer0.getReceiptPriceByReceiptId(receipt_id);\n\t\t\t// Create instance\n\t\t\tconst instanceReceiptPrice = new ReceiptPrice(receipt_price_object.id);\n\t\t\tawait instanceReceiptPrice.loadInstance();\n\t\t\treturn instanceReceiptPrice;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - ReceiptPrice.getByReceiptId()`);\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tjson() {\n\t\tif (!this.#data) throw new Error('Cannot get receipt price: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - ReceiptPrice.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass SampleReport {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(sample_report_id) {\n\t\tthis.id = sample_report_id;\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst sampleReport = new SampleReport(id);\n\t\t\treturn await sampleReport.loadInstance();\n\t\t} else throw new Error('Cannot get sample report: Invalid param Sample Report ID');\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id;\n\t\t\tlet sample_report_object;\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Cannot load sample report: Invalid sample report ID');\n\n\t\t\t// Try cache\n\t\t\tsample_report_object = this.#cache.getSampleReport(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!sample_report_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (!sample_report_object && this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_sample_report_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) sample_report_object = xanoRes.data;\n\t\t\t\t\telse return null;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (sample_report_object) {\n\t\t\t\t\tthis.#cache.setSampleReport(sample_report_object);\n\t\t\t\t\tthis.#data = this.#cache.setSampleReport(sample_report_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance if data is found\n\t\t\tif (sample_report_object) {\n\t\t\t\tthis.#data = sample_report_object;\n\t\t\t\tthis.#initialized = true;\n\t\t\t\tObject.assign(this, sample_report_object);\n\t\t\t\tthis.#setupGetters();\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'loadInstance');\n\t\t}\n\t}\n\n\tstatic async findBySampleId(sample_id) {\n\t\ttry {\n\t\t\t// Validate sample_id\n\t\t\tif (!Number.isInteger(sample_id) || sample_id <= 0)\n\t\t\t\tthrow new Error('Cannot find sample report: Invalid sample ID');\n\n\t\t\tlet sample_report_objects;\n\t\t\t// Variables declaration\n\t\t\t// const layer0 = global.get('layer0');\n\t\t\t// let sample_report_objects = await layer0.getSampleReportBySampleId(sample_id);\n\n\t\t\t// try xano\n\t\t\tif (!sample_report_objects && global.get('xano') && global.get('xano').bridge_api) {\n\t\t\t\tconst xanoRes = await global.get('xano').get_sample_report_by_sample_id(sample_id);\n\t\t\t\tif (xanoRes && xanoRes.status === 200) {\n\t\t\t\t\tsample_report_objects = xanoRes.data\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// return empty array if no sample report found\n\t\t\tif (!sample_report_objects || !Array.isArray(sample_report_objects) || sample_report_objects.length === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// return list of SampleReport instances\n\n\t\t\tconst instanceSampleReports = sample_report_objects.map((sample_report_object) => {\n\t\t\t\treturn new SampleReport(sample_report_object.id);\n\t\t\t});\n\n\t\t\tfor (const instance of instanceSampleReports) {\n\t\t\t\tawait instance.loadInstance();\n\t\t\t}\n\t\t\t\n\t\t\treturn instanceSampleReports;\n\t\t} catch (error) {\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync json() {\n\t\tawait this.#lazyLoader();\n\t\tif (!this.#data) throw new Error('Cannot get sample report: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance();\n\t\telse throw new Error('Cannot get sample report: instance is not initialized');\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - SampleReport.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass AnalyteProtocol {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(analyte_protocol_id) {\n\t\tthis.id = analyte_protocol_id;\n\t}\n\n\tstatic async add(analyte_protocol_object) {\n\t\ttry {\n\t\t\t// Validate analyte_protocol_object\n\t\t\tif (!analyte_protocol_object || typeof analyte_protocol_object !== 'object')\n\t\t\t\tthrow new Error('Invalid analyte protocol object');\n\n\t\t\t// Add to layer0\n\t\t\tif (global.get('layer0').newLibProtocol) {\n\t\t\t\tconst resLayer0 = await global.get('layer0').newLibProtocol(analyte_protocol_object);\n\t\t\t\tanalyte_protocol_object = resLayer0;\n\t\t\t}\n\n\t\t\t// Add to Xano\n\t\t\tif (global.get('xano').bridge_api) {\n\t\t\t\tconst xanoRes = await global.get('xano').add_analyte_protocol({ analyte_protocol: analyte_protocol_object });\n\t\t\t\tif (xanoRes && xanoRes.status === 200) analyte_protocol_object = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// Add to cache\n\t\t\tglobal.get('cache').setAnalyteProtocol(analyte_protocol_object);\n\n\t\t\t// Return updated receipt\n\t\t\treturn await this.loadInstance();\n\t\t} catch (error) {\n\t\t\tthrow new Error(`Cannot add analyte protocol: ${error}`);\n\t\t}\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id)) {\n\t\t\tconst analyteProtocol = new AnalyteProtocol(id);\n\t\t\treturn await analyteProtocol.loadInstance();\n\t\t} else throw new Error('Cannot get analyte protocol: Invalid param Analyte Protocol ID');\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id; // Prevent changing the instance ID\n\t\t\tlet analyte_protocol_object; // analyte_protocol object\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0)\n\t\t\t\tthrow new Error('Cannot load analyte protocol: Invalid analyte protocol ID');\n\n\t\t\t// Try cache\n\t\t\tanalyte_protocol_object = this.#cache.getAnalyteProtocol(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!analyte_protocol_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_lib_protocol_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) {\n\t\t\t\t\t\tanalyte_protocol_object = xanoRes.data;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (analyte_protocol_object) {\n\t\t\t\t\tthis.#cache.setAnalyteProtocol(analyte_protocol_object);\n\t\t\t\t\tthis.#data = this.#cache.setAnalyteProtocol(analyte_protocol_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance if data is found\n\t\t\tif (analyte_protocol_object) {\n\t\t\t\tthis.#data = analyte_protocol_object;\n\t\t\t\tthis.#initialized = true;\n\t\t\t\tObject.assign(this, analyte_protocol_object);\n\t\t\t\tthis.#setupGetters();\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'loadInstance');\n\t\t}\n\t}\n\n\tasync json() {\n\t\tawait this.#lazyLoader();\n\t\treturn this.#data;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance();\n\t\telse throw new Error('Cannot initialize analyte protocol instance: Analyte Protocol ID is not set');\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - AnalyteProtocol.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass Departments {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(dept_id) {\n\t\tthis.id = dept_id;\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst dept = new Departments(id);\n\t\t\treturn await dept.loadInstance();\n\t\t} else throw new Error('Cannot get department: Invalid param Department ID');\n\t}\n\n\tstatic async create(dept_object) {\n\t\ttry {\n\t\t\t// Validate dept_object\n\t\t\tif (!dept_object || typeof dept_object !== 'object') throw new Error('Invalid department object');\n\t\t\tif (!dept_object.name && !dept_object.dept_name)\n\t\t\t\tthrow new Error('Invalid department object: name and dept_name are required');\n\n\t\t\tlet newDept;\n\n\t\t\t// TODO: Add to layer0\n\n\t\t\t// Add to Xano\n\t\t\tif (global.get('xano').bridge_api) {\n\t\t\t\tconst xanoRes = await global.get('xano').add_department({ department: dept_object });\n\t\t\t\tif (xanoRes && xanoRes.status === 200) newDept = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// set cache and return department instance\n\t\t\tif (newDept) {\n\t\t\t\tglobal.get('cache').setDepartment(newDept);\n\t\t\t\treturn await Departments.get(newDept.id);\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - Departments.create()`);\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id;\n\t\t\tlet dept_object;\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Invalid department ID');\n\n\t\t\t// Try cache\n\t\t\tdept_object = this.#cache.getDepartment(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!dept_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (!dept_object && this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_department_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) dept_object = xanoRes.data;\n\t\t\t\t\telse return null;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (dept_object) {\n\t\t\t\t\tthis.#cache.setDepartment(dept_object);\n\t\t\t\t\tthis.#data = this.#cache.setDepartment(dept_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance if data is found\n\t\t\tif (dept_object) {\n\t\t\t\tthis.#data = dept_object; // Save to instance raw data\n\t\t\t\tthis.#initialized = true; // Set initialized to true\n\t\t\t\tObject.assign(this, dept_object); // Assign data to instance\n\t\t\t\tthis.#setupGetters(); // Setup getters\n\t\t\t\treturn this;\n\t\t\t} else return null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'loadInstance');\n\t\t}\n\t}\n\n\tasync json() {\n\t\tawait this.#lazyLoader();\n\t\tif (this.lab_id) this.#data.lab = await Lab.get(this.lab_id);\n\t\treturn this.#data;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance();\n\t\telse throw new Error('Cannot get department: instance is not initialized');\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - Departments.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass Client {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(client_id) {\n\t\tthis.id = client_id;\n\t}\n\n\tstatic async create(client_object) {\n\t\ttry {\n\t\t\t// Validate client_object\n\t\t\tif (!client_object || typeof client_object !== 'object') throw new Error('Invalid client object');\n\n\t\t\tif (!client_object.name && !client_object.client_name)\n\t\t\t\tthrow new Error('Invalid client object: name and client_name are required');\n\n\t\t\tlet newClient;\n\n\t\t\t// TODO: Add to layer0\n\n\t\t\t// Add to Xano\n\t\t\tif (global.get('xano').bridge_api) {\n\t\t\t\tconst xanoRes = await global.get('xano').add_client({ client: client_object });\n\t\t\t\tif (xanoRes && xanoRes.status === 200) newClient = xanoRes.data;\n\t\t\t\telse return null;\n\t\t\t}\n\n\t\t\t// set cache and return client instance\n\t\t\tif (newClient) {\n\t\t\t\tglobal.get('cache').setClient(newClient);\n\t\t\t\treturn await Client.get(newClient.id);\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - Client.create()`);\n\t\t\tnode.warn(error.stack);\n\t\t\terror.statusCode = 500;\n\t\t\terror.errorMessage = 'Internal Server Error';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst client = new Client(id);\n\t\t\treturn await client.loadInstance();\n\t\t} else throw new Error('Cannot get client: Invalid param Client ID');\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id;\n\t\t\tlet client_object;\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Invalid client ID');\n\n\t\t\t// Try cache\n\t\t\tclient_object = this.#cache.getClient(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!client_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (!client_object && this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_client_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) client_object = xanoRes.data;\n\t\t\t\t\telse return null;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (client_object) {\n\t\t\t\t\tthis.#cache.setClient(client_object);\n\t\t\t\t\tthis.#data = this.#cache.setClient(client_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance if data is found\n\t\t\tif (client_object) {\n\t\t\t\tthis.#data = client_object; // Save to instance raw data\n\t\t\t\tthis.#initialized = true; // Set initialized to true\n\t\t\t\tObject.assign(this, client_object); // Assign data to instance\n\t\t\t\tthis.#setupGetters(); // Setup getters\n\t\t\t\treturn this; // Return this class\n\t\t\t} else return null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'loadInstance');\n\t\t}\n\t}\n\n\tjson() {\n\t\tif (!this.#data) throw new Error('Cannot get client: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.id) throw new Error('Cannot initialize client Instance: Client ID is not set');\n\t\tawait this.loadInstance();\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - Client.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass User {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(user_id) {\n\t\tthis.id = user_id;\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id)) {\n\t\t\tif (id === 0) return {};\n\t\t\tconst user = new User(id);\n\t\t\treturn await user.loadInstance();\n\t\t} else throw new Error('Cannot get user: Invalid param User ID');\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id;\n\t\t\tlet user_object;\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Cannot load user instance: Invalid user ID');\n\n\t\t\t// Try cache\n\t\t\tuser_object = this.#cache.getUser(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!user_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (!user_object && this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_user_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) user_object = xanoRes.data;\n\t\t\t\t\telse return null;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (user_object) {\n\t\t\t\t\tthis.#cache.setUser(user_object);\n\t\t\t\t\tthis.#data = this.#cache.setUser(user_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance if data is found\n\t\t\tif (user_object) {\n\t\t\t\tthis.#data = user_object; // Save to instance raw data\n\t\t\t\tthis.#initialized = true; // Set initialized to true\n\t\t\t\tObject.assign(this, user_object); // Assign data to instance\n\t\t\t\tthis.#setupGetters(); // Setup getters\n\t\t\t\treturn this; // Return this class\n\t\t\t} else return null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'loadInstance');\n\t\t}\n\t}\n\n\tasync json() {\n\t\tawait this.#lazyLoader();\n\t\tif (!this.#data) throw new Error('Cannot get user: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance();\n\t\telse throw new Error('Cannot get user: instance is not initialized');\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - User.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nclass Lab {\n\t#initialized = false;\n\t#layer0 = global.get('layer0'); // Postgres layer\n\t#xano = global.get('xano'); // Xano layer\n\t#cache = global.get('cache'); // Cache layer\n\t#data = null; // Actual data from DB/Xano\n\n\tconstructor(lab_id) {\n\t\tthis.id = lab_id;\n\t}\n\n\tstatic async get(id) {\n\t\tif (Number.isInteger(id) && id > 0) {\n\t\t\tconst lab = new Lab(id);\n\t\t\treturn await lab.loadInstance();\n\t\t} else throw new Error('Cannot get lab: Invalid param Lab ID');\n\t}\n\n\tasync loadInstance(id = this.id) {\n\t\ttry {\n\t\t\t// Variable declaration\n\t\t\tconst id = this.id;\n\t\t\tlet lab_object;\n\n\t\t\t// Validate ID\n\t\t\tif (!Number.isInteger(id) || id <= 0) throw new Error('Invalid lab ID');\n\n\t\t\t// Try cache\n\t\t\tlab_object = this.#cache.getLab(id);\n\n\t\t\t// Try other sources if not in cache\n\t\t\tif (!lab_object) {\n\t\t\t\t// TODO: Try layer0\n\t\t\t\t// Try Xano if possible\n\t\t\t\tif (!lab_object && this.#xano && this.#xano.bridge_api) {\n\t\t\t\t\tconst xanoRes = await this.#xano.get_lab_by_id(id);\n\t\t\t\t\tif (xanoRes && xanoRes.status === 200) lab_object = xanoRes.data;\n\t\t\t\t\telse return null;\n\t\t\t\t}\n\n\t\t\t\t// Set cache if data is found\n\t\t\t\tif (lab_object) {\n\t\t\t\t\tthis.#cache.setLab(lab_object);\n\t\t\t\t\tthis.#data = this.#cache.setLab(lab_object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup instance if data is found\n\t\t\tif (lab_object) {\n\t\t\t\tthis.#data = lab_object; // Save to instance raw data\n\t\t\t\tthis.#initialized = true; // Set initialized to true\n\t\t\t\tObject.assign(this, lab_object); // Assign data to instance\n\t\t\t\tthis.#setupGetters(); // Setup getters\n\t\t\t\treturn this; // Return this class\n\t\t\t} else return null;\n\t\t} catch (error) {\n\t\t\tthis.#errorHandler(error, 'loadInstance');\n\t\t}\n\t}\n\n\tjson() {\n\t\tif (!this.#data) throw new Error('Cannot get lab: instance is not initialized');\n\t\treturn this.#data;\n\t}\n\n\t#setupGetters() {\n\t\tif (this.#initialized) return;\n\t\tif (!this.#data) return;\n\n\t\tfor (const [key, value] of Object.entries(this.#data)) {\n\t\t\t// Skip if property already exists\n\t\t\tif (this.hasOwnProperty(key)) continue;\n\n\t\t\t// Define getter\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#data[key];\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync #lazyLoader() {\n\t\tif (this.#initialized) return;\n\t\tif (this.id) await this.loadInstance();\n\t\telse throw new Error('Cannot get lab: instance is not initialized');\n\t}\n\n\t#errorHandler(error, method_name) {\n\t\tnode.warn(`[ CAUGHT ERROR ] tables.js - Lab.${method_name}()`);\n\t\tnode.warn(error.stack);\n\t\terror.statusCode = 500;\n\t\terror.errorMessage = 'Internal Server Error';\n\t\tthrow error;\n\t}\n}\n\nconst tableHelper = {\n\treceiptValidate: (receipt_object, new_record = false, throw_error = true) => {\n\t\tif (typeof receipt_object !== 'object') {\n\t\t\tif (throw_error) throw new Error('Invalid receipt object');\n\t\t\telse return false;\n\t\t}\n\n\t\t// Receipt must have a client_id\n\t\tif (!receipt_object?.client_id) {\n\t\t\tif (throw_error) throw new Error('Invalid receipt object: client_id is required');\n\t\t\telse return false;\n\t\t}\n\n\t\t// Receipt must have a contact_person_name, contact_person_phone, and contact_person_email\n\t\tif (\n\t\t\t!receipt_object.contact_person_name ||\n\t\t\t!receipt_object.contact_person_phone ||\n\t\t\t!receipt_object.contact_person_email\n\t\t) {\n\t\t\tif (throw_error)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Invalid receipt object: contact_person_name, contact_person_phone, and contact_person_email are required',\n\t\t\t\t);\n\t\t\telse return false;\n\t\t}\n        return true;\n\t},\n\tsampleValidate: (sample_object, new_record = false, throw_error = true) => {\n\t\tif (!sample_object || typeof sample_object !== 'object') {\n\t\t\tif (throw_error) throw new Error('Invalid sample object');\n\t\t\telse return false;\n\t\t}\n\t\tif (!sample_object.receipt_id && !new_record) {\n\t\t\tif (throw_error) throw new Error('Invalid sample object: receipt_id is required');\n\t\t\telse return false;\n\t\t}\n\t},\n\tsampleAnalyteValidate: (sample_analyte_object, new_record = false, throw_error = true) => {\n\t\tif (!sample_analyte_object || typeof sample_analyte_object !== 'object') {\n\t\t\tif (throw_error) throw new Error('Invalid sample analyte object');\n\t\t\telse return false;\n\t\t}\n\t\tif (!sample_analyte_object.sample_id && !new_record) {\n\t\t\tif (throw_error) throw new Error('Invalid sample analyte object: sample_id is required');\n\t\t\telse return false;\n\t\t}\n\t\tif (!sample_analyte_object.analyte_id && !new_record) {\n\t\t\tif (throw_error) throw new Error('Invalid sample analyte object: analyte_id is required');\n\t\t\telse return false;\n\t\t}\n\t},\n\tdeptValidate: (dept_object, throw_error = true) => {\n\t\tif (!dept_object || typeof dept_object !== 'object') {\n\t\t\tif (throw_error) throw new Error('Invalid department object');\n\t\t\telse return false;\n\t\t}\n\t\tif (!dept_object.name && !dept_object.dept_name) {\n\t\t\tif (throw_error) throw new Error('Invalid department object: name and dept_name are required');\n\t\t\telse return false;\n\t\t}\n\t},\n\tclientValidate: (client_object, throw_error = true) => {\n\t\tif (!client_object || typeof client_object !== 'object') {\n\t\t\tif (throw_error) throw new Error('Invalid client object');\n\t\t\telse return false;\n\t\t}\n\t\tif (!client_object.name && !client_object.client_name) {\n\t\t\tif (throw_error) throw new Error('Invalid client object: name and client_name are required');\n\t\t\telse return false;\n\t\t}\n\t},\n\tuserValidate: (user_object, throw_error = true) => {\n\t\tif (!user_object || typeof user_object !== 'object') {\n\t\t\tif (throw_error) throw new Error('Invalid user object');\n\t\t\telse return false;\n\t\t}\n\t\tif (!user_object.name && !user_object.user_name) {\n\t\t\tif (throw_error) throw new Error('Invalid user object: name and user_name are required');\n\t\t\telse return false;\n\t\t}\n\t},\n\n\t// TO TEST: convert analyte to test order\n\tanalyteToTestOrder: (analyte_object) => {\n\t\tif (!analyte_object || typeof analyte_object !== 'object') throw new Error('Invalid analyte object');\n\t\tanalyte_object.sample_receipt_id = analyte_object.receipt_id;\n\t\tanalyte_object.test_name = analyte_object.analyte_name;\n\t\tanalyte_object.test_name_secondary = analyte_object.analyte_name_nd;\n\t\tanalyte_object.lib_test_id = analyte_object.analyte_id;\n\t\tanalyte_object.protocol_id = analyte_object.analyte_protocol_id;\n\t\treturn analyte_object;\n\t},\n\ttestOrderToAnalyte: (test_order_object) => {\n\t\tif (!test_order_object || typeof test_order_object !== 'object') throw new Error('Invalid test order object');\n\t\ttest_order_object.receipt_id = test_order_object.sample_receipt_id;\n\t\ttest_order_object.analyte_name = test_order_object.test_name;\n\t\ttest_order_object.analyte_name_nd = test_order_object.test_name_secondary;\n\t\ttest_order_object.analyte_id = test_order_object.lib_test_id;\n\t\ttest_order_object.analyte_protocol_id = test_order_object.protocol_id;\n\t\treturn test_order_object;\n\t},\n};\n\nglobal.set('tables', {\n\tReceipt,\n\tSample,\n\tSampleAnalyte,\n\tDepartments,\n\tAnalyteProtocol,\n\tClient,\n\tUser,\n\tReceiptPrice,\n\tSamplePrice,\n\tAnalyte,\n\tSampleReport,\n\ttableHelper,\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "class Receipt {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    async get() {\n        try {\n            if (Number.isInteger(this.id) && this.id >= 0) {\n                const receipt = await this.#layer0.getReceipt(this.id);\n                Object.assign(this, receipt);\n                this.#initialized = true;\n                return receipt;\n            }\n            throw new Error('Invalid receipt id');\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    async set(receipt) {\n        await this.#lazyLoader();\n        try {\n            return await this.#layer0.setReceipt(this.id, receipt);\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    static async new(data) {\n        try {\n            const receipt = await global.get('layer0').newReceipt(data);\n            return receipt;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Receipt.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async recentReceipts(data) {\n        /** 1. Query recent receipts */\n\n        const query = `\n            SELECT *\n            FROM receipts r\n            WHERE EXISTS (\n                SELECT 1 \n                FROM samples s \n                WHERE r.id = s.sample_receipt_id AND s.status < 4 ${data.receipt_id ? `AND r.id = ${data.receipt_id}` : ''\n            } ${data.sample_id ? `AND s.id = ${data.sample_id}` : ''}\n            ) \n            ORDER BY r.receipt_uid DESC\n        `;\n\n        let receipts = await global.get('repoClient').query(query);\n\n        receipts = JSON.parse(JSON.stringify(receipts.rows));\n\n        for (const receipt of receipts) {\n            /**2. Query get Receipt by user */\n            receipt.receipt_by_user = await User.fromReceipt(receipt.receipt_by_user_id);\n\n            /**3. Query get Client by receipt */\n            receipt.client = await Client.fromReceipt(receipt.client_id);\n\n            /**4. Query get ReceiptPrice by receipt */\n            receipt.receipt_prices = await ReceiptPrice.fromReceipt(receipt.id);\n\n            /**5. Query get Samples by receipt */\n            receipt.samples = await Sample.fromReceipt(receipt.id);\n\n            for (const sample of receipt.samples) {\n                /**6. Query get User by sample */\n                if (sample.created_by_id && sample.created_by_id >= 0) {\n                    sample.created_by = await User.fromSample(sample.created_by_id);\n                } else {\n                    sample.created_by = null;\n                }\n\n                /**7. Query get Test by sample */\n                sample.test_orders = await TestOrder.fromSample(sample.id);\n\n                for (const test_order of sample.test_orders) {\n                    /**9. Query get LibProtocol by test_order */\n                    test_order.protocol = await LibProtocol.fromTestOrder(test_order.protocol_id);\n\n                    /**10. Query get LibDept by test_order */\n                    test_order.assigned_to_dept = await LibDept.fromTestOrder(test_order.assigned_to_dept_id);\n\n                    /**11. Query get LibLab by lib_dept */\n                    if (test_order.assigned_to_dept !== null) {\n                        test_order.assigned_to_dept.lab = await LibLab.fromLibDept(test_order.assigned_to_dept.lab_id);\n                    }\n                }\n\n                /**12. Query get SamplePrice by sample */\n                sample.sample_prices = await SamplePrice.fromSample(sample.id);\n\n                sample.report = [];\n            }\n        }\n\n        return receipts;\n    }\n\n    static async getDashboardData() {\n        const receipts = await Receipt.recentReceipts();\n        let dashboardData = [];\n\n        receipts.forEach((receipt) => {\n            let data = {\n                receipt_uid: receipt.receipt_uid,\n                client_name: receipt.client_name,\n                receipt_date: receipt.receipt_date,\n                receipt_by: receipt.receipt_by_user_id,\n                samples: [],\n            };\n\n            receipt.samples.forEach((sample) => {\n                let sampleData = {\n                    sample_uid: sample.sample_uid,\n                    sample_name: sample.sample_name,\n                    commencement_time: sample.commencement_time,\n                    status: ['Đang chờ', 'Thường', 'Nhanh', 'Khẩn', 'Hoàn thành'][sample.status],\n                    progress: `${sample.tests.filter((test) => test.test_status === 4).length}/${sample.tests.filter((test) => test.assigned_to_dept_id).length\n                        }/${sample.tests.length}`,\n                };\n                data.samples.push(sampleData);\n            });\n\n            dashboardData.push(data);\n        });\n\n        return dashboardData;\n    }\n\n    async #lazyLoader() {\n        if (this.#initialized) return;\n        await this.get();\n    }\n\n    #handleError(error) {\n        console.error(error);\n        return null;\n    }\n}\n\nclass Sample {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    async get() {\n        try {\n            if (Number.isInteger(this.id) && this.id >= 0) {\n                const sample = await this.#layer0.getSample(this.id);\n                Object.assign(this, sample);\n                this.#initialized = true;\n                return sample;\n            }\n            throw new Error('Invalid sample id');\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    async set(sample) {\n        await this.#lazyLoader();\n        try {\n            return await this.#layer0.setSample(this.id, sample);\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    static async new(data) {\n        try {\n            const sample = await global.get('layer0').newSample(data);\n            return sample;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromReceipt(sample_receipt_id) {\n        try {\n            if (Number.isInteger(sample_receipt_id) && sample_receipt_id >= 0) {\n                const query = `SELECT * FROM samples WHERE sample_receipt_id = $1`;\n                const params = [sample_receipt_id];\n                const results = await global.get('repoClient').query(query, params);\n                let samples = results.rows;\n\n                samples = JSON.parse(JSON.stringify(samples));\n\n                if (samples && Array.isArray(samples) && samples.length === 0) return [];\n\n                return samples;\n            }\n            throw new Error('Invalid sample_receipt_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.fromReceipt() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    async #lazyLoader() {\n        if (this.#initialized) return;\n        await this.get();\n    }\n\n    #handleError(error) {\n        node.warn(`[ CAUGHT ERROR ] @layer1.js - Sample.get() - ${error}`);\n        node.warn(error);\n        // API response\n        error.statusCode = 500; // Internal Server Error\n        error.errorMessage = 'Internal Server Error';\n        throw error;\n    }\n}\n\nclass Test {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    async get() {\n        try {\n            if (Number.isInteger(this.id) && this.id >= 0) {\n                const test = await this.#layer0.getTest(this.id);\n                Object.assign(this, test);\n                this.#initialized = true;\n                return test;\n            }\n            throw new Error('Invalid test id');\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    async set(test) {\n        await this.#lazyLoader();\n        try {\n            return await this.#layer0.setTest(this.id, test);\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    static async new(data) {\n        try {\n            const test = await global.get('layer0').newTest(data);\n            return test;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Test.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromSample(sample_id) {\n        try {\n            if (Number.isInteger(sample_id) && sample_id >= 0) {\n                const query = `SELECT id FROM test_order WHERE sample_id = $1`;\n                const params = [sample_id];\n                const results = await global.get('repoClient').query(query, params);\n                const tests = results.rows;\n\n                if (tests && Array.isArray(tests) && tests.length === 0) return [];\n\n                return Promise.all(\n                    tests.map(async (test) => {\n                        const newInstance = new Test(test.id);\n                        return await newInstance.get();\n                    }),\n                );\n            }\n            throw new Error('Invalid sample id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Test.fromSample() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    async #lazyLoader() {\n        if (this.#initialized) return;\n        await this.get();\n    }\n\n    #handleError(error) {\n        node.warn(`[ CAUGHT ERROR ] @layer1.js - Test.get() - ${error}`);\n        node.warn(error);\n        // API response\n        error.statusCode = 500; // Internal Server Error\n        error.errorMessage = 'Internal Server Error';\n        throw error;\n    }\n}\n\nclass TestOrder {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    async get() {\n        try {\n            if (Number.isInteger(this.id) && this.id >= 0) {\n                const testOrder = await this.#layer0.getTestOrder(this.id);\n                Object.assign(this, testOrder);\n                this.#initialized = true;\n                return testOrder;\n            }\n            throw new Error('Invalid testOrder id');\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    async set(testOrder) {\n        await this.#lazyLoader();\n        try {\n            return await this.#layer0.setTestOrder(this.id, testOrder);\n        } catch (error) {\n            return this.#handleError(error);\n        }\n    }\n\n    static async new(data) {\n        try {\n            const testOrder = await global.get('layer0').newTestOrder(data);\n            return testOrder;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - TestOrder.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromSample(sample_id) {\n        try {\n            if (Number.isInteger(sample_id) && sample_id >= 0) {\n                const query = `SELECT * FROM test_order WHERE sample_id = $1`;\n                const params = [sample_id];\n                const results = await global.get('repoClient').query(query, params);\n                let tests = results.rows;\n\n                tests = JSON.parse(JSON.stringify(tests));\n\n                if (tests && Array.isArray(tests) && tests.length === 0) return [];\n\n                return tests;\n            }\n            throw new Error('Invalid sample id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - TestOrder.fromTest() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    async #lazyLoader() {\n        if (this.#initialized) return;\n        await this.get();\n    }\n\n    #handleError(error) {\n        node.warn(`[ CAUGHT ERROR ] @layer1.js - TestOrder.get() - ${error}`);\n        node.warn(error);\n        // API response\n        error.statusCode = 500; // Internal Server Error\n        error.errorMessage = 'Internal Server Error';\n        throw error;\n    }\n}\n\nclass Client {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const client = await global.get('layer0').newClient(data);\n            return client;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Client.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromReceipt(receipt_client_id) {\n        try {\n            if (Number.isInteger(receipt_client_id) && receipt_client_id >= 0) {\n                const query = `SELECT * FROM clients WHERE id = $1`;\n                const params = [receipt_client_id];\n                const results = await global.get('repoClient').query(query, params);\n                let clients = results.rows;\n\n                clients = JSON.parse(JSON.stringify(clients));\n\n                if (clients && Array.isArray(clients) && clients.length === 0) return [];\n\n                return clients[0];\n            }\n            throw new Error('Invalid receipt_client_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - Client.fromReceipt() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass User {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const user = await global.get('layer0').newUser(data);\n            return user;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - User.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromReceipt(receipt_by_user_id) {\n        try {\n            if (Number.isInteger(receipt_by_user_id) && receipt_by_user_id >= 0) {\n                const query = `SELECT * FROM users WHERE id = $1`;\n                const params = [receipt_by_user_id];\n                const results = await global.get('repoClient').query(query, params);\n                let users = results.rows;\n\n                users = JSON.parse(JSON.stringify(users));\n\n                if (users && Array.isArray(users) && users.length === 0) return [];\n\n                return users[0];\n            }\n            throw new Error('Invalid receipt_by_user_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - User.fromReceipt() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromSample(sample_by_user_id) {\n        try {\n            if (Number.isInteger(sample_by_user_id) && sample_by_user_id >= 0) {\n                const query = `SELECT * FROM users WHERE id = $1`;\n                const params = [sample_by_user_id];\n                const results = await global.get('repoClient').query(query, params);\n                let users = results.rows;\n\n                users = JSON.parse(JSON.stringify(users));\n\n                if (users && Array.isArray(users) && users.length === 0) return [];\n\n                return users[0];\n            }\n            throw new Error(`Invalid sample_by_user_id: ${sample_by_user_id}`);\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - User.fromSample() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass ReceiptPrice {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const receiptPrice = await global.get('layer0').newReceiptPrice(data);\n            return receiptPrice;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - ReceiptPrice.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromReceipt(receipt_price_id) {\n        try {\n            if (Number.isInteger(receipt_price_id) && receipt_price_id >= 0) {\n                const query = `SELECT * FROM receipt_prices WHERE sample_receipt_id = $1`;\n                const params = [receipt_price_id];\n                const results = await global.get('repoClient').query(query, params);\n                let receiptPrices = results.rows;\n\n                receiptPrices = JSON.parse(JSON.stringify(receiptPrices));\n\n                if (receiptPrices && Array.isArray(receiptPrices) && receiptPrices.length === 0) return [];\n\n                return receiptPrices[0];\n            }\n            throw new Error('Invalid receipt_price_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - ReceiptPrice.fromReceipt() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass LibProtocol {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const libProtocol = await global.get('layer0').newLibProtocol(data);\n            return libProtocol;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibProtocol.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromTestOrder(test_order_protocol_id) {\n        try {\n            if (Number.isInteger(test_order_protocol_id) && test_order_protocol_id >= 0) {\n                const query = `SELECT * FROM lib_protocols WHERE id = $1`;\n                const params = [test_order_protocol_id];\n                const results = await global.get('repoClient').query(query, params);\n                let libProtocols = results.rows;\n\n                libProtocols = JSON.parse(JSON.stringify(libProtocols));\n\n                if (libProtocols && Array.isArray(libProtocols) && libProtocols.length === 0) return null;\n\n                return libProtocols[0];\n            }\n            throw new Error(`Invalid test_order_protocol_id: ${test_order_protocol_id}`);\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibProtocol.fromTestOrder() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass LibDept {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const libDept = await global.get('layer0').newLibDept(data);\n            return libDept;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibDept.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromTestOrder(test_order_assigned_to_dept_id) {\n        try {\n            if (Number.isInteger(test_order_assigned_to_dept_id) && test_order_assigned_to_dept_id >= 0) {\n                const query = `SELECT * FROM lib_dept WHERE id = $1`;\n                const params = [test_order_assigned_to_dept_id];\n                const results = await global.get('repoClient').query(query, params);\n                let libDepts = results.rows;\n\n                libDepts = JSON.parse(JSON.stringify(libDepts));\n\n                if (libDepts && Array.isArray(libDepts) && libDepts.length === 0) return null;\n\n                return libDepts[0];\n            }\n            throw new Error(`Invalid test_order_assigned_to_dept_id: ${test_order_assigned_to_dept_id}`);\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibDept.fromTestOrder() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass SamplePrice {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const samplePrice = await global.get('layer0').newSamplePrice(data);\n            return samplePrice;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - SamplePrice.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromSample(sample_price_id) {\n        try {\n            if (Number.isInteger(sample_price_id) && sample_price_id >= 0) {\n                const query = `SELECT * FROM sample_prices WHERE sample_id = $1`;\n                const params = [sample_price_id];\n                const results = await global.get('repoClient').query(query, params);\n                let samplePrices = results.rows;\n\n                samplePrices = JSON.parse(JSON.stringify(samplePrices));\n\n                if (samplePrices && Array.isArray(samplePrices) && samplePrices.length === 0) return [];\n\n                return samplePrices[0];\n            }\n            throw new Error('Invalid sample_price_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - SamplePrice.fromSample() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\nclass LibLab {\n    #initialized = false;\n    #layer0 = global.get('layer0');\n    #repoClient = global.get('repoClient');\n\n    constructor(id) {\n        this.id = id;\n    }\n\n    static async new(data) {\n        try {\n            const libLab = await global.get('layer0').newLibLab(data);\n            return libLab;\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibLab.new() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n\n    static async fromLibDept(lib_dept_lab_id) {\n        try {\n            if (Number.isInteger(lib_dept_lab_id) && lib_dept_lab_id >= 0) {\n                const query = `SELECT * FROM lib_lab WHERE id = $1`;\n                const params = [lib_dept_lab_id];\n                const results = await global.get('repoClient').query(query, params);\n                let libLabs = results.rows;\n\n                libLabs = JSON.parse(JSON.stringify(libLabs));\n\n                if (libLabs && Array.isArray(libLabs) && libLabs.length === 0) return null;\n\n                return libLabs[0];\n            } else if (lib_dept_lab_id === null) {\n                return null;\n            }\n            throw new Error('Invalid lib_dept_lab_id');\n        } catch (error) {\n            node.warn(`[ CAUGHT ERROR ] @layer1.js - LibLab.fromLibDept() - ${error}`);\n            node.warn(error);\n            // API response\n            error.statusCode = 500; // Internal Server Error\n            error.errorMessage = 'Internal Server Error';\n            throw error;\n        }\n    }\n}\n\n// export classes\nconst tables = {\n    Receipt,\n    Sample,\n    Test,\n    Client,\n    TestOrder,\n    User,\n    ReceiptPrice,\n    LibProtocol,\n    LibDept,\n    SamplePrice,\n    LibLab,\n};\n\nglobal.set('tables', tables);\n",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 610,
        "y": 140,
        "wires": [
            [
                "1398d930cd2dd1d9"
            ]
        ]
    },
    {
        "id": "9b8fef1d3325f9e0",
        "type": "comment",
        "z": "5fb64aedc3e2bcf3",
        "name": "postgres.sql origin",
        "info": "CREATE TABLE IF NOT EXISTS clients (\n    id              SERIAL PRIMARY KEY,\n    client_name     TEXT,\n    client_uid      TEXT,\n    code            TEXT,\n    address         TEXT,\n    email           TEXT,\n    phone           TEXT,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    notes           TEXT    \n);\n\nCREATE TABLE IF NOT EXISTS users (\n    id              SERIAL PRIMARY KEY,\n    user_uid        TEXT,\n    name            TEXT NOT NULL UNIQUE,\n    password        TEXT,\n    email           TEXT NOT NULL UNIQUE,\n    phone           TEXT,\n    disabled        BOOLEAN NOT NULL DEFAULT FALSE,\n    employee        BOOLEAN NOT NULL DEFAULT FALSE,\n    org_admin       BOOLEAN NOT NULL DEFAULT FALSE,\n    force_reset_pw  BOOLEAN NOT NULL DEFAULT FALSE,\n    force_sign_out  BOOLEAN NOT NULL DEFAULT FALSE,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS lib_lab (\n    id              SERIAL PRIMARY KEY,\n    lab_name        TEXT,\n    code            TEXT,\n    address         TEXT,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS lib_sale (\n    id                      SERIAL PRIMARY KEY,\n    sale_name               TEXT,\n    sale_payment_infor      TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS lib_dept (\n    id              SERIAL PRIMARY KEY,\n    dept_name       TEXT,\n    lab_id          INTEGER NOT NULL,\n    is_lab          BOOL NOT NULL DEFAULT FALSE,\n    priority        INTEGER NOT NULL DEFAULT 0,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (lab_id) REFERENCES lib_lab(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS lib_protocols (\n    id                      SERIAL PRIMARY KEY,\n    code                    TEXT,\n    name                    TEXT,\n    name_secondary          TEXT,\n    vlas                    BOOLEAN NOT NULL DEFAULT FALSE,\n    modified_by             INTEGER,\n    accreditation_source    TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (modified_by) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS receipts (\n    id                              SERIAL PRIMARY KEY,\n    receipt_uid                     TEXT,\n    client_id                       INTEGER ,\n    receipt_by_lab_id               INTEGER NOT NULL,\n    receipt_by_user_id              INTEGER NOT NULL,\n    receipt_date                    DATE,\n    commencement_date               DATE,\n    eta_days                        INTEGER,\n    archived                        BOOLEAN NOT NULL DEFAULT FALSE,\n    note                            TEXT,\n    ppt_copies                      INTEGER,\n    submission_person_name          TEXT,\n    submission_courier_name         TEXT,\n    report_method_in_person         BOOLEAN NOT NULL DEFAULT FALSE,\n    report_method_courier_address   TEXT,\n    report_method_email             TEXT,\n    report_method_zalo              TEXT,\n    contact_person_name             TEXT,\n    contact_person_phone            TEXT,\n    contact_person_email            TEXT,\n    created_at                      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS samples (\n    id                      SERIAL PRIMARY KEY,\n    sample_uid              TEXT,\n    sample_name             TEXT,\n    sample_receipt_id       INTEGER NOT NULL,\n    sample_name_secondary   TEXT,\n    sample_lot              TEXT,\n    sample_mfg              DATE,\n    sample_exp              DATE,\n    sample_mfr              TEXT,\n    sample_qty              TEXT,\n    sample_seal             TEXT,\n    sample_desc             TEXT,\n    note                    TEXT,\n    sample_category         TEXT,\n    secondary_language      BOOLEAN NOT NULL DEFAULT FALSE,\n    test_purpose            TEXT,\n    created_by_id           INTEGER,\n    commencement_time       TIMESTAMP,\n    modified_at             TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_id          INTEGER ,\n    ppt_copies              INTEGER,\n    deleted                 BOOLEAN NOT NULL DEFAULT FALSE,\n    sample_deadline         DATE,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    status                  INTEGER,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (created_by_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (modified_by_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS tests (\n    id                      SERIAL PRIMARY KEY,\n    test_name               TEXT,\n    protocol_id             INTEGER ,\n    modified_by_id          INTEGER,\n    test_name_secondary     TEXT,\n    result_unit             TEXT,\n    protocol_source         TEXT,\n    fee                     DOUBLE PRECISION,\n    modified_at             TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    vlas                    BOOLEAN NOT NULL DEFAULT FALSE,\n    created_at              TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    dept_id                 INTEGER,\n    FOREIGN KEY (protocol_id) REFERENCES lib_protocols(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (modified_by_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (dept_id) REFERENCES lib_dept(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_prices (\n    id                      SERIAL PRIMARY KEY,\n    sample_id               INTEGER NOT NULL,\n    sample_receipt_id       INTEGER NOT NULL,\n    gross                   INTEGER,\n    premium                 INTEGER,\n    premium_rate            DOUBLE PRECISION,\n    discount                INTEGER,\n    discount_rate           DOUBLE PRECISION,\n    net                     INTEGER,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_report (\n    id                              SERIAL PRIMARY KEY,\n    modified_at                     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_by_id                  INTEGER ,\n    report_uid                      TEXT,\n    published_date                  DATE,\n    sample_id                       INTEGER NOT NULL,\n    sample_receipt_id               INTEGER ,\n    title                           TEXT,\n    title_eng                       TEXT,\n    sample_uid                      TEXT,\n    sample_prices_id                INTEGER,\n    format_is_vlas_logo             BOOLEAN NOT NULL DEFAULT FALSE,\n    client_uid                      TEXT,\n    client_section_title_left       TEXT,\n    client_section_title_right      TEXT,\n    sample_name                     TEXT,\n    sample_name_secondary           TEXT,\n    sample_lot                      TEXT,\n    sample_mfg                      TEXT,\n    sample_exp                      TEXT,\n    sample_mfr                      TEXT,\n    receipt_date                    DATE,\n    sample_desc                     TEXT,\n    format_is_std_ref               BOOLEAN NOT NULL DEFAULT FALSE,\n    test_comments                   TEXT,\n    test_notes                      TEXT,\n    signer_fist_title              TEXT,\n    signer_first_name               TEXT,\n    signer_second_title             TEXT,\n    signer_second_name              TEXT,\n    test_table_row_num              TEXT,\n    test_table_row_num_eng          TEXT,\n    test_table_protocol             TEXT,\n    test_table_protocol_eng         TEXT,\n    test_table_std_ref              TEXT,\n    test_table_std_ref_eng          TEXT,\n    test_table_unit                 TEXT,\n    test_table_unit_eng             TEXT,\n    test_table_result               TEXT,\n    test_table_result_eng           TEXT,\n    comment_title                   TEXT,\n    format_is_comment               BOOLEAN NOT NULL DEFAULT FALSE,\n    comment_detail                  TEXT,\n    test_note_title                 TEXT,\n    test_note_detail                TEXT,\n    created_at                      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_prices_id) REFERENCES sample_prices(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (modified_by_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS test_order (\n    id                      SERIAL PRIMARY KEY,\n    sample_id               INTEGER ,\n    sample_receipt_id       INTEGER ,\n    test_name               TEXT,\n    test_name_secondary     TEXT,\n    lib_test_id             INTEGER,\n    std_ref                 TEXT,\n    fee                     DOUBLE PRECISION,\n    protocol_id             INTEGER,\n    protocol_source         TEXT,\n    vlas                    BOOLEAN NOT NULL DEFAULT FALSE,\n    result_unit             TEXT,\n    result_value            TEXT,\n    outsourced              BOOLEAN NOT NULL DEFAULT FALSE,\n    protocol_value          TEXT,\n    assigned_to_user_id     INTEGER ,\n    assigned_to_dept_id     INTEGER ,\n    result_note             TEXT,\n    result_deadline         DATE,  \n    result_submitted_by_id  INTEGER,\n    result_submitted_at     TIMESTAMP,\n    deleted                 BOOLEAN NOT NULL DEFAULT FALSE,\n    tested_by_user_id       INTEGER ,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (lib_test_id) REFERENCES tests(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (protocol_id) REFERENCES lib_protocols(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (assigned_to_user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (assigned_to_dept_id) REFERENCES lib_dept(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (tested_by_user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_report_tests (\n    id                      SERIAL PRIMARY KEY,\n    sample_report_id        INTEGER ,\n    sample_id               INTEGER ,\n    sample_receipt_id       INTEGER,\n    test_order_id           INTEGER ,\n    test_name               TEXT,\n    protocol_id             INTEGER ,\n    protocol_value          TEXT,\n    vlas                    BOOLEAN NOT NULL DEFAULT FALSE,\n    external                BOOLEAN NOT NULL DEFAULT FALSE,\n    lab_id                  INTEGER ,\n    std_ref                 TEXT,\n    result_unit             TEXT,\n    result_value            TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_report_id) REFERENCES sample_report(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (test_order_id) REFERENCES test_order(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (protocol_id) REFERENCES lib_protocols(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (lab_id) REFERENCES lib_lab(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_transfer_report (\n    id                      SERIAL PRIMARY KEY,\n    created_by_user_id      INTEGER NOT NULL,\n    report_uid              TEXT,\n    report_date             DATE,\n    location                TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS sample_transfer_tests (\n    id                      SERIAL PRIMARY KEY,\n    transfer_report_id      INTEGER NOT NULL,\n    sample_id               INTEGER NOT NULL,\n    test_order_id           INTEGER NOT NULL,\n    recipient_user_id       INTEGER NOT NULL,\n    deadline                DATE,\n    note                    TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (transfer_report_id) REFERENCES sample_transfer_report(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (test_order_id) REFERENCES test_order(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (recipient_user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS receipt_prices (\n    id                      SERIAL PRIMARY KEY,\n    sample_receipt_id       INTEGER NOT NULL,\n    gross                   INTEGER,\n    premium                 INTEGER,\n    premium_rate            DOUBLE PRECISION,\n    discount                INTEGER,\n    discount_rate           DOUBLE PRECISION,\n    tax                     INTEGER,\n    tax_rate                DOUBLE PRECISION,\n    payable                 INTEGER,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS test_results (\n    id                      SERIAL PRIMARY KEY,\n    sample_id               INTEGER NOT NULL,\n    sample_receipt_id       INTEGER NOT NULL,\n    test_order_id           INTEGER NOT NULL,\n    std_ref                 TEXT,\n    result_value            TEXT,\n    unit                    TEXT,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (test_order_id) REFERENCES test_order(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_id) REFERENCES samples(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS user_depts (\n    id              SERIAL PRIMARY KEY,\n    user_id         INTEGER NOT NULL,\n    dept_id         INTEGER NOT NULL,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (dept_id) REFERENCES lib_dept(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS user_lab_roles (\n    id              SERIAL PRIMARY KEY,\n    user_id         INTEGER NOT NULL,\n    lab_id          INTEGER ,\n    sample_manager  BOOLEAN NOT NULL DEFAULT FALSE,\n    test_manager    BOOLEAN NOT NULL DEFAULT FALSE,\n    finance_manager BOOLEAN NOT NULL DEFAULT FALSE,\n    org_admin       BOOLEAN NOT NULL DEFAULT FALSE,\n    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    FOREIGN KEY (lab_id) REFERENCES lib_lab(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS user_event_logs (\n    id              SERIAL PRIMARY KEY,\n    user_id         INTEGER NOT NULL,\n    context         TEXT,\n    function        TEXT,\n    message         TEXT,\n    data            JSON,\n    time            TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\nCREATE TABLE IF NOT EXISTS receipt_sales (\n    id                      SERIAL PRIMARY KEY,\n    sample_receipt_id       INTEGER NOT NULL,\n    sample_id               INTEGER NOT NULL,\n    sale_id                 INTEGER NOT NULL,\n    commission_percent      DOUBLE PRECISION,\n    commission_value        DOUBLE PRECISION,\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (sample_receipt_id) REFERENCES receipts(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- Chỉ mục cho bảng lib_dept\nCREATE INDEX idx_lib_dept_lab_id ON lib_dept(lab_id);\nCREATE INDEX idx_lib_dept_is_lab ON lib_dept(is_lab);\nCREATE INDEX idx_lib_dept_priority ON lib_dept(priority);\n\n-- Chỉ mục cho bảng lib_protocols\nCREATE INDEX idx_lib_protocols_modified_by ON lib_protocols(modified_by);\n\n-- Chỉ mục cho bảng lib_lab\nCREATE INDEX idx_lib_lab_code ON lib_lab(code);\n\n-- Chỉ mục cho bảng tests\nCREATE INDEX idx_tests_protocol_id ON tests(protocol_id);\nCREATE INDEX idx_tests_modified_by_id ON tests(modified_by_id);\nCREATE INDEX idx_tests_dept_id ON tests(dept_id);\n\n-- Chỉ mục cho bảng receipt_sales\nCREATE INDEX idx_receipt_sales_sample_receipt_id ON receipt_sales(sample_receipt_id);\nCREATE INDEX idx_receipt_sales_sample_id ON receipt_sales(sample_id);\nCREATE INDEX idx_receipt_sales_sale_id ON receipt_sales(sale_id);\n\n-- Chỉ mục cho bảng sample\nCREATE INDEX idx_sample_sample_receipt_id ON samples(sample_receipt_id);\nCREATE INDEX idx_sample_created_by_id ON samples(created_by_id);\nCREATE INDEX idx_sample_modified_by_id ON samples(modified_by_id);\nCREATE INDEX idx_sample_status ON samples(status);\n\n-- Chỉ mục cho bảng sample_prices\nCREATE INDEX idx_sample_prices_sample_id ON sample_prices(sample_id);\nCREATE INDEX idx_sample_prices_sample_receipt_id ON sample_prices(sample_receipt_id);\n\n-- Chỉ mục cho bảng sample_receipt\nCREATE INDEX idx_sample_receipt_client_id ON receipts(client_id);\nCREATE INDEX idx_sample_receipt_receipt_by_lab_id ON receipts(receipt_by_lab_id);\nCREATE INDEX idx_sample_receipt_receipt_by_user_id ON receipts(receipt_by_user_id);\n\n-- Chỉ mục cho bảng receipt_prices\nCREATE INDEX idx_receipt_prices_sample_receipt_id ON receipt_prices(sample_receipt_id);\n\n-- Chỉ mục cho bảng sample_report\nCREATE INDEX idx_sample_report_sample_id ON sample_report(sample_id);\nCREATE INDEX idx_sample_report_sample_receipt_id ON sample_report(sample_receipt_id);\nCREATE INDEX idx_sample_report_sample_prices_id ON sample_report(sample_prices_id);\n\n-- Chỉ mục cho bảng sample_report_tests\nCREATE INDEX idx_sample_report_tests_sample_report_id ON sample_report_tests(sample_report_id);\nCREATE INDEX idx_sample_report_tests_sample_id ON sample_report_tests(sample_id);\nCREATE INDEX idx_sample_report_tests_test_order_id ON sample_report_tests(test_order_id);\nCREATE INDEX idx_sample_report_tests_protocol_id ON sample_report_tests(protocol_id);\nCREATE INDEX idx_sample_report_tests_lab_id ON sample_report_tests(lab_id);\n\n-- Chỉ mục cho bảng sample_transfer_report\nCREATE INDEX idx_sample_transfer_report_created_by_user_id ON sample_transfer_report(created_by_user_id);\n\n-- Chỉ mục cho bảng sample_transfer_tests\nCREATE INDEX idx_sample_transfer_tests_transfer_report_id ON sample_transfer_tests(transfer_report_id);\nCREATE INDEX idx_sample_transfer_tests_sample_id ON sample_transfer_tests(sample_id);\nCREATE INDEX idx_sample_transfer_tests_recipient_user_id ON sample_transfer_tests(recipient_user_id);\n\n-- Chỉ mục cho bảng test_order\nCREATE INDEX idx_test_order_sample_id ON test_order(sample_id);\nCREATE INDEX idx_test_order_sample_receipt_id ON test_order(sample_receipt_id);\nCREATE INDEX idx_test_order_lib_test_id ON test_order(lib_test_id);\nCREATE INDEX idx_test_order_protocol_id ON test_order(protocol_id);\nCREATE INDEX idx_test_order_assigned_to_user_id ON test_order(assigned_to_user_id);\nCREATE INDEX idx_test_order_assigned_to_dept_id ON test_order(assigned_to_dept_id);\nCREATE INDEX idx_test_order_tested_by_user_id ON test_order(tested_by_user_id);\n\n-- Chỉ mục cho bảng test_results\nCREATE INDEX idx_test_results_test_order_id ON test_results(test_order_id);\nCREATE INDEX idx_test_results_sample_id ON test_results(sample_id);\nCREATE INDEX idx_test_results_sample_receipt_id ON test_results(sample_receipt_id);\n\n-- Chỉ mục cho bảng user_depts\nCREATE INDEX idx_user_depts_user_id ON user_depts(user_id);\nCREATE INDEX idx_user_depts_dept_id ON user_depts(dept_id);\n\n-- Chỉ mục cho bảng user_lab_roles\nCREATE INDEX idx_user_lab_roles_user_id ON user_lab_roles(user_id);\nCREATE INDEX idx_user_lab_roles_lab_id ON user_lab_roles(lab_id);\n\n-- Chỉ mục cho bảng user_event_logs\nCREATE INDEX idx_user_event_logs_user_id ON user_event_logs(user_id);\nCREATE INDEX idx_user_event_logs_time ON user_event_logs(time);\n\n-- Chỉ mục cho bảng users\n-- Đã tạo chỉ mục UNIQUE trong định nghĩa bảng, không cần tạo thêm\n\n\n-- Clients table\nCREATE SEQUENCE IF NOT EXISTS clients_id_seq;\nALTER TABLE clients ALTER COLUMN id SET DEFAULT nextval('clients_id_seq'::regclass);\n\n-- Lib_dept table\nCREATE SEQUENCE IF NOT EXISTS lib_dept_id_seq;\nALTER TABLE lib_dept ALTER COLUMN id SET DEFAULT nextval('lib_dept_id_seq'::regclass);\n\n-- Lib_lab table\nCREATE SEQUENCE IF NOT EXISTS lib_lab_id_seq;\nALTER TABLE lib_lab ALTER COLUMN id SET DEFAULT nextval('lib_lab_id_seq'::regclass);\n\n-- Lib_protocols table\nCREATE SEQUENCE IF NOT EXISTS lib_protocols_id_seq;\nALTER TABLE lib_protocols ALTER COLUMN id SET DEFAULT nextval('lib_protocols_id_seq'::regclass);\n\n-- Lib_sale table\nCREATE SEQUENCE IF NOT EXISTS lib_sale_id_seq;\nALTER TABLE lib_sale ALTER COLUMN id SET DEFAULT nextval('lib_sale_id_seq'::regclass);\n\n-- Receipt_prices table\nCREATE SEQUENCE IF NOT EXISTS receipt_prices_id_seq;\nALTER TABLE receipt_prices ALTER COLUMN id SET DEFAULT nextval('receipt_prices_id_seq'::regclass);\n\n-- Receipt_sales table\nCREATE SEQUENCE IF NOT EXISTS receipt_sales_id_seq;\nALTER TABLE receipt_sales ALTER COLUMN id SET DEFAULT nextval('receipt_sales_id_seq'::regclass);\n\n-- Receipts table\nCREATE SEQUENCE IF NOT EXISTS receipts_id_seq;\nALTER TABLE receipts ALTER COLUMN id SET DEFAULT nextval('receipts_id_seq'::regclass);\n\n-- Sample_prices table\nCREATE SEQUENCE IF NOT EXISTS sample_prices_id_seq;\nALTER TABLE sample_prices ALTER COLUMN id SET DEFAULT nextval('sample_prices_id_seq'::regclass);\n\n-- Sample_report table\nCREATE SEQUENCE IF NOT EXISTS sample_report_id_seq;\nALTER TABLE sample_report ALTER COLUMN id SET DEFAULT nextval('sample_report_id_seq'::regclass);\n\n-- Sample_report_tests table\nCREATE SEQUENCE IF NOT EXISTS sample_report_tests_id_seq;\nALTER TABLE sample_report_tests ALTER COLUMN id SET DEFAULT nextval('sample_report_tests_id_seq'::regclass);\n\n-- Sample_transfer_report table\nCREATE SEQUENCE IF NOT EXISTS sample_transfer_report_id_seq;\nALTER TABLE sample_transfer_report ALTER COLUMN id SET DEFAULT nextval('sample_transfer_report_id_seq'::regclass);\n\n-- Sample_transfer_tests table\nCREATE SEQUENCE IF NOT EXISTS sample_transfer_tests_id_seq;\nALTER TABLE sample_transfer_tests ALTER COLUMN id SET DEFAULT nextval('sample_transfer_tests_id_seq'::regclass);\n\n-- Samples table\nCREATE SEQUENCE IF NOT EXISTS samples_id_seq;\nALTER TABLE samples ALTER COLUMN id SET DEFAULT nextval('samples_id_seq'::regclass);\n\n-- Test_order table\nCREATE SEQUENCE IF NOT EXISTS test_order_id_seq;\nALTER TABLE test_order ALTER COLUMN id SET DEFAULT nextval('test_order_id_seq'::regclass);\n\n-- Test_results table\nCREATE SEQUENCE IF NOT EXISTS test_results_id_seq;\nALTER TABLE test_results ALTER COLUMN id SET DEFAULT nextval('test_results_id_seq'::regclass);\n\n-- Tests table\nCREATE SEQUENCE IF NOT EXISTS tests_id_seq;\nALTER TABLE tests ALTER COLUMN id SET DEFAULT nextval('tests_id_seq'::regclass);\n\n-- User_depts table\nCREATE SEQUENCE IF NOT EXISTS user_depts_id_seq;\nALTER TABLE user_depts ALTER COLUMN id SET DEFAULT nextval('user_depts_id_seq'::regclass);\n\n-- User_event_logs table\nCREATE SEQUENCE IF NOT EXISTS user_event_logs_id_seq;\nALTER TABLE user_event_logs ALTER COLUMN id SET DEFAULT nextval('user_event_logs_id_seq'::regclass);\n\n-- User_lab_roles table\nCREATE SEQUENCE IF NOT EXISTS user_lab_roles_id_seq;\nALTER TABLE user_lab_roles ALTER COLUMN id SET DEFAULT nextval('user_lab_roles_id_seq'::regclass);\n\n-- Users table\nCREATE SEQUENCE IF NOT EXISTS users_id_seq;\nALTER TABLE users ALTER COLUMN id SET DEFAULT nextval('users_id_seq'::regclass);\n\n\n-- Clients table\nSELECT setval('clients_id_seq', (SELECT COALESCE(MAX(id), 1) FROM clients));\n\n-- Lib_dept table\nSELECT setval('lib_dept_id_seq', (SELECT COALESCE(MAX(id), 1) FROM lib_dept));\n\n-- Lib_lab table\nSELECT setval('lib_lab_id_seq', (SELECT COALESCE(MAX(id), 1) FROM lib_lab));\n\n-- Lib_protocols table\nSELECT setval('lib_protocols_id_seq', (SELECT COALESCE(MAX(id), 1) FROM lib_protocols));\n\n-- Lib_sale table\nSELECT setval('lib_sale_id_seq', (SELECT COALESCE(MAX(id), 1) FROM lib_sale));\n\n-- Receipt_prices table\nSELECT setval('receipt_prices_id_seq', (SELECT COALESCE(MAX(id), 1) FROM receipt_prices));\n\n-- Receipt_sales table\nSELECT setval('receipt_sales_id_seq', (SELECT COALESCE(MAX(id), 1) FROM receipt_sales));\n\n-- Receipts table\nSELECT setval('receipts_id_seq', (SELECT COALESCE(MAX(id), 1) FROM receipts));\n\n-- Sample_prices table\nSELECT setval('sample_prices_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_prices));\n\n-- Sample_report table\nSELECT setval('sample_report_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_report));\n\n-- Sample_report_tests table\nSELECT setval('sample_report_tests_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_report_tests));\n\n-- Sample_transfer_report table\nSELECT setval('sample_transfer_report_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_transfer_report));\n\n-- Sample_transfer_tests table\nSELECT setval('sample_transfer_tests_id_seq', (SELECT COALESCE(MAX(id), 1) FROM sample_transfer_tests));\n\n-- Samples table\nSELECT setval('samples_id_seq', (SELECT COALESCE(MAX(id), 1) FROM samples));\n\n-- Test_order table\nSELECT setval('test_order_id_seq', (SELECT COALESCE(MAX(id), 1) FROM test_order));\n\n-- Test_results table\nSELECT setval('test_results_id_seq', (SELECT COALESCE(MAX(id), 1) FROM test_results));\n\n-- Tests table\nSELECT setval('tests_id_seq', (SELECT COALESCE(MAX(id), 1) FROM tests));\n\n-- User_depts table\nSELECT setval('user_depts_id_seq', (SELECT COALESCE(MAX(id), 1) FROM user_depts));\n\n-- User_event_logs table\nSELECT setval('user_event_logs_id_seq', (SELECT COALESCE(MAX(id), 1) FROM user_event_logs));\n\n-- User_lab_roles table\nSELECT setval('user_lab_roles_id_seq', (SELECT COALESCE(MAX(id), 1) FROM user_lab_roles));\n\n-- Users table\nSELECT setval('users_id_seq', (SELECT COALESCE(MAX(id), 1) FROM users));\n\nCREATE EXTENSION IF NOT EXISTS pg_trgm;\n\nSET pg_trgm.similarity_threshold = 0.2;\n\nCREATE OR REPLACE FUNCTION unaccent_text(text)\nRETURNS text AS $$\nBEGIN\n    RETURN translate(\n        LOWER($1),\n        'áàảãạăắằẳẵặâấầẩẫậđéèẻẽẹêếềểễệíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵ',\n        'aaaaaaaaaaaaaaaaadeeeeeeeeeeeiiiiiooooooooooooooouuuuuuuuuuuuuyyyyy'\n    );\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE;\n\n",
        "x": 150,
        "y": 540,
        "wires": []
    },
    {
        "id": "43c6cc038cc862be",
        "type": "comment",
        "z": "5fb64aedc3e2bcf3",
        "name": "env",
        "info": "process.env.PG_IRDOP_USER\nprocess.env.PG_IRDOP_HOST\nprocess.env.PG_IRDOP_DB \nprocess.env.PG_IRDOP_PW \nprocess.env.PG_IRDOP_PORT",
        "x": 110,
        "y": 620,
        "wires": []
    },
    {
        "id": "aba66d4af74971cc",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1240,
        "wires": [
            [
                "f1e0bf9ceedc729d"
            ]
        ]
    },
    {
        "id": "f1e0bf9ceedc729d",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SAMPLE_TEST",
        "func": "const tables = global.get('tables');\n\ntry {\n    const testOrders = await tables.TestOrder.fromSample(3573);\n    node.warn(testOrders); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 1240,
        "wires": [
            []
        ]
    },
    {
        "id": "aa693c4897c0f506",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST RECENT RECEIPTS",
        "func": "const tables = global.get('tables');\n\ntry {\n    const recent_receipts = await tables.Receipt.recentReceipts(); //{receipt_id: 1222}\n    node.warn(recent_receipts); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 1160,
        "wires": [
            []
        ]
    },
    {
        "id": "1145c77e25c64195",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1160,
        "wires": [
            [
                "aa693c4897c0f506"
            ]
        ]
    },
    {
        "id": "b2433469b1ff917b",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SAMPLE",
        "func": "const tables = global.get('tables');\n\ntry {\n    const testOrders = await tables.Sample.fromReceipt(1207);\n    node.warn(testOrders); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 1200,
        "wires": [
            []
        ]
    },
    {
        "id": "73c61d0ca82caf7c",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1200,
        "wires": [
            [
                "b2433469b1ff917b"
            ]
        ]
    },
    {
        "id": "8765e4ab39e76fed",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1120,
        "wires": [
            [
                "47b067fc658f5615"
            ]
        ]
    },
    {
        "id": "47b067fc658f5615",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SEARCH TESTS",
        "func": "const tables = global.get('tables');\n\ntry {\n    const search = await tables.Test.searchTests('Zn');\n    node.warn(search); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 1120,
        "wires": [
            []
        ]
    },
    {
        "id": "17a5a0074caeeb8c",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1040,
        "wires": [
            [
                "31c5d341f4399f5c"
            ]
        ]
    },
    {
        "id": "31c5d341f4399f5c",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST NEW SAMPLE REPORT",
        "func": "const tables = global.get('tables');\n//body: test_data: [{}], report_data: {} \nconst sampleReport = {\n    modified_by_id: 35,                     // Example integer ID for the user who modified it\n    published_date: \"2024-11-12\",          // Date in 'YYYY-MM-DD' format\n    sample_id: 3566,                        // Example integer ID for sample\n    sample_receipt_id: 1220,               // Example integer ID for sample receipt\n    title: \"Sample Report Title\",          // Report title\n    title_eng: \"Sample Report Title (ENG)\",// Report title in English\n    sample_uid: \"SMP-56789\",               // Unique identifier for the sample\n    sample_prices_id: 1220,                // ID for associated sample price\n    format_is_vlas_logo: true,             // Boolean for VLAS logo format\n    client_uid: \"CLNT-0001\",               // Unique client identifier\n    client_section_title_left: \"Client Left\",  // Left section title\n    client_section_title_right: \"Client Right\", // Right section title\n    sample_name: \"Sample Name\",            // Primary sample name\n    sample_name_secondary: \"Sample Name 2\",// Secondary sample name\n    sample_lot: \"LOT12345\",                // Lot number\n    sample_mfg: \"Manufacturing Details\",   // Manufacturing details text\n    sample_exp: \"Expiration Details\",      // Expiration details text\n    sample_mfr: \"Sample Manufacturer\",     // Manufacturer name\n    receipt_date: \"2024-11-10\",            // Date of receipt in 'YYYY-MM-DD' format\n    sample_desc: \"Sample description text\",// Description text\n    format_is_std_ref: false,              // Boolean for standard reference format\n    test_comments: \"Test comments here\",   // Comments about the test\n    test_notes: \"Additional test notes\",   // Additional notes\n    signer_first_title: \"Dr.\",             // Title for the first signer\n    signer_first_name: \"Alice\",            // First name of the first signer\n    signer_second_title: \"Mr.\",            // Title for the second signer\n    signer_second_name: \"Bob\",             // Second name of the second signer\n    test_table_row_num: \"5\",               // Row number for test table\n    test_table_row_num_eng: \"5\",           // Row number in English\n    test_table_protocol: \"Protocol A\",     // Protocol name\n    test_table_protocol_eng: \"Protocol A (ENG)\", // Protocol in English\n    test_table_std_ref: \"STD123\",          // Standard reference\n    test_table_std_ref_eng: \"STD123 (ENG)\",// Standard reference in English\n    test_table_unit: \"mg/L\",               // Test unit\n    test_table_unit_eng: \"mg/L\",           // Unit in English\n    test_table_result: \"Positive\",         // Test result\n    test_table_result_eng: \"Positive\",     // Result in English\n    comment_title: \"Test Comment\",         // Comment title\n    format_is_comment: true,               // Boolean for comment format\n    comment_detail: \"Detailed comment here\",// Comment details\n    test_note_title: \"Note Title\",         // Note title\n    test_note_detail: \"Detail for the note\"// Detail for the note\n};\n\nconst {test_data, report_data} = {test_data: [{id:1}, {id:2}] , report_data:sampleReport}\n\ntry {\n    if(test_data !== null && report_data !== null){\n        // check exist sample\n        if(report_data.sample_id !== null){\n            const instance = new tables.Sample(report_data.sample_id);\n            if (await instance.get() === null ) throw new Error('Sample is not exist');\n            node.warn(JSON.parse(JSON.stringify(instance)));\n            //Insert DB\n            const addSampleReport = await tables.SampleReport.new(sampleReport);\n            node.warn(JSON.parse(JSON.stringify(addSampleReport))); \n        } else  {\n            throw new Error('Sample id is required');\n        }\n    }else{   \n        throw new Error('test_data & report_data is empty');\n    }\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 1040,
        "wires": [
            []
        ]
    },
    {
        "id": "425d2d2592033e6a",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST NEW TEST REPORT",
        "func": "const tables = global.get('tables');\n\nconst sampleReportTest = {\n    sample_report_id: 3700,               // Reference ID linking to `sample_report`\n    sample_id: 3566,                    // ID for the sample\n    sample_receipt_id: 1220,    // Unique identifier for the sample receipt\n    test_name_secondary: \"Secondary Test\", // Secondary test name\n    test_order_id: 24440,                  // Order ID for the test\n    test_name: \"Test Name\",            // Name of the test\n    protocol_id: 1001,                 // ID for the protocol used\n    protocol_value: \"Protocol Value\",  // Value associated with the protocol\n    vlas: false,                       // Boolean for VLAS (default is false)\n    external: true,                    // Boolean for external testing (default is false)\n    lab_id: 1,                      // Lab ID where the test was conducted\n    std_ref: \"STD-12345\",              // Standard reference identifier\n    result_unit: \"mg/L\",               // Unit for the result\n    result_value: \"20.5\"               // Value of the test result\n    // created_at will default to the current timestamp, no need to set it manually\n};\n\ntry {\n    const add = await tables.TestReport.new(sampleReportTest);\n    node.warn(JSON.parse(JSON.stringify(add))); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1080,
        "wires": [
            []
        ]
    },
    {
        "id": "dbf7e35619c42da4",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1080,
        "wires": [
            [
                "425d2d2592033e6a"
            ]
        ]
    },
    {
        "id": "7cb5672fb0a1f133",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET REPORT",
        "func": "const tables = global.get('tables');\n\ntry {\n    const instance = new tables.SampleReport(11);\n    const obj = await instance.get();\n\n    node.warn(JSON.parse(JSON.stringify(obj)));\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 1120,
        "wires": [
            []
        ]
    },
    {
        "id": "f1b2fd8bfe3ae35d",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1120,
        "wires": [
            [
                "7cb5672fb0a1f133"
            ]
        ]
    },
    {
        "id": "2910e99ae2994348",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1160,
        "wires": [
            [
                "e1633ecf3c211bb1"
            ]
        ]
    },
    {
        "id": "e1633ecf3c211bb1",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET SAMPLE",
        "func": "const tables = global.get('tables');\n\ntry {\n    const sample = await tables.Sample.get(3770);\n    node.warn(sample);\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 1160,
        "wires": [
            []
        ]
    },
    {
        "id": "53b5df58195808c4",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET SAMPLE REPORT",
        "func": "const tables = global.get('tables');\n\ntry {\n    const sample = await tables.SampleReport.fromSample(11);\n    node.warn(sample);\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 1200,
        "wires": [
            []
        ]
    },
    {
        "id": "b9996aa3dddd8d9c",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1200,
        "wires": [
            [
                "53b5df58195808c4"
            ]
        ]
    },
    {
        "id": "5f56f8d524b846e0",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SEARCH RECIPT",
        "func": "const tables = global.get('tables');\n\ntry {\n    const search = await tables.Receipt.searchReceipts('AVATEK');\n    node.warn(search); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 1080,
        "wires": [
            []
        ]
    },
    {
        "id": "72de7d067ff17ba9",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1080,
        "wires": [
            [
                "5f56f8d524b846e0"
            ]
        ]
    },
    {
        "id": "5ea3b668f0f5536b",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1040,
        "wires": [
            [
                "69af6a65da9f7a7d"
            ]
        ]
    },
    {
        "id": "69af6a65da9f7a7d",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SEARCH PROTOCOL",
        "func": "const tables = global.get('tables');\n\ntry {\n    const search = await tables.LibProtocol.searchProtocols('HDPP233-KN');\n    node.warn(search); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 1040,
        "wires": [
            []
        ]
    },
    {
        "id": "23773f85a11b3318",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST SEARCH CLIENT",
        "func": "const tables = global.get('tables');\n\ntry {\n    const search = await tables.Client.searchClients('AVATEK');\n    node.warn(search); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 1000,
        "wires": [
            []
        ]
    },
    {
        "id": "8e017d1c2301e479",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1000,
        "wires": [
            [
                "23773f85a11b3318"
            ]
        ]
    },
    {
        "id": "d7fd09bb478e43d8",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET ASSIGN_DEPT_LIST",
        "func": "const tables = global.get('tables');\n\ntry {\n    const result = await tables.LibLab.get_assign_dept_list();\n    node.warn(result); \n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1000,
        "wires": [
            []
        ]
    },
    {
        "id": "2f3ccf5ef73b7f37",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1000,
        "wires": [
            [
                "d7fd09bb478e43d8"
            ]
        ]
    },
    {
        "id": "0ea883bd94017958",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET PROTOCOL",
        "func": "const tables = global.get('tables');\n\ntry {\n    const instace = new tables.LibProtocol(20);\n    await instace.get();\n    node.warn(JSON.parse(JSON.stringify(instace)));\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 1240,
        "wires": [
            []
        ]
    },
    {
        "id": "1e48bdb012092b68",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1240,
        "wires": [
            [
                "0ea883bd94017958"
            ]
        ]
    },
    {
        "id": "bd4ebf58b6419979",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "TEST GET TESTS",
        "func": "const tables = global.get('tables');\n\ntry {\n    const instace = new tables.Test(400);\n    await instace.get();\n    node.warn(JSON.parse(JSON.stringify(instace)));\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 1280,
        "wires": [
            []
        ]
    },
    {
        "id": "a6e93ccd7d251031",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1280,
        "wires": [
            [
                "bd4ebf58b6419979"
            ]
        ]
    },
    {
        "id": "7666f13515385fab",
        "type": "comment",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "info": "Todo: authenticate",
        "x": 120,
        "y": 580,
        "wires": []
    },
    {
        "id": "384baf7007c675f8",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1280,
        "wires": [
            [
                "1913a0ec76b765b2"
            ]
        ]
    },
    {
        "id": "1913a0ec76b765b2",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Test add user",
        "func": "const tables = global.get('tables');\nconst newUser = {\n        id: 38,\n        created_at: 1730773830107,\n        name: \"Trần Tú\",\n        user_uid: \"\",\n        email: \"trantu02.efw@gmail.com\",\n        phone: \"\",\n        password: \"123abcd\",\n        employee: true,\n        org_admin: true,\n        disabled: false,\n        force_reset_pw: false,\n        force_sign_out: false\n    }\n\ntry {\n    // Chuyển đổi thời gian từ mili-giây sang giây\n    newUser.created_at = new Date(newUser.created_at).toISOString();\n    const newuser = await tables.User.new(newUser);\n    node.warn(`Populated user ${newUser.id}`);\n    \n    node.warn(newuser);\n} catch (error) {\n    node.warn(error);\n};\n    \nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 1280,
        "wires": [
            []
        ]
    },
    {
        "id": "88f940cca9302e13",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1320,
        "wires": [
            [
                "59080bb74c31734a"
            ]
        ]
    },
    {
        "id": "59080bb74c31734a",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Test Login",
        "func": "const tables = global.get('tables');\nconst  email = \"trantu02.efw@gmail.com\"\nconst  password = \"123abcd\"\n\ntry {\n    const login = await tables.User.login(email,password);\n    \n    if(login){\n        node.warn(\"Correct\");\n        node.warn(login);\n    }else{\n        node.warn(\"Again\")\n    }\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 1320,
        "wires": [
            []
        ]
    },
    {
        "id": "a61d70058026ea9c",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1320,
        "wires": [
            [
                "04904e86a0ec26f3"
            ]
        ]
    },
    {
        "id": "04904e86a0ec26f3",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "test client UID",
        "func": "\nconst abc = crypto.randomUUID().substr(0, 8)\nnode.warn(abc);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 840,
        "y": 1320,
        "wires": [
            []
        ]
    },
    {
        "id": "9f1a7d62cd87f04c",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Test auth",
        "func": "const tables = global.get('tables');\nconst  email = \"trantu02.efw@gmail.com\"\nconst  password = \"123abcd\"\n\ntry {\n    const user = new tables.User(5);\n    await user.get();\n    node.warn(JSON.parse(JSON.stringify(user)));\n\n    await user.authenticate();\n\n} catch (error) {\n    node.warn(error);\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 1360,
        "wires": [
            []
        ]
    },
    {
        "id": "cc5f3a160c1c946e",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1360,
        "wires": [
            [
                "9f1a7d62cd87f04c"
            ]
        ]
    },
    {
        "id": "e78d8f6b94f6ec77",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "xano layer",
        "func": "const axios = global.get('axios');\n\nconst xano_headers = {\n\t'Content-Type': 'application/json',\n\tauthorization: `Bearer eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.pU_6QICoFZ4mk_14AsGn5NC_QyG_XRAdOj_NGLZHLgXOQ9kPM1htnVCyGLu2Dx6QHu2qpglHwYJTd_mk6keIYCwaTOkWu0yA.gS-Ca-5y69wA9UyOjDpZGw.tNJRhxyJ9adJ6GgUJzPeruycVVXypFRXDzOXw2OE_u2fwcD38Qvwe4ly2GYkCg0WsI4XnptmGllU6sEIMbuDe8qWQ6KWkaeLWrv10WQpGNwVJPjUf2kXqaJ9dywGZXLx1CaKf2QfBvzQRfrUObwuLl0B8SyrqldH9bRjZiffxoBNws7-SBitxh8zJxZHyuntQB1bLmF6aEdqaI3n2EaSZXjHtOm4BJ5apPRPIq3ViefhAzplqhHy5wLGTgsCcYjSS0xWFDIlGOSx7vUhxBCTc5x2mj3JxmMfAv_UZhAZPaWcRDW70ofwlW4V2V0fNh2ieNvwTFAWYIRTbxw92inO8M7DFqZ1yoMDriSNvCt4qNor8udWRHrlIbMlbekjulZZAWl2G3oPgwCVZH0d_mM_wavM2C127OYjQwPCdh9pP6LlRidvZWYl-fcZqyy_-RA-Q2sxC6cuBso5Gapb-RZnnA.Y42BoFfDRXq4mlUs8QQ6gGNr2e4T8Vxs4s83TqeBacw`,\n};\n\nglobal.set('xano_headers', xano_headers);\n\n// TODO: get_receipt_by_id\n\nconst xano = {\n\tflag: false,\n\n\tbridge_api: true, // if true, use xano\n\n\tbridge_auth: true, // if true, use xano auth\n\n\t////////// TODO FUNCTIONS //////////\n\t// function riêng cho NODE-RED tương tác với XANO SERVER với auth token riêng\n\n\txn_get_recent_receipts: async (rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_receipt/_get/_recent\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_receipt/_get/_recent', {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_sample_analytes_by_uid: async (sample_uid, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/_get_by_uid/{uid}\n\t\ttry {\n\t\t\tconst response = await axios.get(\n\t\t\t\t`https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/_get_by_uid/${sample_uid}`,\n\t\t\t\t{\n\t\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\txn_get_processing_samples: async (user_token, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample/_get/_processing\n\t\ttry {\n\t\t\tconst headers = {\n\t\t\t\taccept: 'application/json',\n\t\t\t\tauthorization: `Bearer ${user_token}`,\n\t\t\t};\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_sample/_get/_processing', {\n\t\t\t\theaders: headers,\n\t\t\t});\n\t\t\tnode.warn(response.data);\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tsearch_receipts: async (query, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_search/_get/_receipts\n\t\t// body: {query: query}\n\t\ttry {\n\t\t\tconst response = await axios.post(\n\t\t\t\t'https://xn.irdop.org/api:l-KUlHFI/_search/_get/_receipts',\n\t\t\t\t{\n\t\t\t\t\tquery: query,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t\t},\n\t\t\t);\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_receipt_by_id: async (id, rethrow) => {\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_node/_get/_receipt/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_lab_by_id: async (id, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_lab/_get/{lib_lab_id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_lab/_get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tfind_samples_by_receipt_id: async (id, rethrow) => {\n\t\t// TODO: get_samples_by_receipt_id https://xn.irdop.org/api:l-KUlHFI/_receipt/_get/_samples/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_receipt/_get/_samples/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_sample_report_by_id: async (id, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_report/_get/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_report/_get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_sample_report_by_sample_id: async (id, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample/_get/_report/{sample_id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_sample/_get/_report/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_sample_by_id: async (id, rethrow) => {\n\t\t// https://xn.irdop.org/api:l-KUlHFI/_sample/get/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_sample/get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_sample_price_by_id: async (id, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample_prices/_get_/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_sample_prices/_get_/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_sample_price_by_sample_id: async (id, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample_prices/_get/{sample_id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_sample_prices/_get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_test_order_by_id: async (id, rethrow) => {\n\t\t// https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/get/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tfind_test_orders_by_sample_id: async (id, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample/_get_analyte/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_sample/_get_analyte/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_client_by_id: async (id, rethrow) => {\n\t\t// https://xn.irdop.org/api:l-KUlHFI/_client/_get/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_client/_get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_department_by_id: async (id, rethrow) => {\n\t\t// https://xn.irdop.org/api:l-KUlHFI/_department/_get/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_department/_get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_lib_protocol_by_id: async (id, rethrow) => {\n\t\t// https://xn.irdop.org/api:l-KUlHFI/_analyte/_get/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_analyte/_get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_user_by_id: async (id, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_user/get/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_user/get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_receipt_price_by_id: async (id, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_receipt_prices/_get/{id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_receipt_prices/_get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tget_analyte_by_id: async (id, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_test/get/{lib_tests_id}\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:l-KUlHFI/_test/get/' + id, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tupdate_receipt: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_receipt/_update\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_receipt/_update', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tupdate_sample: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_receipt/_update\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_sample/_update', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tupdate_test_order: async (body, rethrow) => {\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/_update', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tupdate_fee: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/_edit/_fee\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/_edit/_fee', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tadd_sample_analyte: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/_add\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/_add', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tadd_sample: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_receipt/_add/_sample\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_receipt/_add/_sample', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tadd_analyte_protocol: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_analyte_protocol/_add\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_analyte_protocol/_add', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tadd_client: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_client/_add\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_client/_add', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tadd_analyte: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_analyte/_add\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_analyte/_add', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tadd_receipt: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_receipt/_add\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_receipt/_add', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tdelete_receipt: async (body, rethrow) => {},\n\n\tdelete_sample: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample/_delete\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_sample/_delete', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\tdelete_sample_analyte: async (body, rethrow) => {\n\t\t//https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/_delete\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:l-KUlHFI/_sample_analyte/_delete', body, {\n\t\t\t\theaders: global.get('xano_headers'),\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\txano.errorHandler(error, rethrow);\n\t\t}\n\t},\n\n\t//////////  RECEIPTS API BRIDGE  //////////\n\tget_recent_receipts: async (headers) => {\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:hrFfPpfK/receipt_list/_get/recent_receipts', {\n\t\t\t\theaders: headers,\n\t\t\t});\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tnode.warn(error.stack);\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tget_detail_sample: async (params, headers) => {\n\t\ttry {\n\t\t\tconst response = await axios.get(\n\t\t\t\t'https://xn.irdop.org/api:hrFfPpfK/sample_detail/_get/sample/' + params.sample_id,\n\t\t\t\t{ headers: headers },\n\t\t\t);\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tget_detail_receipt: async (params, headers) => {\n\t\ttry {\n\t\t\tconst response = await axios.get(\n\t\t\t\t'https://xn.irdop.org/api:hrFfPpfK/receipt_detail/_get/receipt/' + params.receipt_id,\n\t\t\t\t{ headers: headers },\n\t\t\t);\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tpost_create_receipt: async (headers, body) => {\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:hrFfPpfK/receipt_list/_new/receipt', body, {\n\t\t\t\theaders: headers,\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tpost_delete_receipt: async (headers, body) => {\n\t\ttry {\n\t\t\tconst response = await axios.post(\n\t\t\t\t'https://xn.irdop.org/api:zGP0ovp2/sample_receipt_dashboard/delete_receipt',\n\t\t\t\tbody,\n\t\t\t\t{ headers: headers },\n\t\t\t);\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tget_bulk_receipts: async (headers, body) => {\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:hrFfPpfK/receipt_list/_get/bulk_receipts', body, {\n\t\t\t\theaders: headers,\n\t\t\t});\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\t//////////  SAMPLES  //////////\n\tpost_create_sample: async (headers, body) => {\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:hrFfPpfK/receipt_detail/_new/sample', body, {\n\t\t\t\theaders: headers,\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tget_processing_samples: async (headers) => {\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:FzsHe1z4/sample_mgr/get_processing_samples', {\n\t\t\t\theaders: headers,\n\t\t\t});\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tpost_sample_add_tests: async (headers, body) => {\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:hrFfPpfK/sample_detail/_add/tests', body, {\n\t\t\t\theaders: headers,\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tpost_delete_test_from_sample: async (headers, body) => {\n\t\ttry {\n\t\t\tconst response = await axios.post(\n\t\t\t\t'https://xn.irdop.org/api:hrFfPpfK/test/_delete/delete_test_from_sample',\n\t\t\t\tbody,\n\t\t\t\t{ headers: headers },\n\t\t\t);\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tpost_delete_sample: async (headers, body) => {\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:hrFfPpfK/receipt_detail/_delete/sample', body, {\n\t\t\t\theaders: headers,\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tpost_submit_test_result: async (headers, body) => {\n\t\t/**\n\t\t * Submits test results to the XN server\n\t\t * @param {Object} headers - The HTTP request headers\n\t\t * @param {Object} body - The request body containing test results\n\t\t * @param {Object} body.result_submit - The test result data\n\t\t * @returns {Promise<{test_order, protocol}|Error>} A promise that resolves with the test order response or rejects with an Error\n\t\t */\n\t\ttry {\n\t\t\tconst response = await axios.post('https://xn.irdop.org/api:eHOTU1fm/POST/_edit/submit_result', body, {\n\t\t\t\theaders: headers,\n\t\t\t});\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\n\tauth_me_employee: async (headers) => {\n\t\ttry {\n\t\t\tconst response = await axios.get('https://xn.irdop.org/api:e2HKBcnJ/auth/me_employee', { headers: headers });\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (error.response) {\n\t\t\t\tconst err = new Error(error.response.data.message + ` ${error.response.status}`);\n\t\t\t\terr.statusCode = error.response.status;\n\t\t\t\tthrow err;\n\t\t\t} else if (error.request) {\n\t\t\t\tconst err = new Error('No response from XN server');\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\tconst err = new Error('Unexpected error requesting XN server: ' + error.message);\n\t\t\t\terr.statusCode = 500;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n};\n\nxano.errorHandler = (error, rethrow) => {\n\tnode.warn(error.stack);\n\tconst err = new Error(error.message);\n\terr.statusCode = error.statusCode;\n\tif (rethrow) throw err;\n};\n\n// export functions\nglobal.set('xano', xano);\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "d154e66024c00edf",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 340,
        "y": 500,
        "wires": [
            [
                "56e29e13fe69df57"
            ]
        ]
    },
    {
        "id": "56e29e13fe69df57",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Log recentReceipt_cache",
        "func": "const cache = global.get('cache');\n\nconst receipts = cache.recentReceipts;\nnode.warn(receipts)\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 500,
        "wires": [
            []
        ]
    },
    {
        "id": "dc109e8a7740ba59",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 340,
        "y": 540,
        "wires": [
            [
                "b73caebbb33a1cab"
            ]
        ]
    },
    {
        "id": "b73caebbb33a1cab",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Log processingSample",
        "func": "const cache = global.get('cache');\n\nconst receipts = cache.processingSamples;\nnode.warn(receipts)\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "1809df8c23f4f417",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 340,
        "y": 580,
        "wires": [
            [
                "e64848a9c21540f5"
            ]
        ]
    },
    {
        "id": "e64848a9c21540f5",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Clear Log processingSample",
        "func": "const cache = global.get('cache');\n\ncache.processingSamples = {};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "5fea1f3d11b6585c",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Cache layer",
        "func": "const cache = {\n\t// Cache storage objects\n\treceipt: {},\n\treceiptFull: {},\n\treceiptPrice: {},\n\tsample: {},\n\ttest: {},\n\tclient: {},\n\tuser: {},\n\tsampleReport: {},\n\tsamplePrice: {},\n\trecentReceipts: {},\n\tprocessingSamples: {}, // User Token as key\n\tsampleAnalyte: {},\n\tanalyteProtocol: {},\n\tdepartment: {},\n\tanalyte: {},\n\tlab: {},\n\n\t// Generic cache handlers\n\tset: (type, item, max_age = 60 * 60 * 1000) => {\n\t\t// 1 hour\n\t\tif (!cache[type]) throw new Error(`Invalid cache type: ${type}`);\n\n\t\tcache[type][item.id] = {\n\t\t\tvalue: item,\n\t\t\tcached_at: Date.now(),\n\t\t\tmax_age: max_age,\n\t\t};\n\t},\n\n\tget: (type, id, age_limit) => {\n\t\tif (!cache[type]) throw new Error(`Invalid cache type: ${type}`);\n\t\tif (!cache[type][id]) return null;\n\n\t\tconst item = cache[type][id];\n\t\tage_limit = age_limit || item.max_age;\n\n\t\tif (item.cached_at + age_limit < Date.now()) {\n\t\t\tdelete cache[type][id];\n\t\t\treturn null;\n\t\t}\n\t\treturn item.value;\n\t},\n\n\t// Convenience methods\n\tsetReceipt: (receipt, max_age) => cache.set('receipt', receipt, max_age),\n\tgetReceipt: (id, age_limit) => cache.get('receipt', id, age_limit),\n\tdelReceipt: (id) => delete cache.receipt[id],\n\n\tsetReceiptFull: (receiptFull, max_age) => cache.set('receiptFull', receiptFull, max_age),\n\tgetReceiptFull: (id, age_limit) => cache.get('receiptFull', id, age_limit),\n\tdelReceiptFull: (id) => delete cache.receiptFull[id],\n\n\tsetSample: (sample, max_age) => cache.set('sample', sample, max_age),\n\tgetSample: (id, age_limit) => cache.get('sample', id, age_limit),\n\tdelSample: (id) => delete cache.sample[id],\n\n\tsetTest: (test, max_age) => cache.set('test', test, max_age),\n\tgetTest: (id, age_limit) => cache.get('test', id, age_limit),\n\tdelTest: (id) => delete cache.test[id],\n\n\tsetClient: (client, max_age) => cache.set('client', client, max_age),\n\tgetClient: (id, age_limit) => cache.get('client', id, age_limit),\n\tdelClient: (id) => delete cache.client[id],\n\n\tsetUser: (user, max_age) => cache.set('user', user, max_age),\n\tgetUser: (id, age_limit) => cache.get('user', id, age_limit),\n\tdelUser: (id) => delete cache.user[id],\n\n\tsetReceiptPrice: (receiptPrice, max_age) => cache.set('receiptPrice', receiptPrice, max_age),\n\tgetReceiptPrice: (id, age_limit) => cache.get('receiptPrice', id, age_limit),\n\tdelReceiptPrice: (id) => delete cache.receiptPrice[id],\n\n\tsetAnalyteProtocol: (analyteProtocol, max_age) => cache.set('analyteProtocol', analyteProtocol, max_age),\n\tgetAnalyteProtocol: (id, age_limit) => cache.get('analyteProtocol', id, age_limit),\n\tdelAnalyteProtocol: (id) => delete cache.analyteProtocol[id],\n\n\tsetSampleAnalyte: (sampleAnalyte, max_age) => cache.set('sampleAnalyte', sampleAnalyte, max_age),\n\tgetSampleAnalyte: (id, age_limit) => cache.get('sampleAnalyte', id, age_limit),\n\tdelSampleAnalyte: (id) => delete cache.sampleAnalyte[id],\n\n\tsetSampleReport: (sampleReport, max_age) => cache.set('sampleReport', sampleReport, max_age),\n\tgetSampleReport: (id, age_limit) => cache.get('sampleReport', id, age_limit),\n\tdelSampleReport: (id) => delete cache.sampleReport[id],\n\n\tsetSampleReportTest: (sampleReportTest, max_age) => cache.set('sampleReportTest', sampleReportTest, max_age),\n\tgetSampleReportTest: (id, age_limit) => cache.get('sampleReportTest', id, age_limit),\n\tdelSampleReportTest: (id) => delete cache.sampleReportTest[id],\n\n\tsetDepartment: (department, max_age) => cache.set('department', department, max_age),\n\tgetDepartment: (id, age_limit) => cache.get('department', id, age_limit),\n\tdelDepartment: (id) => delete cache.department[id],\n\n\t//samplePrice\n\tsetSamplePrice: (samplePrice, max_age) => cache.set('samplePrice', samplePrice, max_age),\n\tgetSamplePrice: (id, age_limit) => cache.get('samplePrice', id, age_limit),\n\tdelSamplePrice: (id) => delete cache.samplePrice[id],\n\n\t//analyte\n\tsetAnalyte: (analyte, max_age) => cache.set('analyte', analyte, max_age),\n\tgetAnalyte: (id, age_limit) => cache.get('analyte', id, age_limit),\n\tdelAnalyte: (id) => delete cache.analyte[id],\n\n\t//lab\n\tsetLab: (lab, max_age) => cache.set('lab', lab, max_age),\n\tgetLab: (id, age_limit) => cache.get('lab', id, age_limit),\n\tdelLab: (id) => delete cache.lab[id],\n\n\t// Set cache processing sample for each sample (user_token.split('.')[1] as key)\n\tsetProcessingSamples: (user_token, processingSample, max_age = 20 * 60 * 1000) => {\n\t\tif (!cache.processingSamples[user_token]) cache.processingSamples[user_token] = {};\n\t\tcache.processingSamples[user_token] = {\n\t\t\tvalue: processingSample,\n\t\t\tcached_at: Date.now(),\n\t\t\tmax_age: max_age,\n\t\t};\n\t},\n\t// Get cache processing sample by user_token\n\tgetProcessingSamples: (user_token, age_limit = 20 * 60 * 1000) => {\n\t\tif (!cache.processingSamples[user_token]) return null;\n\n\t\tconst item = cache.processingSamples[user_token];\n\t\tage_limit = age_limit || item.max_age;\n\n\t\tif (item.cached_at + age_limit < Date.now()) {\n\t\t\tdelete cache.processingSamples[user_token];\n\t\t\treturn null;\n\t\t}\n\n\t\treturn item.value;\n\t},\n};\n\n// Export Cache to global\nglobal.set('cache', cache);\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 220,
        "wires": [
            [
                "1398d930cd2dd1d9"
            ]
        ]
    },
    {
        "id": "1cd6fa8e66c1f3af",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 340,
        "y": 740,
        "wires": [
            [
                "2170c27a5379c721"
            ]
        ]
    },
    {
        "id": "2170c27a5379c721",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "compareStructure",
        "func": "// Ví dụ\nconst obj1 = {\n  id: 1322,\n  created_at: 1732329807733,\n  receipt_uid: 'TNM.244723-04',\n  client_id: 821,\n  receipt_by_lab_id: 0,\n  receipt_by_user_id: 29,\n  receipt_date: '2024-11-21',\n  commencement_date: null,\n  eta_days: 0,\n  archived: false,\n  note: '',\n  ppt_copies: 1,\n  submission_person_name: '',\n  submission_courier_name: 'shipper',\n  report_method_in_person: false,\n  report_method_courier_address: 'Viettel Post',\n  report_method_email: '',\n  report_method_zalo: '',\n  contact_person_name: '',\n  contact_person_phone: '',\n  contact_person_email: '',\n  receipt_by_user: {\n    id: 29,\n    created_at: 1717643358265,\n    name: 'Lê Thị Quỳnh',\n    user_uid: 'Ex08fb9c7',\n    email: 'lethiquynh.k60cnshc@gmail.com',\n    phone: '',\n    password:\n      'a21f2cf0c4084db8.b3fcffc46e926480e35f66592986d5d9136bfb912c5ad19a424898bf79780089',\n    employee: true,\n    org_admin: false,\n    disabled: false,\n    force_reset_pw: false,\n    force_sign_out: false,\n  },\n  client: {\n    id: 821,\n    created_at: 1733999943139,\n    client_name:\n      'NHÀ MÁY SẢN XUẤT CÔNG TY CỔ PHẦN TẬP ĐOÀN DINH DƯỠNG MRIK - CHI NHÁNH HÒA BÌNH',\n    client_uid: 'CL.23b6634',\n    code: '',\n    address: 'Thôn Cố Thổ, xã Hòa Sơn, huyện Lương Sơn, tỉnh Hòa Bình',\n    legal_id: '0109632159-002',\n    note: '',\n  },\n  receipt_prices: {\n    id: 1322,\n    created_at: 1732329807740,\n    sample_receipt_id: 1322,\n    gross: 1200000,\n    premium_rate: 0,\n    premium: 0,\n    discount_rate: 0,\n    discount: 0,\n    tax: 60000,\n    tax_rate: 0.05,\n    payable: 1260000,\n  },\n  samples: [\n    {\n      id: 3937,\n      created_at: 1732331320025,\n      sample_uid: 'SP.244823-17',\n      sample_name: 'Thực phẩm bổ sung Venus Canxi',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 29,\n      commencement_time: null,\n      modified_at: 1733992163408,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 29,\n        created_at: 1717643358265,\n        name: 'Lê Thị Quỳnh',\n        user_uid: 'Ex08fb9c7',\n        email: 'lethiquynh.k60cnshc@gmail.com',\n        phone: '',\n        password:\n          'a21f2cf0c4084db8.b3fcffc46e926480e35f66592986d5d9136bfb912c5ad19a424898bf79780089',\n        employee: true,\n        org_admin: false,\n        disabled: false,\n        force_reset_pw: false,\n        force_sign_out: false,\n      },\n      test_orders: [\n        {\n          id: 27283,\n          created_at: 1732335044526,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003EKPH (LOD:10)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27284,\n          created_at: 1732335044536,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Staphylococci (+) coagulase',\n          test_name_secondary: '',\n          lib_test_id: 781,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 19,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003EKPH (LOD:10)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 19,\n            created_at: 1691815958050,\n            name: 'Định lượng Staphylococci có phản ứng dương tính coagulase (S. aureus và các loài khác) trên đĩa thạch trong thực phẩm, thức ăn chăn nuôi',\n            code: 'TCVN 4830-1:2005 (ISO 6888-1:1999; AMD 1:2003)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27285,\n          created_at: 1732335044623,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Listeria monocytogenes',\n          test_name_secondary: '',\n          lib_test_id: 61,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 997,\n          vlas: false,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value:\n            '\\u003Cp\\u003EKPH (eLOD\\u003Csub\\u003E50\\u003C/sub\\u003E:5)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/25g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 997,\n            created_at: 1721883537337,\n            name: 'Listeria monocytogenes',\n            code: 'TCVN 7700-1:2007',\n            name_secondary: '',\n            vlas: false,\n            modified_by: 23,\n            accreditation_source: 'IRDOP',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27286,\n          created_at: 1732335044632,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value:\n            '\\u003Cp\\u003EKPH (eLOD\\u003Csub\\u003E50\\u003C/sub\\u003E:5)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/25g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27287,\n          created_at: 1732335044640,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,1)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704893292,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27288,\n          created_at: 1732335044647,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,018)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704902133,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27289,\n          created_at: 1732335044653,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,0014)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704906740,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27290,\n          created_at: 1732335044729,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,012)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704915925,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n      ],\n      sample_prices: {\n        id: 3931,\n        created_at: 1732331320120,\n        sample_id: 3937,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      reports: [],\n    },\n    {\n      id: 3936,\n      created_at: 1732330570243,\n      sample_uid: 'SP.244823-16',\n      sample_name: 'Thực phẩm bổ sung Venus Glusure',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 29,\n      commencement_time: null,\n      modified_at: 1733992154701,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 29,\n        created_at: 1717643358265,\n        name: 'Lê Thị Quỳnh',\n        user_uid: 'Ex08fb9c7',\n        email: 'lethiquynh.k60cnshc@gmail.com',\n        phone: '',\n        password:\n          'a21f2cf0c4084db8.b3fcffc46e926480e35f66592986d5d9136bfb912c5ad19a424898bf79780089',\n        employee: true,\n        org_admin: false,\n        disabled: false,\n        force_reset_pw: false,\n        force_sign_out: false,\n      },\n      test_orders: [\n        {\n          id: 27168,\n          created_at: 1732330758627,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003EKPH (LOD:10)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27174,\n          created_at: 1732330811914,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Staphylococci (+) coagulase',\n          test_name_secondary: '',\n          lib_test_id: 781,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 19,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003EKPH (LOD:10)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 19,\n            created_at: 1691815958050,\n            name: 'Định lượng Staphylococci có phản ứng dương tính coagulase (S. aureus và các loài khác) trên đĩa thạch trong thực phẩm, thức ăn chăn nuôi',\n            code: 'TCVN 4830-1:2005 (ISO 6888-1:1999; AMD 1:2003)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27180,\n          created_at: 1732330919912,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Listeria monocytogenes',\n          test_name_secondary: '',\n          lib_test_id: 61,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 997,\n          vlas: false,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value:\n            '\\u003Cp\\u003EKPH (eLOD\\u003Csub\\u003E50\\u003C/sub\\u003E:5)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/25g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 997,\n            created_at: 1721883537337,\n            name: 'Listeria monocytogenes',\n            code: 'TCVN 7700-1:2007',\n            name_secondary: '',\n            vlas: false,\n            modified_by: 23,\n            accreditation_source: 'IRDOP',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27186,\n          created_at: 1732330967048,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value:\n            '\\u003Cp\\u003EKPH (eLOD\\u003Csub\\u003E50\\u003C/sub\\u003E:5)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/25g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27187,\n          created_at: 1732330985411,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,1)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704927415,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27188,\n          created_at: 1732330999337,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,018)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704938733,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27194,\n          created_at: 1732331022190,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,0014)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704943689,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27195,\n          created_at: 1732331043382,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,012)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704961565,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n      ],\n      sample_prices: {\n        id: 3930,\n        created_at: 1732330570252,\n        sample_id: 3936,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      reports: [],\n    },\n    {\n      id: 3941,\n      created_at: 1732332224722,\n      sample_uid: 'SP.244823-21',\n      sample_name:\n        'Sản phẩm dinh dưỡng công thức dành cho trẻ từ 0-12 tháng tuổi Snow Clostrum',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 28,\n      commencement_time: null,\n      modified_at: 1733997899143,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 28,\n        created_at: 1715825164244,\n        name: 'Đỗ Thị Dung',\n        user_uid: 'Ex9a920f9',\n        email: 'Dothuydung752002@gmail.com',\n        phone: '0383770345',\n        password:\n          '9950acb26c41caf9.4ca5f6754e03bbd7aa702bcdd8f8519283f51c7aa71aa877c35027cf183178bc',\n        employee: true,\n        org_admin: false,\n        disabled: false,\n        force_reset_pw: false,\n        force_sign_out: false,\n      },\n      test_orders: [\n        {\n          id: 27391,\n          created_at: 1732338392828,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Enterobacter sakazakii',\n          test_name_secondary: '',\n          lib_test_id: 966,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '\\u003Cp\\u003EKPH (LOD:10)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/g\\u003C/p\\u003E',\n          protocol_value: 'TCVN 5518-2:2007',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27392,\n          created_at: 1732338392916,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value:\n            '\\u003Cp\\u003EKPH (eLOD\\u003Csub\\u003E50\\u003C/sub\\u003E:5)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/25g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27394,\n          created_at: 1732338393114,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,018)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704659379,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27395,\n          created_at: 1732338393219,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,0014)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704672339,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27396,\n          created_at: 1732338393327,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,012)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704808660,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 31075,\n          created_at: 1733999576509,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: false,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '',\n          result_unit: '',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-12-13',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n      ],\n      sample_prices: {\n        id: 3935,\n        created_at: 1732332224739,\n        sample_id: 3941,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      reports: [],\n    },\n    {\n      id: 3938,\n      created_at: 1732332208386,\n      sample_uid: 'SP.244823-18',\n      sample_name: 'Thực phẩm bổ sung Venus Curcumin',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 28,\n      commencement_time: null,\n      modified_at: 1733996728222,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 28,\n        created_at: 1715825164244,\n        name: 'Đỗ Thị Dung',\n        user_uid: 'Ex9a920f9',\n        email: 'Dothuydung752002@gmail.com',\n        phone: '0383770345',\n        password:\n          '9950acb26c41caf9.4ca5f6754e03bbd7aa702bcdd8f8519283f51c7aa71aa877c35027cf183178bc',\n        employee: true,\n        org_admin: false,\n        disabled: false,\n        force_reset_pw: false,\n        force_sign_out: false,\n      },\n      test_orders: [\n        {\n          id: 27301,\n          created_at: 1732335200223,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003EKPH (LOD:10)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27302,\n          created_at: 1732335200413,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Staphylococci (+) coagulase',\n          test_name_secondary: '',\n          lib_test_id: 781,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 19,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003EKPH (LOD:10)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 19,\n            created_at: 1691815958050,\n            name: 'Định lượng Staphylococci có phản ứng dương tính coagulase (S. aureus và các loài khác) trên đĩa thạch trong thực phẩm, thức ăn chăn nuôi',\n            code: 'TCVN 4830-1:2005 (ISO 6888-1:1999; AMD 1:2003)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27303,\n          created_at: 1732335200520,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Listeria monocytogenes',\n          test_name_secondary: '',\n          lib_test_id: 61,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 997,\n          vlas: false,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value:\n            '\\u003Cp\\u003EKPH (eLOD\\u003Csub\\u003E50\\u003C/sub\\u003E:5)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/25g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 997,\n            created_at: 1721883537337,\n            name: 'Listeria monocytogenes',\n            code: 'TCVN 7700-1:2007',\n            name_secondary: '',\n            vlas: false,\n            modified_by: 23,\n            accreditation_source: 'IRDOP',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27304,\n          created_at: 1732335200624,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value:\n            '\\u003Cp\\u003EKPH (eLOD\\u003Csub\\u003E50\\u003C/sub\\u003E:5)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/25g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27305,\n          created_at: 1732335200719,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,1)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704748037,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27306,\n          created_at: 1732335200815,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,018)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704757105,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27307,\n          created_at: 1732335200827,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,0014)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704767382,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27308,\n          created_at: 1732335200913,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,012)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704783056,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n      ],\n      sample_prices: {\n        id: 3932,\n        created_at: 1732332208427,\n        sample_id: 3938,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      reports: [],\n    },\n    {\n      id: 3939,\n      created_at: 1732332212001,\n      sample_uid: 'SP.244823-19',\n      sample_name:\n        'Sản phẩm dinh dưỡng công thức với mục đích ăn bổ sung dành cho trẻ từ 1-10 tuổi SNOW GROW EQ',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 28,\n      commencement_time: null,\n      modified_at: 1733996805823,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 28,\n        created_at: 1715825164244,\n        name: 'Đỗ Thị Dung',\n        user_uid: 'Ex9a920f9',\n        email: 'Dothuydung752002@gmail.com',\n        phone: '0383770345',\n        password:\n          '9950acb26c41caf9.4ca5f6754e03bbd7aa702bcdd8f8519283f51c7aa71aa877c35027cf183178bc',\n        employee: true,\n        org_admin: false,\n        disabled: false,\n        force_reset_pw: false,\n        force_sign_out: false,\n      },\n      test_orders: [\n        {\n          id: 27334,\n          created_at: 1732335801835,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003EKPH (LOD:10)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27335,\n          created_at: 1732335801846,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value:\n            '\\u003Cp\\u003EKPH (eLOD\\u003Csub\\u003E50\\u003C/sub\\u003E:5)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/25g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27336,\n          created_at: 1732335801916,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,1)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704851822,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27337,\n          created_at: 1732335801924,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,018)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704861176,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27338,\n          created_at: 1732335801931,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,0014)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704872081,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27339,\n          created_at: 1732335801939,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,012)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704881364,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n      ],\n      sample_prices: {\n        id: 3933,\n        created_at: 1732332212010,\n        sample_id: 3939,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      reports: [],\n    },\n    {\n      id: 3940,\n      created_at: 1732332215468,\n      sample_uid: 'SP.244823-20',\n      sample_name:\n        'Sản phẩm dinh dưỡng công thức với mục đích ăn bổ sung dành cho trẻ từ 1-10 tuổi SNOW PEDIA GOLD',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 28,\n      commencement_time: null,\n      modified_at: 1733997761413,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 28,\n        created_at: 1715825164244,\n        name: 'Đỗ Thị Dung',\n        user_uid: 'Ex9a920f9',\n        email: 'Dothuydung752002@gmail.com',\n        phone: '0383770345',\n        password:\n          '9950acb26c41caf9.4ca5f6754e03bbd7aa702bcdd8f8519283f51c7aa71aa877c35027cf183178bc',\n        employee: true,\n        org_admin: false,\n        disabled: false,\n        force_reset_pw: false,\n        force_sign_out: false,\n      },\n      test_orders: [\n        {\n          id: 27376,\n          created_at: 1732336079913,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003EKPH (LOD:10)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27377,\n          created_at: 1732336080023,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value:\n            '\\u003Cp\\u003EKPH (eLOD\\u003Csub\\u003E50\\u003C/sub\\u003E:5)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003ECFU/25g\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n        },\n        {\n          id: 27378,\n          created_at: 1732336080119,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,1)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704700233,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27379,\n          created_at: 1732336080214,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,018)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704713838,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27380,\n          created_at: 1732336080319,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,0014)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704724670,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n        {\n          id: 27381,\n          created_at: 1732336080417,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '\\u003Cp\\u003E\\u0026lt;LOQ (LOQ: 0,012)\\u003C/p\\u003E',\n          result_unit: '\\u003Cp\\u003Emg/kg\\u003C/p\\u003E',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704833048,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n            password:\n              'f359ce5e325d20cf.5f761841b63db134b12e0620b48ca5429876bd2faba550cc0986ef533bd728c9',\n            employee: true,\n            org_admin: false,\n            disabled: false,\n            force_reset_pw: false,\n            force_sign_out: false,\n          },\n        },\n      ],\n      sample_prices: {\n        id: 3934,\n        created_at: 1732332215481,\n        sample_id: 3940,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      reports: [],\n    },\n  ],\n};\n\nconst obj2 = {\n  id: 1322,\n  created_at: 1732329807733,\n  receipt_uid: 'TNM.244723-04',\n  client_id: 821,\n  receipt_by_lab_id: 0,\n  receipt_by_user_id: 29,\n  receipt_date: '2024-11-21',\n  commencement_date: null,\n  eta_days: 0,\n  archived: false,\n  note: '',\n  ppt_copies: 1,\n  submission_person_name: '',\n  submission_courier_name: 'shipper',\n  report_method_in_person: false,\n  report_method_courier_address: 'Viettel Post',\n  report_method_email: '',\n  report_method_zalo: '',\n  contact_person_name: '',\n  contact_person_phone: '',\n  contact_person_email: '',\n  client: {\n    id: 821,\n    created_at: 1733999943139,\n    client_name:\n      'NHÀ MÁY SẢN XUẤT CÔNG TY CỔ PHẦN TẬP ĐOÀN DINH DƯỠNG MRIK - CHI NHÁNH HÒA BÌNH',\n    client_uid: 'CL.23b6634',\n    code: '',\n    address: 'Thôn Cố Thổ, xã Hòa Sơn, huyện Lương Sơn, tỉnh Hòa Bình',\n    legal_id: '0109632159-002',\n    note: '',\n  },\n  receipt_by_user: {\n    id: 29,\n    created_at: 1717643358265,\n    name: 'Lê Thị Quỳnh',\n    user_uid: 'Ex08fb9c7',\n    email: 'lethiquynh.k60cnshc@gmail.com',\n    phone: '',\n  },\n  receipt_prices: {\n    id: 1322,\n    created_at: 1732329807740,\n    sample_receipt_id: 1322,\n    gross: 1200000,\n    premium_rate: 0,\n    premium: 0,\n    discount_rate: 0,\n    discount: 0,\n    tax: 60000,\n    tax_rate: 0.05,\n    payable: 1260000,\n  },\n  samples: [\n    {\n      id: 3936,\n      created_at: 1732330570243,\n      sample_uid: 'SP.244823-16',\n      sample_name: 'Thực phẩm bổ sung Venus Glusure',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 29,\n      commencement_time: null,\n      modified_at: 1733992154701,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 29,\n        created_at: 1717643358265,\n        name: 'Lê Thị Quỳnh',\n        user_uid: 'Ex08fb9c7',\n        email: 'lethiquynh.k60cnshc@gmail.com',\n        phone: '',\n      },\n      reports: [],\n      sample_prices: {\n        id: 3930,\n        created_at: 1732330570252,\n        sample_id: 3936,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      test_orders: [\n        {\n          id: 27194,\n          created_at: 1732331022190,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,0014)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704943689,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27195,\n          created_at: 1732331043382,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,012)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704961565,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27168,\n          created_at: 1732330758627,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (LOD:10)</p>',\n          result_unit: '<p>CFU/g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27187,\n          created_at: 1732330985411,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '<p>&lt;LOQ (LOQ: 0,1)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704927415,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27188,\n          created_at: 1732330999337,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,018)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704938733,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27174,\n          created_at: 1732330811914,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Staphylococci (+) coagulase',\n          test_name_secondary: '',\n          lib_test_id: 781,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 19,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (LOD:10)</p>',\n          result_unit: '<p>CFU/g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 19,\n            created_at: 1691815958050,\n            name: 'Định lượng Staphylococci có phản ứng dương tính coagulase (S. aureus và các loài khác) trên đĩa thạch trong thực phẩm, thức ăn chăn nuôi',\n            code: 'TCVN 4830-1:2005 (ISO 6888-1:1999; AMD 1:2003)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27186,\n          created_at: 1732330967048,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (eLOD<sub>50</sub>:5)</p>',\n          result_unit: '<p>CFU/25g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27180,\n          created_at: 1732330919912,\n          sample_receipt_id: 1322,\n          sample_id: 3936,\n          test_name: 'Listeria monocytogenes',\n          test_name_secondary: '',\n          lib_test_id: 61,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 997,\n          vlas: false,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '<p>KPH (eLOD<sub>50</sub>:5)</p>',\n          result_unit: '<p>CFU/25g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 997,\n            created_at: 1721883537337,\n            name: 'Listeria monocytogenes',\n            code: 'TCVN 7700-1:2007',\n            name_secondary: '',\n            vlas: false,\n            modified_by: 23,\n            accreditation_source: 'IRDOP',\n          },\n        },\n      ],\n    },\n    {\n      id: 3937,\n      created_at: 1732331320025,\n      sample_uid: 'SP.244823-17',\n      sample_name: 'Thực phẩm bổ sung Venus Canxi',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 29,\n      commencement_time: null,\n      modified_at: 1733992163408,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 29,\n        created_at: 1717643358265,\n        name: 'Lê Thị Quỳnh',\n        user_uid: 'Ex08fb9c7',\n        email: 'lethiquynh.k60cnshc@gmail.com',\n        phone: '',\n      },\n      reports: [],\n      sample_prices: {\n        id: 3931,\n        created_at: 1732331320120,\n        sample_id: 3937,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      test_orders: [\n        {\n          id: 27288,\n          created_at: 1732335044647,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,018)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704902133,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27290,\n          created_at: 1732335044729,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,012)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704915925,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27289,\n          created_at: 1732335044653,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,0014)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704906740,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27283,\n          created_at: 1732335044526,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (LOD:10)</p>',\n          result_unit: '<p>CFU/g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27287,\n          created_at: 1732335044640,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '<p>&lt;LOQ (LOQ: 0,1)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704893292,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27286,\n          created_at: 1732335044632,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (eLOD<sub>50</sub>:5)</p>',\n          result_unit: '<p>CFU/25g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27284,\n          created_at: 1732335044536,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Staphylococci (+) coagulase',\n          test_name_secondary: '',\n          lib_test_id: 781,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 19,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (LOD:10)</p>',\n          result_unit: '<p>CFU/g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 19,\n            created_at: 1691815958050,\n            name: 'Định lượng Staphylococci có phản ứng dương tính coagulase (S. aureus và các loài khác) trên đĩa thạch trong thực phẩm, thức ăn chăn nuôi',\n            code: 'TCVN 4830-1:2005 (ISO 6888-1:1999; AMD 1:2003)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27285,\n          created_at: 1732335044623,\n          sample_receipt_id: 1322,\n          sample_id: 3937,\n          test_name: 'Listeria monocytogenes',\n          test_name_secondary: '',\n          lib_test_id: 61,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 997,\n          vlas: false,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '<p>KPH (eLOD<sub>50</sub>:5)</p>',\n          result_unit: '<p>CFU/25g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 997,\n            created_at: 1721883537337,\n            name: 'Listeria monocytogenes',\n            code: 'TCVN 7700-1:2007',\n            name_secondary: '',\n            vlas: false,\n            modified_by: 23,\n            accreditation_source: 'IRDOP',\n          },\n        },\n      ],\n    },\n    {\n      id: 3938,\n      created_at: 1732332208386,\n      sample_uid: 'SP.244823-18',\n      sample_name: 'Thực phẩm bổ sung Venus Curcumin',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 28,\n      commencement_time: null,\n      modified_at: 1733996728222,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 28,\n        created_at: 1715825164244,\n        name: 'Đỗ Thị Dung',\n        user_uid: 'Ex9a920f9',\n        email: 'Dothuydung752002@gmail.com',\n        phone: '0383770345',\n      },\n      reports: [],\n      sample_prices: {\n        id: 3932,\n        created_at: 1732332208427,\n        sample_id: 3938,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      test_orders: [\n        {\n          id: 27307,\n          created_at: 1732335200827,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,0014)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704767382,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27305,\n          created_at: 1732335200719,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '<p>&lt;LOQ (LOQ: 0,1)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704748037,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27308,\n          created_at: 1732335200913,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,012)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704783056,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27302,\n          created_at: 1732335200413,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Staphylococci (+) coagulase',\n          test_name_secondary: '',\n          lib_test_id: 781,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 19,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (LOD:10)</p>',\n          result_unit: '<p>CFU/g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 19,\n            created_at: 1691815958050,\n            name: 'Định lượng Staphylococci có phản ứng dương tính coagulase (S. aureus và các loài khác) trên đĩa thạch trong thực phẩm, thức ăn chăn nuôi',\n            code: 'TCVN 4830-1:2005 (ISO 6888-1:1999; AMD 1:2003)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27304,\n          created_at: 1732335200624,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (eLOD<sub>50</sub>:5)</p>',\n          result_unit: '<p>CFU/25g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27303,\n          created_at: 1732335200520,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Listeria monocytogenes',\n          test_name_secondary: '',\n          lib_test_id: 61,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 997,\n          vlas: false,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '<p>KPH (eLOD<sub>50</sub>:5)</p>',\n          result_unit: '<p>CFU/25g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 997,\n            created_at: 1721883537337,\n            name: 'Listeria monocytogenes',\n            code: 'TCVN 7700-1:2007',\n            name_secondary: '',\n            vlas: false,\n            modified_by: 23,\n            accreditation_source: 'IRDOP',\n          },\n        },\n        {\n          id: 27306,\n          created_at: 1732335200815,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,018)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704757105,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27301,\n          created_at: 1732335200223,\n          sample_receipt_id: 1322,\n          sample_id: 3938,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (LOD:10)</p>',\n          result_unit: '<p>CFU/g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n      ],\n    },\n    {\n      id: 3939,\n      created_at: 1732332212001,\n      sample_uid: 'SP.244823-19',\n      sample_name:\n        'Sản phẩm dinh dưỡng công thức với mục đích ăn bổ sung dành cho trẻ từ 1-10 tuổi SNOW GROW EQ',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 28,\n      commencement_time: null,\n      modified_at: 1733996805823,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 28,\n        created_at: 1715825164244,\n        name: 'Đỗ Thị Dung',\n        user_uid: 'Ex9a920f9',\n        email: 'Dothuydung752002@gmail.com',\n        phone: '0383770345',\n      },\n      reports: [],\n      sample_prices: {\n        id: 3933,\n        created_at: 1732332212010,\n        sample_id: 3939,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      test_orders: [\n        {\n          id: 27339,\n          created_at: 1732335801939,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,012)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704881364,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27336,\n          created_at: 1732335801916,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '<p>&lt;LOQ (LOQ: 0,1)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704851822,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27337,\n          created_at: 1732335801924,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,018)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704861176,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27334,\n          created_at: 1732335801835,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (LOD:10)</p>',\n          result_unit: '<p>CFU/g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27338,\n          created_at: 1732335801931,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,0014)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704872081,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27335,\n          created_at: 1732335801846,\n          sample_receipt_id: 1322,\n          sample_id: 3939,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (eLOD<sub>50</sub>:5)</p>',\n          result_unit: '<p>CFU/25g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n      ],\n    },\n    {\n      id: 3940,\n      created_at: 1732332215468,\n      sample_uid: 'SP.244823-20',\n      sample_name:\n        'Sản phẩm dinh dưỡng công thức với mục đích ăn bổ sung dành cho trẻ từ 1-10 tuổi SNOW PEDIA GOLD',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 28,\n      commencement_time: null,\n      modified_at: 1733997761413,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 28,\n        created_at: 1715825164244,\n        name: 'Đỗ Thị Dung',\n        user_uid: 'Ex9a920f9',\n        email: 'Dothuydung752002@gmail.com',\n        phone: '0383770345',\n      },\n      reports: [],\n      sample_prices: {\n        id: 3934,\n        created_at: 1732332215481,\n        sample_id: 3940,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      test_orders: [\n        {\n          id: 27381,\n          created_at: 1732336080417,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,012)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704833048,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27378,\n          created_at: 1732336080119,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '<p>&lt;LOQ (LOQ: 0,1)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704700233,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27379,\n          created_at: 1732336080214,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,018)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704713838,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27380,\n          created_at: 1732336080319,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,0014)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704724670,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27377,\n          created_at: 1732336080023,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (eLOD<sub>50</sub>:5)</p>',\n          result_unit: '<p>CFU/25g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27376,\n          created_at: 1732336079913,\n          sample_receipt_id: 1322,\n          sample_id: 3940,\n          test_name: 'Enterobacteriaceae',\n          test_name_secondary: '',\n          lib_test_id: 18,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (LOD:10)</p>',\n          result_unit: '<p>CFU/g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n      ],\n    },\n    {\n      id: 3941,\n      created_at: 1732332224722,\n      sample_uid: 'SP.244823-21',\n      sample_name:\n        'Sản phẩm dinh dưỡng công thức dành cho trẻ từ 0-12 tháng tuổi Snow Clostrum',\n      sample_receipt_id: 1322,\n      sample_name_secondary: '',\n      sample_lot: '',\n      sample_mfr:\n        'Nhà máy sản xuất Công ty cổ phần Tập đoàn dinh dưỡng MRIK - Chi nhánh Hòa Bình. Địa chỉ: Thôn Cố Thổ, Xã Hòa Sơn, Huyện Lương Sơn, Tỉnh Hòa Bình, Việt Nam',\n      sample_qty: '1',\n      sample_seal: '',\n      sample_desc:\n        'Sản phẩm dạng bột, đựng trong hộp 900g, nhãn ghi đầy đủ thông tin',\n      note: '',\n      sample_category: 'TPBVSK/TPCN',\n      secondary_language: false,\n      test_purpose: 'chất lượng',\n      status: '1',\n      created_by_id: 28,\n      commencement_time: null,\n      modified_at: 1733997899143,\n      modified_by_id: 28,\n      ppt_copies: 0,\n      deleted: false,\n      sample_deadline: null,\n      created_by: {\n        id: 28,\n        created_at: 1715825164244,\n        name: 'Đỗ Thị Dung',\n        user_uid: 'Ex9a920f9',\n        email: 'Dothuydung752002@gmail.com',\n        phone: '0383770345',\n      },\n      reports: [],\n      sample_prices: {\n        id: 3935,\n        created_at: 1732332224739,\n        sample_id: 3941,\n        sample_receipt_id: 1322,\n        gross: 200000,\n        premium: 0,\n        premium_rate: 0,\n        discount: 0,\n        discount_rate: 0,\n        net: 200000,\n      },\n      test_orders: [\n        {\n          id: 27391,\n          created_at: 1732338392828,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Enterobacter sakazakii',\n          test_name_secondary: '',\n          lib_test_id: 966,\n          std_ref: '',\n          fee: 200000,\n          protocol_id: 509,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '<p>KPH (LOD:10)</p>',\n          result_unit: '<p>CFU/g</p>',\n          protocol_value: 'TCVN 5518-2:2007',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 509,\n            created_at: 1698114653782,\n            name: 'Enterobacteriaceae',\n            code: 'TCVN 5518-2:2007',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 0,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 31075,\n          created_at: 1733999576509,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Thiếc ( Sn)',\n          test_name_secondary: '',\n          lib_test_id: 60,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 690,\n          vlas: false,\n          outsourced: false,\n          protocol_source: 'IRDOP',\n          result_value: '',\n          result_unit: '',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-12-13',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 690,\n            created_at: 1705472644100,\n            name: 'Xác định hàm lượng Sắt (Fe), Đồng (Cu), Kẽm (Zn), Thiếc (Sn) bằng F-AAS',\n            code: 'TCVN 13090:2020',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27392,\n          created_at: 1732338392916,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Salmonella',\n          test_name_secondary: '',\n          lib_test_id: 1362,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 41,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>KPH (eLOD<sub>50</sub>:5)</p>',\n          result_unit: '<p>CFU/25g</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 3,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 0,\n          result_submitted_at: null,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 0,\n          assigned_to_dept: {\n            id: 3,\n            created_at: 1693192018303,\n            dept_name: 'IRDOP Vi sinh',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 41,\n            created_at: 1692670311836,\n            name: 'Phát hiện, định lượng và xác định typ huyết thanh của salmonella',\n            code: 'TCVN 10780-1:2017 (ISO 6579-1:2017)',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 5,\n            accreditation_source: 'IRDOP VS',\n          },\n        },\n        {\n          id: 27394,\n          created_at: 1732338393114,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Chì (Pb)',\n          test_name_secondary: '',\n          lib_test_id: 1283,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1018,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,018)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704659379,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1018,\n            created_at: 1723706438065,\n            name: 'Chì (Pb)',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 34,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27395,\n          created_at: 1732338393219,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Cadmi (Cd)',\n          test_name_secondary: '',\n          lib_test_id: 826,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 1007,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,0014)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704672339,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 1007,\n            created_at: 1723195336152,\n            name: 'cadimi',\n            code: 'TCVN 8126:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n        {\n          id: 27396,\n          created_at: 1732338393327,\n          sample_receipt_id: 1322,\n          sample_id: 3941,\n          test_name: 'Thủy Ngân (Hg)',\n          test_name_secondary: 'Mercury',\n          lib_test_id: 48,\n          std_ref: '',\n          fee: 0,\n          protocol_id: 304,\n          vlas: true,\n          outsourced: false,\n          protocol_source: 'IRDOP VS',\n          result_value: '<p>&lt;LOQ (LOQ: 0,012)</p>',\n          result_unit: '<p>mg/kg</p>',\n          protocol_value: '',\n          assigned_to_dept_id: 1,\n          assigned_to_user_id: 0,\n          result_submitted_by_id: 34,\n          result_submitted_at: 1732704808660,\n          result_deadline: '2024-11-27',\n          result_note: '',\n          deleted: false,\n          tested_by_user_id: 34,\n          assigned_to_dept: {\n            id: 1,\n            created_at: 1693191981510,\n            dept_name: 'IRDOP Hoá lý 1',\n            lab_id: 1,\n            is_lab: true,\n            priority: -1,\n            lab: {\n              id: 1,\n              created_at: 1689677306626,\n              lab_name: 'Viện nghiên cứu và phát triển Sản phẩm thiên nhiên',\n              code: 'IRDOP HQ',\n              address: '176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội',\n            },\n          },\n          protocol: {\n            id: 304,\n            created_at: 1695622702006,\n            name: 'Hàm lượng thuỷ ngân (Hg)',\n            code: 'TCVN 7993:2009',\n            name_secondary: '',\n            vlas: true,\n            modified_by: 30,\n            accreditation_source: 'IRDOP VS',\n          },\n          result_submitted_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n          tested_by: {\n            id: 34,\n            created_at: 1719885632156,\n            name: 'Trần Thị Lan',\n            user_uid: 'Exaf24de21',\n            email: 'tranlan.irdop@gmail.com',\n            phone: '',\n          },\n        },\n      ],\n    },\n  ],\n};\n\nfunction sortDataById(data) {\n    // Nếu data là mảng, sắp xếp từng phần tử trong mảng\n    if (Array.isArray(data)) {\n        return data\n            .map(item => sortDataById(item)) // Đệ quy sắp xếp các phần tử\n            .sort((a, b) => (a.id || 0) - (b.id || 0)); // Sắp xếp theo id\n    }\n    // Nếu data là object\n    else if (data && typeof data === 'object') {\n        const sortedData = {};\n        for (const key in data) {\n            if (key === 'test_orders') {\n                // Sắp xếp test_orders nếu là mảng\n                sortedData[key] = sortDataById(data[key]);\n            } else {\n                // Đệ quy xử lý các phần tử con\n                sortedData[key] = sortDataById(data[key]);\n            }\n        }\n        return sortedData;\n    }\n    // Nếu không phải object hoặc mảng, trả về chính nó\n    return data;\n}\n\n\n\n\nfunction logDifferentKeys(obj1, obj2, path = '') {\n  \n   obj1 = sortDataById(obj1);\n   obj2 = sortDataById(obj2);\n\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  // Gọi hàm và in kết quả\n\n  // Hợp tất cả key từ hai object\n  const allKeys = new Set([...keys1, ...keys2]);\n\n  for (let key of allKeys) {\n    const currentPath = path ? `${path}.${key}` : key;\n\n    // Key chỉ có trong obj1\n    if (!keys2.includes(key)) {\n      node.warn(`Key chỉ có trong obj1: ${currentPath}`);\n    }\n    // Key chỉ có trong obj2\n    else if (!keys1.includes(key)) {\n      node.warn(`Key chỉ có trong obj2: ${currentPath}`);\n    }\n    // Đệ quy nếu là nested object\n    else if (\n      typeof obj1[key] === 'object' &&\n      obj1[key] !== null &&\n      typeof obj2[key] === 'object' &&\n      obj2[key] !== null\n    ) {\n      logDifferentKeys(obj1[key], obj2[key], currentPath);\n    }\n  }\n}\n\nnode.warn('Các key khác nhau:');\nlogDifferentKeys(obj1, obj2);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "cc6e58db25d846b4",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 340,
        "y": 620,
        "wires": [
            [
                "f8a37dafbc5c88e3"
            ]
        ]
    },
    {
        "id": "f8a37dafbc5c88e3",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "logCache",
        "func": "const cache = global.get('cache')\n\nnode.warn({cache});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "8581e0bf5418d81b",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 340,
        "y": 660,
        "wires": [
            [
                "18d742b0717d8fec"
            ]
        ]
    },
    {
        "id": "18d742b0717d8fec",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "log Tables Class",
        "func": "const tables = global.get('tables')\nconst Receipt = tables.Receipt;\nnode.warn(Receipt);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "79307cda6c23bd82",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 340,
        "y": 700,
        "wires": [
            [
                "96a74e40d7fa47e9"
            ]
        ]
    },
    {
        "id": "96a74e40d7fa47e9",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "function 8",
        "func": "\nconst getTestOrder = (json) => {\n    // Map each sample to its test_orders array\n    const list = json.map(sample => sample.test_orders);\n    \n    let listTestOrder = [];\n    \n    // Iterate over each test_orders array\n    list.forEach(t_o => {\n        // Iterate over each test_order in the test_orders array\n        for (const test_order of t_o) {\n            // Push each test_order to the listTestOrder array\n            listTestOrder.push(test_order);\n        }\n    });\n    \n    // Return the flattened list of test orders\n    return listTestOrder;\n}\nconst json1 = global.get('cache').processingSamples['eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwiemlwIjoiREVGIn0.bMKMpnJLJriYYaOAiGfpLwbAV7Luz9MWza0W3P--lEeJ1UDP-ZWKYs68do90qkgUIyZ4WpbiK8QDcMFo0MMgXYHatjM-TEYG._ZGWIz_7K7SmMfVPgfqBUQ.YJ4yxWYdYhWpTV7PplwAx55nLYmuAlpqTVBdR5Uz8JHFLUBurvCb4E3n6EqwjblALFqIbR-FRydfGUFHBHXvvK0onSiFg_o0naGg7uWdSSLlXzOR9np_pyrN0eYtFMo0RFy6omewFGny0g7rRKhCC5Y1XoKCU4U-_HtbGNWyUGYKx3mjQOchZmuUuYs76ls5tIUoerj6z9VGuqWkPWRa4UMGn7CqBucJSDkAllOGPDAX9LO9Mu1FO379pnwiZ3R4t19kzwKP8DB2p6RH9qXX5-hP0MHQh4lPy-dN1RUGqWWfo6EhlQyuOooxFkV87rSAPDMPWz1EH7MZgTsIYh9w4YXVvwtVfBCU2eFU6xBGZXOq9m26NOEdu-Y4BezDMrDdtq3JDzm5YEtPwNP2Yvw5nc-Uim2W4ZkQXfUcy9sEeNZ5fOWUr7E4Q2e871YNOoz6KSHCGH4KY1hdsOCbqwnHJw.fUECuhOC87-2aX5PKnqwKswpCWoUoLrbM9We21Q75TI'].value.samples;\nnode.warn(json1);\nconst t_o = getTestOrder(json1);\nnode.warn(t_o)",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 700,
        "wires": [
            []
        ]
    },
    {
        "id": "35428fc4a84fd3d7",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "Restart AI",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 360,
        "y": 180,
        "wires": [
            [
                "b58595f09d34fcaa"
            ]
        ]
    },
    {
        "id": "b58595f09d34fcaa",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "ai router",
        "func": "// OpenAI\nconst oai = global.get('oai') || {}; // function helpers (oai.call, oai.extractJSON, oai.extractResponse)\nglobal.set('oai', oai);\nconst axios = global.get('axios');\nconst cache = global.get('cache');\nconst lab_batch_helpers = global.get('lab_batch_helpers');\n\n// Initialize OpenAI API\nconst openai_api = await initOpenAI(); // OpenAI API\nglobal.set('openai_api', openai_api);\n\nasync function initOpenAI() {\n\ttry {\n\t\tconst OpenAI = global.get('openai');\n\t\tconst oai_api = new OpenAI({ apiKey: env.get('OPENAI_API_KEY') });\n\t\tif (oai_api) {\n\t\t\tnode.warn('[   OK   ] OpenAI initialized');\n\t\t\treturn oai_api;\n\t\t} else throw new Error('[ FAILED ] OpenAI Initialization failed');\n\t} catch (error) {\n\t\tnode.warn('[ FAILED ] OpenAI Initialization failed: ' + error.message);\n\t\tnode.warn(error.stack);\n\t\tnode.status({ fill: 'red', shape: 'dot', text: 'FAILED' });\n\t\treturn null;\n\t}\n}\n\n// OpenAI quick call\noai.call = async (request, rethrow = false) => {\n\tconst DEFAULT_MODEL = 'gpt-4o';\n\tconst FAST_MODEL = 'gpt-4o-mini';\n\tconst GOOD_MODEL = 'o1';\n\ttry {\n\t\tlet validated_request = {};\n\t\tif (typeof request === 'string') {\n\t\t\tvalidated_request.messages = [{ role: 'user', content: request }];\n\t\t\tvalidated_request.model = DEFAULT_MODEL;\n\t\t} else {\n\t\t\t// model\n\t\t\tswitch (request.model) {\n\t\t\t\tcase 'fast':\n\t\t\t\t\tvalidated_request.model = FAST_MODEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'good':\n\t\t\t\t\tvalidated_request.model = GOOD_MODEL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvalidated_request.model = DEFAULT_MODEL;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// messages\n\t\t\tif (typeof request.prompt === 'string') validated_request.messages = [{ role: 'user', content: request.prompt }];\n\t\t\telse if (typeof request.messages === 'string')\n\t\t\t\tvalidated_request.messages = [{ role: 'user', content: request.messages }];\n\t\t\telse if (typeof request.messages === 'object') validated_request.messages = request.messages;\n\t\t\telse throw new Error('[ FAILED ] Invalid messages');\n\n\t\t\t// temperature\n\t\t\tif (typeof request.temperature === 'number') validated_request.temperature = request.temperature;\n\t\t\telse validated_request.temperature = 0.2;\n\n\t\t\t// max_tokens\n\t\t\tif (typeof request.max_tokens === 'number') validated_request.max_tokens = request.max_tokens;\n\t\t}\n\n\t\tconst response = await openai_api.chat.completions.create(validated_request);\n\t\t\n\t\tconst extract_content = await oai.extractContent(response);\n\t\t\n\t\treturn oai.extractJSON(extract_content);\n\t} catch (error) {\n\t\tif (rethrow) throw error;\n\t\telse node.warn('[ FAILED ] OpenAI call failed');\n\t\tnode.warn(error.stack);\n\t\treturn null;\n\t}\n};\n\noai.extractJSON = (response) => {\n    // Match the content between triple backticks (```...```)\n\tconst match = response.match(/```json\\s*([\\s\\S]*?)```/); // Dấu `[\\s\\S]*?` đảm bảo khớp mọi ký tự giữa hai dấu ```.\n    const cleanedResponse = match ? match[1] : '{}'; // Extract the first match group or default to '{}'\n\n    try {\n        const obj_response = JSON.parse(cleanedResponse);\n        return obj_response;\n    } catch (error) {\n        node.warn('Error parsing JSON response: ' + error.message);\n        node.warn(error.stack);\n        return {};\n    }\n};\n\n\noai.extractContent = async (response) => {\n\tconst content = response?.choices?.[0]?.message?.content;\n\tif (!content) {\n\t\tthrow new Error('Cannot extract content from response');\n\t}\n\treturn content;\n};\n\noai.getListAssistants = async () => {\n\tconst myAssistants = await openai_api.beta.assistants.list({\n\t\torder: \"desc\",\n\t\tlimit: \"20\",\n\t});\n\treturn myAssistants.data;\n}\n\noai.deleteAssistant = async (listAst) => {\n\tfor (const ast of listAst) {\n\t\ttry {\n\t\t\tconst response = await openai_api.beta.assistants.del(ast.id);\n\t\t\tnode.warn(`Delete ast: ${ast.id}`)\n\t\t} catch (error) {\n\t\t\tnode.warn(`error: ${error}`)\n\t\t};\n\t};\n}\n\noai.deleteThread = async (listThr) => {\n\tfor (const id of listThr) {\n\t\ttry {\n\t\t\tconst response = await openai_api.beta.threads.del(id);\n\t\t\tnode.warn(`Delete thread: ${id}`)\n\t\t} catch (error) {\n\t\t\tnode.warn(`error: ${error}`)\n\t\t};\n\t};\n}\n\n// oai.getListFiles = async () => {\n// \tnode.warn(\"Get list file\");\n// \tconst list = await openai_api.listFiles();\n// \tnode.warn({list});\n//  \t// for await (const file of list) {\n//     // \tnode.warn(file);\n//   \t// }\t\n// \treturn list.data;\n// }\n\noai.deleteFile = async (listFiles) => {\n\tfor (const file of listFiles) {\n\t\ttry {\n\t\t\tconst res = await openai_api.files.del(file.file_id);\n\t\t\tnode.warn(`Delete file: ${file.file_id}`)\n\t\t} catch (error) {\n\t\t\tnode.warn(`error: ${error}`)\n\t\t};\n\t};\n}\n\n\n\n// URL của file\nconst url1 = 'https://support.staffbase.com/hc/en-us/article_attachments/360009197031/username.csv';\nconst url2 = 'https://filesamples.com/samples/document/docx/sample2.docx';\n\n// Hàm tải file từ URL dưới dạng stream và lưu vào ổ đĩa\nasync function downloadFileStream(url) {\n\ttry {\n\t\tconst response = await axios({ method: 'GET', url: url, responseType: 'stream' });\n\n\t\tconst savePath = 'doc1.docx';\n\n\t\t// Tạo một stream ghi để lưu file vào đường dẫn savePath\n\t\tconst writer = fs.createWriteStream(savePath);\n\n\t\t// Dùng pipe để tải file và ghi vào ổ đĩa\n\t\tresponse.data.pipe(writer);\n\n\t\t// Chờ cho đến khi file được tải và lưu xong\n\t\treturn new Promise((resolve, reject) => {\n\t\t\twriter.on('finish', () => {\n\t\t\t\tnode.warn(`File đã tải và lưu tại: ${savePath}`);\n\t\t\t\tresolve(savePath);\n\t\t\t});\n\t\t\twriter.on('error', (err) => {\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t} catch (error) {\n\t\tnode.warn('Lỗi khi tải file từ URL:' + error);\n\t\tthrow error;\n\t}\n}\n\n// Hàm upload file từ stream lên OpenAI API\nasync function uploadFile(filePath) {\n\tconst fileStream = fs.createReadStream(filePath);\n\n\ttry {\n\t\tconst file = await openai_api.files.create({\n\t\t\tfile: fileStream,\n\t\t\tpurpose: 'assistants', // Đảm bảo rằng bạn sử dụng mục đích hợp lệ\n\t\t});\n\t\t// node.warn('File tải lên thành công:');\n\t\t// node.warn(file);\n\t\treturn file.id;\n\t} catch (error) {\n\t\tnode.warn('Lỗi khi tải file lên OpenAI:' + error);\n\t}\n}\nasync function deleteMessages(threadId) {\n\ttry {\n\t\tconst messages = await openai_api.beta.threads.messages.list(threadId);\n\t\tfor (const message of messages.data) {\n\t\t\tawait openai_api.beta.threads.messages.del(threadId, message.id);\n\t\t}\n\t\t// node.warn(`All messages in thread deleted.`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting messages: ${error}`);\n\t}\n}\n\nasync function deleteThread(threadId) {\n\ttry {\n\t\tawait openai_api.beta.threads.del(threadId);\n\t\t// node.warn(`Thread deleted: ${threadId}`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting thread: ${error}`);\n\t}\n}\n\nasync function deleteAssistant(assistantId) {\n\ttry {\n\t\tawait openai_api.beta.assistants.del(assistantId);\n\t\t// node.warn(`Assistant deleted: ${assistantId}`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting assistant: ${error}`);\n\t}\n}\n\nasync function deleteFilesFromVectorStore(vectorStoreId) {\n\ttry {\n\t\tconst files = await openai_api.beta.vectorStores.files.list(vectorStoreId);\n\t\tfor (const file of files.data) {\n\t\t\tawait openai_api.beta.vectorStores.files.del(vectorStoreId, file.id);\n\t\t}\n\t\t// node.warn(`All files in vector store deleted.`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting files from vector store: ${error}`);\n\t}\n}\n\nasync function deleteVectorStore(vectorStoreId) {\n\ttry {\n\t\tawait openai_api.beta.vectorStores.del(vectorStoreId);\n\t\t// node.warn(`Vector Store deleted: ${vectorStoreId}`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting vector store: ${error}`);\n\t}\n}\n\nasync function cleanupResources(assistantId, threadId, vectorStoreId) {\n\tawait deleteMessages(threadId);\n\tawait deleteThread(threadId);\n\tawait deleteAssistant(assistantId);\n\tawait deleteFilesFromVectorStore(vectorStoreId);\n\tawait deleteVectorStore(vectorStoreId);\n\tnode.warn(`Cleanup completed.`);\n}\n\nasync function checkRunStatus(threadId, runId) {\n\ttry {\n\t\tlet run;\n\t\tdo {\n\t\t\trun = await openai_api.beta.threads.runs.retrieve(threadId, runId);\n\t\t\tnode.warn(`Thread id: ${threadId}\\n Run id: ${runId}\\n Status: ${run.status}`);\n\t\t\tif (run.status === 'completed' || run.status === 'failed') break;\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, 5000)); // Poll every 5 seconds\n\t\t} while (true);\n\t\tnode.warn({ run });\n\n\t\t// return result\t\t\n\t\tconst result = await openai_api.beta.threads.messages.list(threadId);\n\t\tnode.warn({ result });\n\n\t\treturn result.data[0].content[0].text.value;\n\t} catch (error) {\n\t\tnode.warn('Error checking run status:' + error);\n\t}\n}\n\noai.readDocxFile = async (pathOrURL, prompt, chat_context_id) => {\n\t/**\n\t * 1. Download file from URL\n\t * 2. Upload file to OpenAI\n\t * 3. Create vector store\n\t * 4. Add file to vector store\n\t * 5. Create assistant\n\t * 6. Create thread and message\n\t * 7. Run thread\n\t * 8. Check run status: completed -> get, failed -> wait 5s\n\t * 9. Cleanup resources\n\t * 10. Return result\n\t */\n\ttry {\n\t\t// Download file from URL\n\t\t// const filePath = await downloadFileStream(pathOrURL);\n\n\t\t// Upload file to OpenAI\n\t\tconst fileId = await uploadFile(pathOrURL);\n\t\tnode.warn(fileId);\n\n\t\t// // Create vector store\n\t\t// const vectorStore = await openai_api.beta.vectorStores.create({\n\t\t// \tname: 'listFiles',\n\t\t// });\n\n\t\t// // Add file to vector store\n\t\t// await openai_api.beta.vectorStores.files.create(vectorStore.id, {\n\t\t// \tfile_id: fileId,\n\t\t// });\n\n\t\t// // Create assistant\n\t\t// const assistant = await openai_api.beta.assistants.create({\n\t\t// \tname: 'test',\n\t\t// \tinstructions:\n\t\t// \t\t'You are a helpful product support assistant and you answer questions based on the files provided to you.',\n\t\t// \tmodel: 'gpt-4o',\n\t\t// \ttools: [{ type: 'file_search' }],\n\t\t// \ttool_resources: {\n\t\t// \t\tfile_search: {\n\t\t// \t\t\tvector_store_ids: [vectorStore.id],\n\t\t// \t\t},\n\t\t// \t},\n\t\t// });\n\n\t\t// // Create thread and message\n\t\t// const thread = await openai_api.beta.threads.create();\n\t\t// const message = await openai_api.beta.threads.messages.create(thread.id, {\n\t\t// \trole: 'user',\n\t\t// \tcontent: prompt,\n\t\t// });\n\n\t\t// // Run thread\n\t\t// const run = await openai_api.beta.threads.runs.create(thread.id, {\n\t\t// \tassistant_id: assistant.id,\n\t\t// });\n\n\t\t// // Check run status\n\t\t// const result = await checkRunStatus(thread.id, run.id);\n\n\t\t// // create new cache\n\t\t// const asistant_purpose = 'submit result';\n\t\t// const openai_obj = {\n\t\t// \tthread_id: thread.id,\n\t\t// \tassistant_id: assistant.id,\n\t\t// \tvector_store_id: vectorStore.id,\n\t\t// \tmessages: [\n\t\t// \t\t{\n\t\t// \t\t\trun_id: run.id,\n\t\t// \t\t\tuser_request: 'Read lab report file and return list analyte results ',\n\t\t// \t\t\topenai_response: result\n\t\t// \t\t}\n\t\t// \t]\n\t\t// }\n\t\t// cache.new_chat_context(chat_context_id, openai_obj, asistant_purpose);\n\n\t\t// return { result: result, thread_id: thread.id };\n\n\t} catch (error) {\n\t\tnode.warn('Error reading docx file:' + error);\n\t}\n};\n\noai.cleanupResources = async (assistantId, threadId, vectorStoreId) => {\n\ttry {\n\t\tassistantId = assistantId || cache.openai.assistant_id;\n\t\tthreadId = threadId || cache.openai.thread_id;\n\t\tvectorStoreId = vectorStoreId || cache.openai.vectorStore_id;\n\t\tawait cleanupResources(assistantId, threadId, vectorStoreId);\n\t\tcache.openai = {};\n\n\t\tnode.warn(`Cleanup completed.`);\n\t} catch (error) {\n\t\tnode.warn('Error cleaning up resources:' + error);\n\t}\n};\n\n//\"Error with next request:TypeError: Cannot read properties of undefined (reading 'thread_id')\"\n\noai.nextRequest = async (prompt, chat_context_id, thread_id, request) => {\n\ttry {\n\t\tconst purpose = cache.chat_context[chat_context_id][thread_id].assistant_purpose;\n\n\t\tif (prompt === 'ok') {\n\t\t\tswitch (purpose) {\n\t\t\t\tcase \"submit result\":\n\t\t\t\t\t// call func submit result\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//lấy message cuối cùng trong cache\n\t\t\t\t\t\tconst last_message = cache.chat_context[chat_context_id][thread_id].openai.messages[cache.chat_context[chat_context_id][thread_id].openai.messages.length - 1];\n\t\t\t\t\t\t// const last_message = cache.chat_context[chat_context_id][thread_id].openai.messages[1];\n\t\t\t\t\t\tlet analyte_matches = last_message.openai_response;\n\t\t\t\t\t\tnode.warn(analyte_matches);\n\n\t\t\t\t\t\t// lấy chuỗi con bắt đầu từ kí tự '['  và kết thúc bằng kí tự ']' cuối cùng\n\t\t\t\t\t\tconst match = analyte_matches.match(/\\[(.*)\\]/s);\n\n\t\t\t\t\t\tconst cleanedResponse = match ? match[0] : '[]';\n\t\t\t\t\t\tanalyte_matches = JSON.parse(cleanedResponse);\n\n\t\t\t\t\t\t//set cache\n\t\t\t\t\t\tconst analyte_matches_obj = { analyte_matches: analyte_matches }\n\t\t\t\t\t\tnode.warn(analyte_matches_obj);\n\t\t\t\t\t\tcache.set_chat_context_result(chat_context_id, thread_id, analyte_matches_obj);\n\t\t\t\t\t\t// Lấy từ cache analyte_matches \n\t\t\t\t\t\tconst analyte_results = cache.chat_context[chat_context_id][thread_id].result.analyte_matches;\n\t\t\t\t\t\tconst setResult = await lab_batch_helpers.setAnalyteResults(analyte_results);\n\n\t\t\t\t\t\tconst new_response = {\n\t\t\t\t\t\t\tuser_request: request || prompt,\n\t\t\t\t\t\t\topenai_response: \"Submit results successfull!\"\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcache.set_chat_context(chat_context_id, thread_id, new_response);\n\n\t\t\t\t\t\treturn setResult;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tnode.warn(\"error\");\n\t\t\t\t\t\tconst new_response = {\n\t\t\t\t\t\t\tuser_request: request || prompt,\n\t\t\t\t\t\t\topenai_response: \"Submit results failed!\"\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcache.set_chat_context(chat_context_id, thread_id, new_response);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\n\t\t\t}\n\t\t}\n\n\t\t// fix prompt \n\n\t\tconst message = await openai_api.beta.threads.messages.create(thread_id, {\n\t\t\trole: 'user',\n\t\t\tcontent: prompt,\n\t\t});\n\n\t\tconst run = await openai_api.beta.threads.runs.create(thread_id, {\n\t\t\tassistant_id: cache.chat_context[chat_context_id][thread_id].openai.assistant_id,\n\t\t});\n\n\t\tconst result = await checkRunStatus(thread_id, run.id);\n\n\t\tconst new_response = {\n\t\t\trun_id: run.id,\n\t\t\tuser_request: request || prompt,\n\t\t\topenai_response: result\n\t\t};\n\n\t\tcache.set_chat_context(chat_context_id, thread_id, new_response);\n\n\t\treturn result;\n\t} catch (error) {\n\t\tnode.warn('Error with next request:' + error);\n\t}\n};\n\noai.checkRunStatus = async (thread_id, run_id) => {\n\ttry {\n\t\tconst result = await checkRunStatus(thread_id, run_id);\n\t\treturn result;\n\t} catch (error) {\n\t\tnode.warn('Error checking run status:' + error);\n\t}\n}\n\noai.getListFiles = async (vector_store_id) => {\n\tconst vectorStoreFiles = await openai_api.beta.vectorStores.files.list(\n\t\tvector_store_id\n\t);\n\treturn vectorStoreFiles;\n}\n\noai.addAttachmentMessage = async (prompt, chat_context_id, thread_id, file_id) => {\n\ttry {\n\t\tconst message = await openai_api.beta.threads.messages.create(thread_id, {\n\t\t\trole: 'user',\n\t\t\tcontent: prompt,\n\t\t\tattachments: [\n\t\t\t\t{\n\t\t\t\t\tfile_id: file_id,\n\t\t\t\t\ttools: [\n\t\t\t\t\t\t{ type: 'file_search' } // expected object instead of just a string\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t});\n\n\t\tconst run = await openai_api.beta.threads.runs.create(thread_id, {\n\t\t\tassistant_id: \"asst_4WstFI2tc1NVD4a8GeA8851J\"\n\t\t});\n\t\tnode.warn({ run });\n\n\t\tconst result = await checkRunStatus(thread_id, run.id);\n\t\tnode.warn({ result });\n\n\t\tconst new_response = {\n\t\t\trun_id: run.id,\n\t\t\tuser_request: prompt,\n\t\t\topenai_response: result\n\t\t};\n\n\t\tnode.warn(new_response);\n\t\t// cache.set_chat_context(chat_context_id, thread_id, new_response);\n\n\t\treturn result;\n\t} catch (error) {\n\t\tnode.warn('Error adding attachment message:' + error);\n\t}\n}\n\n// const result = await oai.readDocxFile(url2, 'what is this?');\n// node.warn(`result: ${result}`);\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            }
        ],
        "x": 600,
        "y": 180,
        "wires": [
            [
                "1398d930cd2dd1d9"
            ]
        ]
    },
    {
        "id": "922c1ff33ef55e62",
        "type": "comment",
        "z": "5fb64aedc3e2bcf3",
        "name": "Server notes",
        "info": "docker irdopnodered: \n- npm install exceljs\n- Update node red setting: `exceljs: require('exceljs')`",
        "x": 130,
        "y": 500,
        "wires": []
    },
    {
        "id": "e506da91d640f33b",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 880,
        "y": 500,
        "wires": [
            [
                "ab030c68dcfc94db"
            ]
        ]
    },
    {
        "id": "ab030c68dcfc94db",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "testGenerateDocxToData",
        "func": "// OpenAI\nconst oai = global.get('oai') || {}; // function helpers (oai.call, oai.extractJSON, oai.extractResponse)\nglobal.set('oai', oai);\nconst axios = global.get('axios');\n\n// Initialize OpenAI API\nconst openai_api = await initOpenAI(); // OpenAI API\nglobal.set('openai_api', openai_api);\n\nasync function initOpenAI() {\n\ttry {\n\t\tconst OpenAI = global.get('openai');\n\t\tconst oai_api = new OpenAI({ apiKey: env.get('OPENAI_API_KEY') });\n\t\tif (oai_api) {\n\t\t\tnode.warn('[   OK   ] OpenAI initialized');\n\t\t\treturn oai_api;\n\t\t} else throw new Error('[ FAILED ] OpenAI Initialization failed');\n\t} catch (error) {\n\t\tnode.warn('[ FAILED ] OpenAI Initialization failed: ' + error.message);\n\t\tnode.warn(error.stack);\n\t\tnode.status({ fill: 'red', shape: 'dot', text: 'FAILED' });\n\t\treturn null;\n\t}\n}\n\n// OpenAI quick call\noai.call = async (request, rethrow = false) => {\n\tconst DEFAULT_MODEL = 'gpt-4o';\n\tconst FAST_MODEL = 'gpt-4o-mini';\n\tconst GOOD_MODEL = 'o1';\n\ttry {\n\t\tlet validated_request = {};\n\t\tif (typeof request === 'string') {\n\t\t\tvalidated_request.messages = [{ role: 'user', content: request }];\n\t\t\tvalidated_request.model = DEFAULT_MODEL;\n\t\t} else {\n\t\t\t// model\n\t\t\tswitch (request.model) {\n\t\t\t\tcase 'fast':\n\t\t\t\t\tvalidated_request.model = FAST_MODEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'good':\n\t\t\t\t\tvalidated_request.model = GOOD_MODEL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvalidated_request.model = DEFAULT_MODEL;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// messages\n\t\t\tif (typeof request.prompt === 'string') validated_request.messages = [{ role: 'user', content: request.prompt }];\n\t\t\telse if (typeof request.messages === 'string')\n\t\t\t\tvalidated_request.messages = [{ role: 'user', content: request.messages }];\n\t\t\telse if (typeof request.messages === 'object') validated_request.messages = request.messages;\n\t\t\telse throw new Error('[ FAILED ] Invalid messages');\n\n\t\t\t// temperature\n\t\t\tif (typeof request.temperature === 'number') validated_request.temperature = request.temperature;\n\t\t\telse validated_request.temperature = 0.2;\n\n\t\t\t// max_tokens\n\t\t\tif (typeof request.max_tokens === 'number') validated_request.max_tokens = request.max_tokens;\n\t\t}\n\n\t\tconst response = await openai_api.chat.completions.create(validated_request);\n\t\treturn oai.extractResponse(response);\n\t} catch (error) {\n\t\tif (rethrow) throw error;\n\t\telse node.warn('[ FAILED ] OpenAI call failed');\n\t\tnode.warn(error.stack);\n\t\treturn null;\n\t}\n};\n\noai.extractJSON = async (response) => {\n\treturn JSON.parse(oai.extractResponse(response));\n};\n\noai.extractResponse = async (response) => {\n\treturn response.choices[0].message.content;\n};\n\n// URL của file\nconst url1 = 'https://support.staffbase.com/hc/en-us/article_attachments/360009197031/username.csv';\nconst url2 = 'https://filesamples.com/samples/document/docx/sample2.docx';\n\n// Hàm tải file từ URL dưới dạng stream và lưu vào ổ đĩa\nasync function downloadFileStream(url) {\n\ttry {\n\t\tconst response = await axios({ method: 'GET', url: url, responseType: 'stream' });\n\n\t\t// const savePath = path.join('C:', 'Users', 'quang', '.node-red', 'files', 'csv1.csv'); // Dùng path.join để xây dựng đường dẫn\n\t\t// node.warn(savePath);\n\t\tconst savePath = 'doc1.docx';\n\n\t\t// Tạo một stream ghi để lưu file vào đường dẫn savePath\n\t\tconst writer = fs.createWriteStream(savePath);\n\n\t\t// Dùng pipe để tải file và ghi vào ổ đĩa\n\t\tresponse.data.pipe(writer);\n\n\t\t// Chờ cho đến khi file được tải và lưu xong\n\t\treturn new Promise((resolve, reject) => {\n\t\t\twriter.on('finish', () => {\n\t\t\t\tnode.warn(`File đã tải và lưu tại: ${savePath}`);\n\t\t\t\tresolve(savePath);\n\t\t\t});\n\t\t\twriter.on('error', (err) => {\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t} catch (error) {\n\t\tnode.warn('Lỗi khi tải file từ URL:' + error);\n\t\tthrow error;\n\t}\n}\n\n// Hàm upload file từ stream lên OpenAI API\nasync function uploadFile(filePath) {\n\tconst fileStream = fs.createReadStream(filePath);\n\n\ttry {\n\t\tconst file = await openai_api.files.create({\n\t\t\tfile: fileStream,\n\t\t\tpurpose: 'assistants', // Đảm bảo rằng bạn sử dụng mục đích hợp lệ\n\t\t});\n\t\tnode.warn('File tải lên thành công:');\n\t\tnode.warn(file);\n\t\treturn file.id;\n\t} catch (error) {\n\t\tnode.warn('Lỗi khi tải file lên OpenAI:' + error);\n\t}\n}\nasync function deleteMessages(threadId) {\n\ttry {\n\t\tconst messages = await openai_api.beta.threads.messages.list(threadId);\n\t\tfor (const message of messages.data) {\n\t\t\tawait openai_api.beta.threads.messages.del(threadId, message.id);\n\t\t}\n\t\tnode.warn(`All messages in thread deleted.`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting messages: ${error}`);\n\t}\n}\n\nasync function deleteThread(threadId) {\n\ttry {\n\t\tawait openai_api.beta.threads.del(threadId);\n\t\tnode.warn(`Thread deleted: ${threadId}`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting thread: ${error}`);\n\t}\n}\n\nasync function deleteAssistant(assistantId) {\n\ttry {\n\t\tawait openai_api.beta.assistants.del(assistantId);\n\t\tnode.warn(`Assistant deleted: ${assistantId}`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting assistant: ${error}`);\n\t}\n}\n\nasync function deleteFilesFromVectorStore(vectorStoreId) {\n\ttry {\n\t\tconst files = await openai_api.beta.vectorStores.files.list(vectorStoreId);\n\t\tfor (const file of files.data) {\n\t\t\tawait openai_api.beta.vectorStores.files.del(vectorStoreId, file.id);\n\t\t}\n\t\tnode.warn(`All files in vector store deleted.`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting files from vector store: ${error}`);\n\t}\n}\n\nasync function deleteVectorStore(vectorStoreId) {\n\ttry {\n\t\tawait openai_api.beta.vectorStores.del(vectorStoreId);\n\t\tnode.warn(`Vector Store deleted: ${vectorStoreId}`);\n\t} catch (error) {\n\t\tnode.warn(`Error deleting vector store: ${error}`);\n\t}\n}\n\nasync function cleanupResources(assistantId, threadId, vectorStoreId) {\n\tawait deleteMessages(threadId);\n\tawait deleteThread(threadId);\n\tawait deleteAssistant(assistantId);\n\tawait deleteFilesFromVectorStore(vectorStoreId);\n\tawait deleteVectorStore(vectorStoreId);\n\tnode.warn(`Cleanup completed.`);\n}\n\nasync function checkRunStatus(threadId, runId) {\n\ttry {\n\t\tlet run;\n\t\tdo {\n\t\t\trun = await openai_api.beta.threads.runs.retrieve(threadId, runId);\n\t\t\tnode.warn(`Thread id: ${threadId}\\n Run id: ${runId}\\n Status: ${run.status}`);\n\t\t\tif (run.status === 'completed' || run.status === 'failed') break;\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, 5000)); // Poll every 5 seconds\n\t\t} while (true);\n\t\tnode.warn({run});\n\n\t\t// return result\t\t\n\t\tconst result = await openai_api.beta.threads.messages.list(threadId);\n\t\treturn result.data[0].content[0].text.value;\n\t} catch (error) {\n\t\tnode.warn('Error checking run status:' + error);\n\t}\n}\n\nconst cache = global.get('cache');\n\nasync function getFileContent(fileId) {\n    try {\n        const response = await openai_api.files.retrieve_content(fileId);\n        return response; // Nội dung file\n    } catch (error) {\n        console.error('Error retrieving file content:', error.message);\n        throw error;\n    }\n}\n\n\noai.readDocxFile = async (pathOrURL, prompt) => {\n\t/**\n\t * 1. Download file from URL\n\t * 2. Upload file to OpenAI\n\t * 3. Create vector store\n\t * 4. Add file to vector store\n\t * 5. Create assistant\n\t * 6. Create thread and message\n\t * 7. Run thread\n\t * 8. Check run status: completed -> get, failed -> wait 5s\n\t * 9. Cleanup resources\n\t * 10. Return result\n\t */\n\ttry {\n\t\t// Download file from URL if include: 'http.....'\n\t\t// const filePath = await downloadFileStream(pathOrURL);\n\n\t\t// Upload file to OpenAI\n\t\tconst fileId = await uploadFile(pathOrURL);\n\n\t\t// Create vector store\n\t\tconst vectorStore = await openai_api.beta.vectorStores.create({\n\t\t\tname: 'listFiles',\n\t\t});\n\t\t\n\t\t// Add file to vector store\n\t\tawait openai_api.beta.vectorStores.files.create(vectorStore.id, {\n\t\t\tfile_id: fileId,\n\t\t});\n\n\t\t// Create assistant\n\t\tconst assistant = await openai_api.beta.assistants.create({\n\t\t\tname: 'test',\n\t\t\tinstructions:\n\t\t\t\t'You are a helpful product support assistant and you answer questions based on the files provided to you.',\n\t\t\tmodel: 'gpt-4o',\n\t\t\t\n\t\t});\n\n\t\t// Create thread and message\n\t\tconst thread = await openai_api.beta.threads.create();\n\t\tconst message = await openai_api.beta.threads.messages.create(thread.id, {\n\t\t\trole: 'user',\n\t\t\tcontent: prompt,\n\t\t});\n\n\t\t// Run thread\n\t\tconst run = await openai_api.beta.threads.runs.create(thread.id, {\n\t\t\tassistant_id: assistant.id,\n\t\t});\n\n\t\t// Check run status\n\t\tconst result = await checkRunStatus(thread.id, run.id);\n\n\t\t// Cleanup resources\n\t\tawait cleanupResources(assistant.id, thread.id, vectorStore.id);\n\n\t\treturn result;\n\t} catch (error) {\n\t\tnode.warn('Error reading docx file:' + error);\n\t}\n};\n\n// const result = await oai.readDocxFile(url2,'what is this?');\n// node.warn(`result: ${result}`);\n\n\tconst list_file =await openai_api.beta.vectorStores.files.retrieve();\n\n\n{\n\t// dowload file from url\n\t// await downloadFileStream(url2)\n\t// await uploadFile('doc1.docx');\n\t// log file\n\t// const files = await openai_api.files.retrieve('file-FJc4UvWzfrnek5bCvFxPsf');\n\t// node.warn(files);\n\t// Create a vector store including our two files.\n\t// let vectorStore = await openai_api.beta.vectorStores.create({\n\t//     name: \"listFiles\",\n\t// });\n\t// node.warn(vectorStore);\n\t//vs_Fft06u9pnrtPc9MqSbhFDqi1\n\t//create store\n\t// const store = await openai_api.beta.vectorStores.files.create('vs_Fft06u9pnrtPc9MqSbhFDqi1', {\n\t//     file_id: 'file-FJc4UvWzfrnek5bCvFxPsf'\n\t// })\n\t// node.warn({store});\n\t// log strore\n\t// node.warn(await openai_api.beta.vectorStores.files.retrieve('vs_Fft06u9pnrtPc9MqSbhFDqi1'));\n\t// await openai_api.beta.vectorStores.files.create('vs_MSYIG0f5zs6vVuWju7vKhNCS', {\n\t//     file_id: 'file-FJc4UvWzfrnek5bCvFxPsf'\n\t// });\n\t// const assistant = await openai_api.beta.assistants.create({\n\t//     name: \"test\",\n\t//     instructions: \"You are a helpful product support assistant and you answer questions based on the files provided to you.\",\n\t//     model: \"gpt-4o\",\n\t//     tools: [{ \"type\": \"file_search\" }],\n\t//     tool_resources: {\n\t//         file_search: {\n\t//             vector_store_ids: ['vs_Fft06u9pnrtPc9MqSbhFDqi1'] // Notice the change here\n\t//         }\n\t//     }\n\t// });\n\t// node.warn({assistant});\n\t//asst_tL1sovjMtj07wNxHWS78QENk\n\t// const thread = await openai_api.beta.threads.create();\n\t// node.warn({thread});\n\t//thread_QcnwWMEyutNcXuSNCsdvrdeD\n\t// const message = await openai_api.beta.threads.messages.create('thread_QcnwWMEyutNcXuSNCsdvrdeD',{\n\t//     role: 'user',\n\t//     content: 'what is this?'\n\t// })\n\t// node.warn({message});\n\t//msg_SJGbfGgJbL5ADz5x34U18OOJ\n\t// const data = await openai_api.beta.threads.runs.create('thread_QcnwWMEyutNcXuSNCsdvrdeD',{\n\t//     assistant_id: 'asst_tL1sovjMtj07wNxHWS78QENk'\n\t// })\n\t// node.warn({data});\n\t// run_Qi0nNqsOYgTchyMbAcuBYOGP\n\t// const res = await openai_api.beta.threads.messages.list('thread_QcnwWMEyutNcXuSNCsdvrdeD');\n\t// node.warn({res});\n\n\t// const run = await checkRunStatus('thread_QcnwWMEyutNcXuSNCsdvrdeD', 'run_Qi0nNqsOYgTchyMbAcuBYOGP');\n\t// node.warn(run);\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "buffer",
                "module": "buffer"
            },
            {
                "var": "stream",
                "module": "stream"
            },
            {
                "var": "fs",
                "module": "fs"
            }
        ],
        "x": 1090,
        "y": 500,
        "wires": [
            []
        ]
    },
    {
        "id": "cab86156cb42c6e2",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 940,
        "y": 60,
        "wires": [
            [
                "f7987db312b20625"
            ]
        ]
    },
    {
        "id": "f7987db312b20625",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "cacheChatContext",
        "func": "const cache = global.get('cache') || {};\n\n/**\n * Cấu trúc dữ liệu:\n * cache.chat_context = [\n * \t{\n * \t     assistant_id:\n * \t\t thread_id:\n * \t\t messages: [],\n * \t\t results: {},\n * \t\t temporary_result: {},\n * \t\t files: [],\n * \t}\n * ]\n */\n\ncache.list_threads = cache.list_threads || [];\ncache.list_files = cache.list_files || [];\ncache.chat_context = cache.chat_context || {};\n\n/**\n * Hàm ghi assistant vào context\n */\ncache.set_chat_assistant = (user_id, ast_id, content) => {\n\n\tcache.chat_context[user_id][ast_id] = {\n\t\tvalue: content,\n\t\tcreated_at: new Date()\n\t};\n};\n\ncache.add_chat_assistant = (user_id, ast_id, content) => {\n\tif (!cache.chat_context[user_id]) {\n\t\tcache.chat_context[user_id] = {};\n\t}\n\tif (!cache.chat_context[user_id][ast_id]) {\n\t\tcache.set_chat_assistant(user_id, ast_id, content);\n\t}\n};\n\ncache.add_thread = (ast_id, thread_id) => {\n\tcache.list_threads.push({\n\t\tassistant_id: ast_id,\n\t\tthread_id: thread_id\n\t})\n}\n\ncache.add_file = (file_name,file_id) => {\n\tcache.list_files.push({\n\t\tfile_name: file_name,\n\t\tfile_id: file_id\n\t})\n}\n\n\n/**\n * Hàm set context\n */\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1230,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "f4870ea699dfbcf3",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "->",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 775,
        "y": 220,
        "wires": [
            [
                "5bd705a8479a63c2"
            ]
        ],
        "l": false
    },
    {
        "id": "7581a676cb093d88",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "Openai Assistants",
        "func": "const axios = global.get('axios'); // *** Chỗ nào dùng thì declare chỗ đó\nconst fs = global.get('fs').promises; // *** Chỗ nào dùng thì declare chỗ đó\nconst cache = global.get('cache');\nconst { Readable } = stream; // *** Chỗ nào dùng thì declare chỗ đó\nconst openai_api = global.get('openai_api'); // openai client\nconst oai = global.get('oai'); // function helpers (oai.call, oai.extractJSON, oai.extractResponse)\n\nclass OpenaiAssistant {\n\tthread_id;\n\tassistant_id;\n\tmessages = [];\n\tresults = {};\n\ttemporary_result = {}; // *** Không cần đến temporary nữa\n\tfiles = [];\n\n\tconstructor() {}\n\n\tasync createAssistant(name, instructions, model, tool = [{}], tool_resources = [{}]) {\n\t\t// create assistant\n\t\tconst assistant = await openai_api.beta.assistants.create({\n\t\t\tname: name,\n\t\t\tinstructions: instructions,\n\t\t\tmodel: model,\n\t\t\ttools: [{ type: 'file_search' }],\n\t\t\ttemperature: 0,\n\t\t\t// tool_resources: tool_resources,\n\t\t});\n\t\tthis.assistant_id = assistant.id;\n\t\t//create thread\n\t\tconst thread = await openai_api.beta.threads.create();\n\t\tthis.thread_id = thread.id;\n\n\t\tcache.add_thread(this.assistant_id, this.thread_id);\n\t}\n\n\tasync uploadFile(media) {\n\t\t/** media: {file_stream, file_name} */\n\t\ttry {\n\t\t\tlet fileStream;\n\t\t\t\n\t\t\tif(media){\n\t\t\t\tconst file = await openai_api.files.create({\n\t\t\t\t\tfile: fileStream,\n\t\t\t\t\tpurpose: 'assistants',\n\t\t\t\t});\n\n\t\t\t\tthis.files.push({ file_name: media.file_name, file_id: file.id });\n\t\t\t\tcache.add_file(media.file_name, file.id);\n\n\t\t\t\tconst response = {\n\t\t\t\t\tuser_request: 'upload file',\n\t\t\t\t\tattachments: media.file_name,\n\t\t\t\t\topenai_response: 'file uploaded -> option: \"getTestResults\",...',\n\t\t\t\t};\n\n\t\t\t\tthis.messages.push(response);\n\n\t\t\t\tcache.add_file(media.file_name, file.id);\n\n\t\t\t\treturn { file_name: media.file_name, file_id: file.id };\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t} catch (error) {\n\t\t\tnode.warn('Lỗi khi tải file từ URL: ' + error);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\t// Đảm bảo file luôn được xóa\n\t\t\tif (await fs.stat(media.file_name).catch(() => false)) {\n\t\t\t\tawait fs.unlink(media.file_name);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateAssistant(instructions, model, tool = [{}], tool_resources = [{}]) {\n\t\t// update assistant\n\t\tawait openai_api.beta.assistants.update(this.assistant_id, {\n\t\t\tinstructions: instructions,\n\t\t\tmodel: model,\n\t\t\t// tool: tool,\n\t\t\t// tool_resources: tool_resources,\n\t\t});\n\t}\n\n\tasync createThread() {\n\t\t// create thread\n\t\tconst thread = await openai_api.beta.threads.create();\n\t\tthis.thread_id = thread.id;\n\t}\n\n\tasync createMessage(attachments, prompt) {\n\t\tnode.warn(\"Create message\");\n\t\t// attachments luôn luôn là array\n\t\tif (!attachments) attachments = [];\n\t\tattachments = Array.isArray(attachments) ? attachments : [attachments];\n\n\t\tlet message_body = {\n\t\t\trole: 'user',\n\t\t\tcontent: prompt,\n\t\t};\n\t\tnode.warn(attachments);\n\n\t\tif (attachments.length > 0) {\n\t\t\t// *** Kiểm tra đúng syntax\n\t\t\tmessage_body.attachments = attachments.map((file) => ({\n\t\t\t\tfile_id: file.file_id,\n\t\t\t\ttools: [{ type: 'file_search' }],\n\t\t\t}));\n\t\t}\n\n\t\t// send message to thread\n\t\tconst message = await openai_api.beta.threads.messages.create(this.thread_id, message_body);\n\n\t\t// run thread\n\t\tconst run = await openai_api.beta.threads.runs.create(this.thread_id, {\n\t\t\tassistant_id: this.assistant_id,\n\t\t});\n\n\t\t// return response\n\t\tconst openai_response = await this.checkRunStatus(this.thread_id, run.id);\n\n\t\tconst format_response = {\n\t\t\trun_id: run.id,\n\t\t\tuser_request: prompt,\n\t\t\tattachments: attachments,\n\t\t\topenai_response: openai_response,\n\t\t};\n\n\t\tthis.messages.push(format_response);\n\n\t\t// return openai_response or format_response\n\t\treturn openai_response;\n\t}\n\n\tasync checkRunStatus(thread_id, run_id) {\n\t\t// check run status and return result\n\t\ttry {\n\t\t\tlet run;\n\t\t\tdo {\n\t\t\t\t// check run status: queue -> in_progress  -> completed / failed\n\t\t\t\trun = await openai_api.beta.threads.runs.retrieve(thread_id, run_id);\n\t\t\t\tnode.warn(`Assistant_id:${this.assistant_id}\\nThread id: ${thread_id}\\nRun id: ${run_id}\\nStatus: ${run.status}`);\n\t\t\t\tif (run.status === 'completed' || run.status === 'failed') break;\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 5000));\n\t\t\t} while (true);\n\t\t\tif (run.status === 'failed') {\n\t\t\t\treturn `\n\t\t\t\t\t\t{  \n                                type: “request_failed”,\n                                user_message: {\n                                        text: “Có lỗi xảy ra, hãy thử lại!”,\n                                        no_reply: true,\n                                        is_still_thinking: false\n                                }\n                        }\n\t\t\t\t\t\t`;\n\t\t\t}\n\t\t\t// return result\n\t\t\tconst result = await openai_api.beta.threads.messages.list(thread_id);\n\t\t\treturn result.data[0].content[0].text.value;\n\t\t} catch (error) {\n\t\t\tnode.warn('Error checking run status:' + error);\n\t\t}\n\t}\n\n\tasync setTemporary(key, value) {\n\t\tthis.temporary_result = {\n\t\t\t[key]: value,\n\t\t};\n\t}\n\n\tasync setResults() {\n\t\t// get result from temporary_result(not include instructions) => set result\n\t\tconst result = this.temporary_result;\n\n\t\t// set this.result\n\t\tthis.results = {\n\t\t\t...this.results,\n\t\t\t...result,\n\t\t};\n\t}\n}\n\nclass LabReportSubmit extends OpenaiAssistant {\n\t#user_id; // *** Không cần đến user_id nữa\n\t#ai_tempurature = 0.2; // *** Chưa sử dụng\n\t#result = {}; // *** Không cần đến temporary nữa\n\t#table = global.get('tables');\n\n\tconstructor(user_id) {\n\t\tsuper();\n\t\tthis.#user_id = user_id;\n\t}\n\n\tstatic async get(user_id, ast_id) {\n\t\treturn cache.chat_context[user_id][ast_id];\n\t}\n\n\tasync create() {\n\t\t// create new assistant\n\t\tconst name = 'lab_report_submit'; // TODO: Complete instruction\n\t\t/*const instructions = `\n                        You are a laboratory assistant who only answer in JSON format.\n                        I am a backend database that sit between you (the assistant) and my users.\n                        My user will send me lab test's result, which I will forward everything to you. Your goal is to extract information and collect from all reports the results and then match each of them to sample’s analytes.\n                        To ask for the sample's analytes, you must give me a list of unique sample_uids (often starts with \"SP\") so I can query it for you in my database. You can find sample_uids in the test report.\n                        You can tell me a short text message in natural language so I can inform / prompt my user action must take, recommendation or confirmation about current action.\n                        All answers must be strictly in JSON format template below:\n\n                        {  \n                                type: “request_analytes_of_sample/ asking_for_confirmation/ commit_this_result/ cancel_request”,\n                                sample_uids: [\"SP……\", \"SP……\"],\n                                analyte_results: [{\"id\": 2, \"sample_uid\": \"SPx…”, \"test_name\": “String”, \"result_value\": “…”, \"result_unit\": “…”, \"protocol\": “HDPP/TCVN/QCVN/DĐVN/…” }],\n                                user_message: {\n                                        text: “<natural language>”,\n                                        no_reply: true/false,\n                                        is_still_thinking: true/false\n                                }\n                        }\n\n                        To ask for sample's analytes, \n                        1. set field “type” to “request_analytes_of_sample”\n                        2. Set \"sample_uids” to list of unique sample_uid string you want to query.\n                        3. user_message text should be natural language to inform user about current action, is_still_thinking is true because this is the work is going on between me and you\n                        4. Other fields can left empty to save token.\n\n                        Every time you finished matching results to analytes, I must ask my user for confirmation of your work:\n                        1. set field “type” to “asking_for_confirmation” \n                        2. Listing your matching results set “analyte_results” to list of result\n                        3. user_message text should be natural language to prompt user for instruction is required.\n                        4. Other fields can left empty to save token.\n\n                        If user express confirmation on your work, you let me know by:\n                        1. set field “type” to “commit_this_result”\n                        2. user_message text should be your confirmation of user’s request. no_reply is true because nothing else to be done.\n                        3. Other fields can left empty to save token\n\n\t\t\t\t\t\tIf user wants to cancel, let me know by:\n\t\t\t\t\t\t1. set field “type” to “cancel_request”\n\t\t\t\t\t\t2. user_message text should be your confirmation of user’s request. no_reply is true because nothing else to be done.\n\t\t\t\t\t\t3. Other fields can left empty to save token\n                `;\n\t\t*/\n\t\tconst instructions = `All answers must be strictly in JSON format template below:\n\t\t\t{  \n\t\t\ttype: \"request_analytes_of_sample/ asking_for_confirmation/ commit_this_result/ cancel_request\",\n\t\t\tsample_uids: [\"SPx…\",\"SPx…\",...],\n\t\t\tanalyte_results: [{\"sample_uid\": \"SPx…\", \"test_name\": \"String\", \"result_value\": \"…\", \"result_unit\": \"…\"}],\n\t\t\tanalyte_matches: [{\"id\": int,\"sample_uid\", \"test_name\": \"String\", \"result_value\": \"String\", \"result_unit\": \"String\"}],\n\t\t\tuser_message: {\n\t\t\t\t\ttext: \"<natural language>\",\n\t\t\t\t\tno_reply: true/false,\n\t\t\t\t\tis_still_thinking: true/false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tNote: \n\t\t\tResponse type: \"asking_for_confirmation\" when the user sends a match request or modification request.\n\t\t\tIf result_value is < LOD or LOQ, the value should be a number (e.g. < LOQ (LOQ: 0.018), etc.).\n\t\t\tuser_message: Vietnamese only\n\t\t\t`;\n\t\tconst model = 'gpt-4o';\n\t\tconst tool = [{}];\n\t\tconst tool_resources = [{}];\n\t\tawait this.createAssistant(name, instructions, model, tool, tool_resources);\n\t}\n\n\tasync newPrompt(medias, prompt, callback) {\n\t\ttry {\n\t\t\tnode.warn(medias);\n\t\t\t// Chuẩn bị prompt\n\t\t\tmedias = Array.isArray(medias) ? medias : [medias];\n\t\t\tconst files = medias.length > 0 ? await Promise.all(medias.map((media) => this.uploadFile(media))) : [];\n\t\t\t\n\t\t\t// gửi prompt đến openai\n\t\t\tlet ai_response = await this.createMessage(files, prompt);\n\n\t\t\tlet obj_response = await oai.extractJSON(ai_response);\n\t\t\tnode.warn(obj_response);\n\n\t\t\tlet count = 0;\n\t\t\t// lặp xử lý response\n\t\t\twhile (obj_response && count < 5) {\n\t\t\t\tnode.warn(obj_response);\n\t\t\t\tswitch (obj_response?.type) {\n\t\t\t\t\tcase 'request_analytes_of_sample':\n\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\tconst red_response = {\n\t\t\t\t\t\t\ttype: 'request_analytes_of_sample',\n\t\t\t\t\t\t\tsample_analytes: await this.findSampleAnalytes(obj_response?.sample_uids),\n\t\t\t\t\t\t};\n\t\t\t\t\t\t// ai_response = await this.createMessage(null, JSON.stringify(red_response));\n\t\t\t\t\t\tai_response = await this.processReport(obj_response);\n\t\t\t\t\t\tobj_response = await oai.extractJSON(ai_response);\n\t\t\t\t\t\tawait callback(obj_response);\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'asking_for_confirmation':\n\t\t\t\t\t\t// Save/Update result\n\t\t\t\t\t\tthis.#result = obj_response?.analyte_matches;\n\t\t\t\t\t\tawait callback(obj_response);\n\t\t\t\t\t\treturn; // exit function\n\t\t\t\t\tcase 'commit_this_result':\n\t\t\t\t\t\tnode.warn(this.#result);\n\t\t\t\t\t\t// TODO: commit saved result to database\n\t\t\t\t\t\t// await this.#table.SampleAnalyte.setResult(obj_response.analyte_results);\n\t\t\t\t\t\tawait callback(obj_response);\n\t\t\t\t\t\treturn; // exit function\n\t\t\t\t\tcase 'cancel_request':\n\t\t\t\t\t\tawait callback(obj_response);\n\t\t\t\t\t\treturn; // exit function\n\t\t\t\t\tcase 'request_failed':\n\t\t\t\t\t\tawait callback(obj_response);\n\t\t\t\t\t\treturn;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Unexpected response type\n\t\t\t\t\t\tthrow new Error('Unexpected response type: ' + obj_response?.type);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tnode.warn('Assistant Error while submitting report');\n\t\t\tnode.warn(error.stack);\n\t\t\tawait callback({\n\t\t\t\ttype: 'cancel_request',\n\t\t\t\tuser_message: {\n\t\t\t\t\ttext: 'Error submitting report: ' + error.message,\n\t\t\t\t\tno_reply: true,\n\t\t\t\t\tis_still_thinking: false,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tasync findSampleAnalytes(sample_uids) {\n\t\ttry {\n\t\t\tnode.warn(sample_uids);\n\t\t\tif (!Array.isArray(sample_uids)) throw new Error('Sample uids must be an array');\n\t\t\tsample_uids = [...new Set(sample_uids)];\n\n\t\t\tlet analytes = [];\n\t\t\tfor (let sample_uid of sample_uids) {\n\t\t\t\tconst sample_analytes = await this.#table.SampleAnalyte.getByUid(sample_uid);\n\t\t\t\tanalytes.push(...sample_analytes);\n\t\t\t}\n\n\t\t\treturn analytes;\n\t\t} catch (error) {\n\t\t\tnode.warn('Lab Report Submit Assistant Error finding sample analytes');\n\t\t\tnode.warn(error.stack);\n\t\t}\n\t}\n\n\tasync processReport(obj_response) {\n\t\ttry {\n\t\t\t/** 1. Match analyte to result */\n\t\t\t// get list sample_uid from this.result.analyte_results\n\t\t\t// const sample_uids = this.results.sample_uids\n\t\t\t// const unique_sample_uids = [...new Set(sample_uids)];\n\n\t\t\t// // get list sample_analyte by sample_uid\n\t\t\t// let analytes = [];\n\n\t\t\t// for (let sample_uid of unique_sample_uids) {\n\t\t\t// \tconst sample_analytes = await this.#table.SampleAnalyte.getByUid(sample_uid);\n\t\t\t// \tanalytes.push(...sample_analytes);\n\t\t\t// }\n\n\t\t\t// set prompt\n\t\t\tlet count = 0;\n\t\t\tconst list_promises = obj_response.sample_uids.map(async (sample_uid) => {\n\t\t\t\tcount +=1;\n                                // get analytes from database by sample_uid\n                                const analytes = await this.findSampleAnalytes([sample_uid]);\n\n                                // get analyte_results from oai response by sample_uid\n                                const analyte_results = obj_response.analyte_results.filter((analyte) => analyte.sample_uid === sample_uid);\n\n                                // set input\n                                const input = `\n                                [${analytes\n                                        .map(\n                                                (analyte) =>\n                                                        `{\"id\": ${analyte.id}, \"sample_uid\": ${analyte.sample_uid}, \"test_name\": ${analyte.test_name}, \"protocol\":${analyte.protocol_value}}`,\n                                        )\n                                        .join(', ')}]\n                                `;\n\n                                const prompt_match = `\n\t\t\t\t\tYour Task is to match the item in the Analyte Results list with the Analytes to Match list based on:\n\n\t\t\t\t\ttest_name: Match if the names are identical or similar (e.g., \"Định lượng Sn\" matches \"Sn\").\n\t\t\t\t\tsample_uid: Match if the sample_uid values are identical.\n\t\t\t\t\tIf a match is found, return the attributes id, test_name, result_value, and result_unit from the matched item in Analyte Results, combined with additional attributes from Analytes to Match.\n\n\t\t\t\t\tAnswer strictly in the following JSON format\n\t\t\t\t\t[{\"id\": (int),\"sample_uid\": \"String\", \"test_name\": \"String\", \"result_value\": \"String\", \"result_unit\": \"String\"},...]\n\n\t\t\t\t\tAnalyte Results:\n\t\t\t\t\t${JSON.stringify(analyte_results)}\n\t\t\t\t\tAnalytes to Match:\n\t\t\t\t\t${input}\n                `;\n\n\t\t\t\t// send message to openai\n\t\t\t\tconst matchResults = await oai.call(prompt_match);\n\t\t\t\treturn matchResults;\n\t\t\t});\n\n            let list_analyte_matches = await Promise.all(list_promises);\n            let response = [];\n\t\t\tlist_analyte_matches.map( arr => {\n\t\t\t\tarr.forEach((analyte_match) =>  {\n\t\t\t\t\tresponse.push(analyte_match);\n\t\t\t\t});\n\t\t\t})\n\n\t\t\tlet prompt = `Đưa ra phản hồi phù hợp sau khi đã khớp kết quả tìm được trong biên bản với các chất thử/chỉ tiêu của mẫu (analyte_matches) theo mẫu dưới đây :\n\t\t\t{  \n\t\t\ttype: \"asking_for_confirmation\",\n\t\t\tsample_uids: Giữ nguyên,\n\t\t\tanalyte_results: Giữ nguyên,\n\t\t\tanalyte_matches: bổ sung ${ JSON.stringify(response)},\n\t\t\tuser_message: {\n\t\t\t\t\ttext: \"<natural language>\",\n\t\t\t\t\tno_reply: true/false,\n\t\t\t\t\tis_still_thinking: true/false\n\t\t\t\t}\n\t\t\t}\n\t\t\t`\n\t\t\t\n\t\t\tobj_response = await this.createMessage([], prompt);\n\n            return obj_response;\n\t\t} catch (error) {\n\t\t\tnode.warn('Error getting test results:' + error);\n\t\t}\n\n\t}\n\n\tasync editResult(response) {\n\t\t// send message to openai again\n\t\t// set temporary result: {instructions, [key]: value}\n\t\t// return result\n\t\ttry {\n\t\t\tlet listMatches = [];\n\t\t\t// analyze response => get result\n\t\t\tconst result_match = response.match(/\\{.*\\}/s);\n\t\t\tconst cleanedResponse_match = result_match ? result_match[0] : '{}';\n\t\t\tconst obj_response = JSON.parse(cleanedResponse_match);\n\n\t\t\tlistMatches = obj_response.modifications;\n\t\t\tnode.warn(listMatches);\n\n\t\t\tthis.setTemporary('analyte_matches', listMatches);\n\n\t\t\t// set cache\n\t\t\tcache.add_chat_assistant(this.#user_id, this.assistant_id, this);\n\n\t\t\treturn obj_response;\n\t\t} catch (error) {\n\t\t\tnode.warn('Error editing result:' + error);\n\t\t}\n\t}\n\n\tasync commitResult(analytes) {\n\t\t// TODO: Validate, commit result to database\n\t\tnode.warn('Commit result to database');\n\t\tnode.warn({ analytes });\n\n\t\t// TODO: return updated database records\n\t}\n\n\tasync cancel(response) {\n\t\t// delete assistant, thread or anything\n\n\t\tnode.warn('call cancel func!');\n\t\tconst result_match = response.match(/\\{.*\\}/s);\n\t\tconst cleanedResponse_match = result_match ? result_match[0] : '{}';\n\t\tconst obj_response = JSON.parse(cleanedResponse_match);\n\n\t\treturn obj_response;\n\t}\n\n\tasync commitResult0(response) {\n\t\t// set result : get result from temporary_result(not include instructions) => set result\n\t\ttry {\n\t\t\t// set this.result; delete instructions and request\n\t\t\tthis.setResults();\n\n\t\t\t// Ghi vào csdl\n\t\t\tif (!Array.isArray(this.results.analyte_matches)) throw new Error('Analyte matches not found');\n\n\t\t\t// Lấy analyte_matches từ this.results.analyte_matches\n\t\t\tconst results = this.results.analyte_matches.map((analyte_match) => analyte_match.result || analyte_match);\n\t\t\tnode.warn(results);\n\n\t\t\t// // Thực hiện update hàm table.SampleAnalyte.setResult(result)\n\t\t\t// for (let result of results) {\n\t\t\t// \t// kiểm tra result có id không\n\t\t\t// \tif (!result.id) {\n\t\t\t// \t\tthrow new Error('Missing analyte id');\n\t\t\t// \t}\n\t\t\t// \t// update result\n\t\t\t// \tconst analyte = await this.#table.SampleAnalyte.get(result.id);\n\t\t\t// \tif (analyte) {\n\t\t\t// \t\tawait analyte.update(result);\n\t\t\t// \t}\n\t\t\t// }\n\n\t\t\tthis.updated_at = new Date();\n\n\t\t\tconst openai_res = {\n\t\t\t\tuser_request: 'commit result',\n\t\t\t\topenai_response: 'result committed',\n\t\t\t};\n\n\t\t\tthis.messages.push(openai_res);\n\n\t\t\t// set cache\n\t\t\tcache.add_chat_assistant(this.#user_id, this.assistant_id, this);\n\n\t\t\tconst result_match = response.match(/\\{.*\\}/s);\n\t\t\tconst cleanedResponse_match = result_match ? result_match[0] : '{}';\n\t\t\tconst obj_response = JSON.parse(cleanedResponse_match);\n\n\t\t\t// return result\n\t\t\treturn obj_response;\n\t\t} catch (error) {\n\t\t\tnode.warn('Error committing result:' + error);\n\t\t}\n\t}\n}\n\nclass SampleReceipt extends OpenaiAssistant {\n\t#user_id;\n\t#file_ids = [{ file_name: '', file_id: '' }];\n\t#ai_tempurature = 0.2;\n}\n\nglobal.set('Assistant', {\n\t// *** Đổi tên\n\tLabReportSubmit,\n\tSampleReceipt,\n});\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "stream",
                "module": "stream"
            },
            {
                "var": "fs_origin",
                "module": "fs"
            },
            {
                "var": "mime",
                "module": "mime"
            }
        ],
        "x": 950,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "946622c90626134c",
        "type": "function",
        "z": "5fb64aedc3e2bcf3",
        "name": "AuthCenter",
        "func": "const AUTH = {\n        identity : [{\n                        identity_uid: 'eIDx777abcdef',\n                        identity_name: 'Xuan Truong',\n                        contact_email: 'abc@xuantruong.xyz',\n                        password: '', // hashed password\n                        security: {\n                                isForcedResetPassword: false,\n                                isForcedResignIn: false\n                        },\n                        irdop_relation: {\n                                staff: true,\n                                staff_admin: true,\n                                staff_superadmin: true,\n                                staff_LabResultReport: true,\n                        },\n                        \n                        telegram_peer: {\n                                userId: \"660522892\",\n                                className: \"PeerUser\"\n                        }\n                }, {\n                        identity_uid: 'eIDxFabc4292',\n                        identity_name: 'Tran Quan Tu',\n                        contact_email: 'TranQuangTu@irdop.org',\n                        password: '', // hashed password\n                        irdop_relation: {\n                                staff: true,\n                                staff_admin: true,\n                                staff_superadmin: true,\n                        },\n                        security: {\n                                isForcedResetPassword: false,\n                                isForcedResignIn: false\n                        },\n                        telegram_peer: {\n                                userId: \"6069072545\",\n                                className: \"PeerUser\"\n                        }\n                }\n        ],\n        \n        // Lấy identity object dựa trên Telegram peerInfo\n        get_identity_by_tg: (peerInfo) => {\n                const matchingIdentities = AUTH.identity.filter(identity => {\n                        const thisPeer = identity?.telegram_peer;\n\n                        // Check if all keys match\n                        const isMatch = Object.keys(thisPeer).every(key => \n                            String(thisPeer[key]) === String(peerInfo[key])\n                        );\n\n                        return isMatch ? identity : null;\n                });\n\n                if (matchingIdentities.length === 1) {\n                    return matchingIdentities[0];\n                } else if (matchingIdentities.length > 1) {\n                    return null;        // multiple matching identities found\n                } else {\n                    return null;        // no matching identity found\n                }\n        },\n\n        get_identity_by_uid: async (identity_uid) => {\n                return AUTH?.identity?.find(identity => identity.identity_uid === identity_uid);\n        }\n}\n\nglobal.set('AUTH', AUTH);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "f2da338a2435b831",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 370,
        "y": 60,
        "wires": [
            [
                "1433a20f7944ae6c"
            ]
        ]
    },
    {
        "id": "bfef09aad0ec5d55",
        "type": "inject",
        "z": "5fb64aedc3e2bcf3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 360,
        "y": 240,
        "wires": [
            [
                "5fea1f3d11b6585c"
            ]
        ]
    },
    {
        "id": "a0ecf94ea2cb05c1",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "name": "post new sample",
        "url": "/new_sample",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1140,
        "y": 260,
        "wires": [
            [
                "3edb570284f771a3"
            ]
        ]
    },
    {
        "id": "3edb570284f771a3",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "New Sample",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { Sample } = global.get(\"tables\");\n\ntry {\n    let sample;\n\n\n    /** 1. AUTHENTICATE */\n    if (xano.bridge_api) {\n        // This block is intentionally left blank\n        // If bridge_api is true, Authentication is alreadt done in Xano\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. CREATE RECORD */\n    if (xano.bridge_api) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            authorization: msg.req.headers.authorization,\n        };\n        const xanoResponse = await xano.post_create_sample(\n            headers,\n            msg.req.body,\n        );\n        sample = xanoResponse.data;\n    } else {    // TODO: Auth, Red table,... forward to xano ,...\n        sample = await Sample.new(msg.req.body.new_sample);\n    }\n\n    /** 3. SET CACHE IF EXIST*/\n    const expireTime = 4 * 60 * 1000; // 4 minutes\n    if (\n        cache.recentReceipts &&\n        cache.recentReceipts.value &&\n        Date.now() - cache.recentReceipts.cached_at < expireTime\n    ) {\n        const receipt_idx = cache.recentReceipts.value.findIndex((receipt) => receipt.id === sample.sample_receipt_id);\n        if (receipt_idx !== -1) {   // only update if target receipt is in cache\n            cache.recentReceipts.value[receipt_idx].samples.unshift(sample);\n            cache.recentReceipts.cached_at = Date.now();\n        }\n    }\n\n    /** 4. RETURN TO CLIENT */\n    msg.payload = sample;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Create Sample error: \" + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 260,
        "wires": [
            [
                "8825701f46bed688"
            ]
        ]
    },
    {
        "id": "8825701f46bed688",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1650,
        "y": 260,
        "wires": []
    },
    {
        "id": "5d6051887d23491b",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "name": "post new test",
        "url": "/new_tests",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1130,
        "y": 300,
        "wires": [
            [
                "f05bdc909167b761"
            ]
        ]
    },
    {
        "id": "f05bdc909167b761",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "New Tests From Sample",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { TestOrder } = global.get(\"tables\");\n\ntry {\n    let test;\n\n    /** 1. CREATE RECORD */\n    if (xano.bridge_api) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            authorization: msg.req.headers.authorization,\n        };\n        const xanoResponse = await xano.post_sample_add_tests(\n            headers,\n            msg.req.body,\n        );\n        test = xanoResponse.data;\n    } else {\n        // USE Red DB\n        //msg.req.body: receipt_id Number, sample_id Number, tests Array<Test {object}>\n        // matching lib_test_id\n    }\n\n    /** 2. SET CACHE IF EXIST*/\n    if (cache.recentReceipts && cache.recentReceipts.value) {\n        const receipt_idx = cache.recentReceipts.value.findIndex((receipt) => receipt.id === test.sample.sample_receipt_id);\n        if (receipt_idx !== -1) {   // only update if target receipt is in cache\n            const sample_idx = cache.recentReceipts.value[receipt_idx].samples.findIndex((sample) => sample.id === test.sample_id);\n            if (sample_idx !== -1) {   // only update if target sample is in cache\n                cache.recentReceipts.value[receipt_idx].samples[sample_idx] = [test, ...cache.recentReceipts.value[receipt_idx].samples];\n            }\n        }\n    }\n\n    msg.payload = test;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Add test orders error: \" + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 300,
        "wires": [
            [
                "f37928b7cb2b2ed1"
            ]
        ]
    },
    {
        "id": "f37928b7cb2b2ed1",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1650,
        "y": 300,
        "wires": []
    },
    {
        "id": "f57454ef879ae3c5",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "name": "post del tests",
        "url": "/delete_tests",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 1130,
        "y": 420,
        "wires": [
            [
                "6878f1a486c9b760"
            ]
        ]
    },
    {
        "id": "6878f1a486c9b760",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "Delete tests from sample",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\n\ntry {\n    let tests;\n\n    /** 1. CREATE RECORD */\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"authorization\": msg.req.headers.authorization\n    }\n\n    if (xano.bridge_api) {      // USE XANO BRIDGE\n        /** 1. Send and receive Xano Request */\n        const xanoResponse = await xano.post_create_receipt(headers, msg.params.body);\n        tests = xanoResponse.data;\n    }\n    else {                      // USE Red DB\n        // TODO: \n    }\n\n    const recentReceipts_cache = cache.recentReceipts;\n\n    /** 2. SET CACHE IF EXIST*/\n    if (tests.status === 200) {\n        const expireTime = 4 * 60 * 1000; // 4 minutes\n        if (\n            recentReceipts_cache &&\n            Date.now() - recentReceipts_cache.cached_at < expireTime\n        ) {\n            // SET VALUE\n            const index = cache.recentReceipts.value.findIndex((receipt) => receipt.id === msg.req.body.receipt_id);\n            let newCacheValue = recentReceipts_cache.value;\n            if (index !== -1) {\n                newCacheValue[index] = tests.receipt;\n                cache.recentReceipts = {\n                    value: newCacheValue,\n                    cached_at: Date.now(),\n                };\n            }\n        }\n    } else {\n        throw new Error(\"Xano Auth API returned non-200 status\");\n    }\n\n    msg.payload = tests;\n    return msg;\n} catch (error) {\n    node.warn(\"Delete tests from sample: \" + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 420,
        "wires": [
            [
                "ab39f1dd0b94bb74"
            ]
        ]
    },
    {
        "id": "ab39f1dd0b94bb74",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1650,
        "y": 420,
        "wires": []
    },
    {
        "id": "e076c647d56e2f1f",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "name": "post del sample",
        "url": "/delete_sample",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 1140,
        "y": 380,
        "wires": [
            [
                "46fea14699ef1847"
            ]
        ]
    },
    {
        "id": "46fea14699ef1847",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "Delete Sample",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\n\ntry {\n    let sample;\n\n    /** 1. CREATE RECORD */\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"authorization\": msg.req.headers.authorization\n    }\n\n    if (xano.bridge_api) {      // USE XANO BRIDGE\n        /** 1. Send and receive Xano Request */\n        const xanoResponse = await xano.post_delete_sample(\n            headers,\n            msg.req.body,\n        );\n        sample = xanoResponse.data;\n    }\n    else {                      // USE Red DB\n        // TODO: \n    }\n\n    const recentReceipts_cache = cache.recentReceipts;\n\n    /** 2. SET CACHE IF EXIST*/\n\n    if (sample.status === 200) {\n        const expireTime = 4 * 60 * 1000; // 4 minutes\n        if (\n            recentReceipts_cache &&\n            Date.now() - recentReceipts_cache.cached_at < expireTime\n        ) {\n            const index = cache.recentReceipts.value.findIndex((receipt) => receipt.id === sample.id);\n            node.warn(index);\n            let newCacheValue = recentReceipts_cache.value;\n            if (index !== -1) {\n                newCacheValue[index] = sample;\n                cache.recentReceipts = {\n                    value: newCacheValue,\n                    cached_at: Date.now(),\n                };\n            }\n\n            node.warn(cache.recentReceipts.value);\n        }\n    } else {\n        throw new Error(\"Xano Auth API returned non-200 status\");\n    }\n\n    msg.payload = sample;\n    return msg;\n} catch (error) {\n    node.warn(\"Delete sample: \" + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 380,
        "wires": [
            [
                "ec26d24551a1aef0"
            ]
        ]
    },
    {
        "id": "ec26d24551a1aef0",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1650,
        "y": 380,
        "wires": []
    },
    {
        "id": "d351b04153bfba19",
        "type": "http in",
        "z": "46183d332de8b18f",
        "g": "90124c05cecd5787",
        "name": "POST: Submit test result",
        "url": "/api:eHOTU1fm/POST/_edit/submit_result",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 250,
        "y": 620,
        "wires": [
            [
                "b8c068dee7f01d2a"
            ]
        ]
    },
    {
        "id": "b8c068dee7f01d2a",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "90124c05cecd5787",
        "name": "Submit test result",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { Receipt } = global.get(\"tables\");\nnode.warn('API HIT: A new test result just submitted');\n/**\n * @param {Object} msg - The message object containing the request data\n * @param {Object} msg.req.body - The request body containing test results\n * @param {Object} msg.req.body.result_submit - The test result data\n * @returns {Promise<{test_order, protocol}|Error>} - A promise that resolves with the test result response or an error\n */\n\ntry {\n    let result_submit;        // Storing requested test result\n    let test_return;          // result return to client\n\n    /** 1. AUTHENTICATE */\n    if (xano.bridge_auth) {         // Forward to XN server\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        };\n        const authResponse = await xano.auth_me_employee(headers);\n    }\n    else {                          // Use Node-RED engine\n        // TODO: RED auth\n    }\n\n    /** 2. SUBMIT TEST RESULT */\n    if (xano.bridge_api) {         // Forward to XN server\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        };\n        const xanoResponse = await xano.post_submit_test_result(headers, msg.req.body);\n        test_return = xanoResponse.data;\n    }\n    else {                          // Use Node-RED engine\n        // TODO: RED submit test result\n    }\n\n    node.warn(test_return);\n    /** 3. IF submission success, update cache for all userToken  */\n    if (test_return && cache.processingSamples) {\n        for (let signature of Object.values(cache.processingSamples)) {\n            if(signature?.value?.samples){\n                for (let sample of signature.value.samples) {   // always try to update even to expired cache\n                    for (let test of sample.test_orders) {\n                        if (test.id === test_return.test_order.id) {\n                            test = test_return;     // update test result\n                        }\n                    }\n                }\n            }else{\n                node.warn(\"Test isn't cached on processing Samples\");\n            }\n\n\n        }\n    }\n\n    /** 4. RETURN TO CLIENT */\n    msg.payload = test_return;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Create receipt error: \" + error);\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 620,
        "wires": [
            [
                "8d198522e922ef0d"
            ]
        ]
    },
    {
        "id": "8d198522e922ef0d",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "90124c05cecd5787",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 620,
        "wires": []
    },
    {
        "id": "9a60357a4fec7c29",
        "type": "http in",
        "z": "46183d332de8b18f",
        "name": "POST: excel_internal_receipt",
        "url": "/api:hrFfPpfK/excel_internal_sample",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1180,
        "y": 160,
        "wires": [
            [
                "b71dd8f93f2f56fd"
            ]
        ]
    },
    {
        "id": "b71dd8f93f2f56fd",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "Generate Internal Sample Excel",
        "func": "const axios = global.get('axios')\n\nasync function fetchData(ids) {\n\ttry {\n\t\tconst response = await axios.post(\n\t\t\t'https://xn.irdop.org/api:FzsHe1z4/_get/_bulk/_sample',\n\t\t\tids, // Mảng chứa các id cần lấy dữ liệu\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t\treturn response.data;\n\t} catch (error) {\n\t\tconsole.error('Error fetching data:', error);\n\t}\n}\n\nfunction getCurrentDateFormatted(timestamp) {\n\tconst today = timestamp ? new Date(timestamp) : new Date();\n\tconst day = String(today.getDate()).padStart(2, '0');\n\tconst month = String(today.getMonth() + 1).padStart(2, '0'); // Tháng bắt đầu từ 0\n\tconst year = today.getFullYear();\n\treturn `${day}-${month}-${year}`;\n}\n\nasync function createAndWriteExcel() {\n\t/**\n\t * Tạo file Excel, ghi dữ liệu và chèn hình ảnh vào một ô.\n\t *\n\t * @param {string} fileName - Tên file Excel sẽ được tạo (bao gồm đuôi .xlsx).\n\t * @param {Array<Array>} data - Dữ liệu cần ghi vào file Excel, mỗi phần tử là một hàng.\n\t * @param {string} imagePath - Đường dẫn đến hình ảnh cần chèn.\n\t */\n\ttry {\n\t\t// Tạo một workbook mới'\n\t\tconst workbook = new ExcelJS.Workbook();\n\t\tconst worksheet = workbook.addWorksheet('Sheet1');\n\n\t\t// body: {ids: array <Number sample_id>}\n\t\tconst {ids} = msg.req.body;\n\t\t// // Dữ liệu ghi vào sheet\n\t\tif (!ids || Array.isArray(ids) === false || ids.length === 0) {\n\t\t\tthrow new Error('Danh sách mẫu không hợp lệ');\n\t\t}\n\t\tconst data = await fetchData({ ids });\n\n\t\t// Hàng 1 header\n\t\tworksheet.getCell('D1').value = `VIỆN NGHIÊN CỨU VÀ PHÁT TRIỂN SẢN PHẨM THIÊN NHIÊN\n        176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội\n        Phòng phân tích - Kiểm nghiệm`;\n\t\t// gộp ô\n\t\tworksheet.mergeCells('D1:G1');\n\t\t//căn lề cho nội dung trong ô\n\t\tworksheet.getCell('D1').alignment = {\n\t\t\twrapText: true,\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t};\n\t\t// chỉnh font cho ô\n\t\tworksheet.getCell('D1').font = { bold: true };\n\t\t// border cho ô\n\t\t['C1', 'D1'].forEach((cell) => {\n\t\t\tworksheet.getCell(cell).border = {\n\t\t\t\ttop: { style: 'thick' },\n\t\t\t\tleft: { style: 'thick' },\n\t\t\t\tbottom: { style: 'thick' },\n\t\t\t\tright: { style: 'thick' },\n\t\t\t};\n\t\t});\n\n\t\t// Tải hình ảnh từ URL dưới dạng buffer\n\t\tconst imageUrl = 'https://irdop.org/wp-content/uploads/2024/07/IRDOP-LOGO-2710-02-2.png';\n\t\tconst response = await axios.get(imageUrl, { responseType: 'arraybuffer' });\n\t\tconst imageBuffer = Buffer.from(response.data, 'binary');\n\n\t\t// Chèn hình ảnh vào ô C1\n\t\tconst imageId = workbook.addImage({\n\t\t\tbuffer: imageBuffer,\n\t\t\textension: 'png',\n\t\t});\n\n\t\tworksheet.addImage(imageId, {\n\t\t\ttl: { col: 2.144, row: 0.283 }, // Vị trí góc trên bên trái (ô C1), ảnhlề trái 14,4% chiều dài ô , \n\t\t\text: { width: 229, height: 70 }, // Kích thước hình ảnh\n\t\t});\n\n\t\tworksheet.getRow(1).height = 60; // Chiều cao hàng 1\n\n\t\tworksheet.getCell('A2').value = 'BIÊN BẢN BÀN GIAO MẪU THỬ NỘI BỘ';\n\t\tworksheet.mergeCells('A2:H2'); // Merge cell\n\t\tworksheet.getCell('A2').alignment = {\n\t\t\twrapText: true,\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t}; // Alignment\n\n\t\tworksheet.getRow(2).height = 60; // Chiều cao hàng 2\n\n\t\tworksheet.getCell('B3').value = 'Thông tin mẫu đến';\n\t\tworksheet.getCell('D3').value = getCurrentDateFormatted(data[0].created_at);\n\t\tworksheet.mergeCells('D3:E3');\n\t\tworksheet.getCell('F3').value = 'Ngày bàn giao mẫu';\n\t\tworksheet.getCell('G3').value = getCurrentDateFormatted();\n\t\tworksheet.mergeCells('G3:H3');\n\t\tworksheet.getCell('B4').value = 'Người bàn giao mẫu thử ( thuộc p. Dịch vụ)';\n\t\tworksheet.getCell('D4').value = '';\n\t\tworksheet.mergeCells('D4:E4');\n\t\tworksheet.getCell('F4').value = 'Ngày bàn giao mẫu cho lab';\n\t\tworksheet.getCell('G4').value = getCurrentDateFormatted();\n\t\tworksheet.mergeCells('G4:H4');\n\n\t\tworksheet.getCell('A6').value = 'Danh mục bàn giao các mẫu giao: trong bảng sau';\n\t\tworksheet.getCell('A6').font = { bold: true };\n\n\t\t// Điều chỉnh kích thước cột\n\t\tworksheet.columns = [\n\t\t\t{ width: 50 / 7.776 }, // Cột A\n\t\t\t{ width: 150 / 7.776 }, // Cột B\n\t\t\t{ width: 275 / 7.776 }, // Cột C\n\t\t\t{ width: 125 / 7.776 }, // Cột D\n\t\t\t{ width: 375 / 7.776 }, // Cột E\n\t\t\t{ width: 325 / 7.776 }, // Cột F\n\t\t\t{ width: 150 / 7.776 }, // Cột G\n\t\t\t{ width: 200 / 7.776 }, // Cột H\n\t\t];\n\n\t\t// A7:H7 Title\n\t\tconst titleCell = ['A7', 'B7', 'C7', 'D7', 'E7', 'F7', 'G7', 'H7'];\n\t\tconst titleValue = [\n\t\t\t'STT',\n\t\t\t'Mã mẫu',\n\t\t\t'Tên mẫu',\n\t\t\t'Số lượng mẫu',\n\t\t\t'Chỉ tiêu',\n\t\t\t'Phương pháp thử',\n\t\t\t'Ngày trả kết quả',\n\t\t\t'Người thực hiện chính',\n\t\t];\n\t\ttitleCell.forEach((cell, index) => {\n\t\t\tworksheet.getCell(cell).value = titleValue[index];\n\t\t\tworksheet.getCell(cell).font = { bold: true };\n\t\t\tworksheet.getCell(cell).alignment = {\n\t\t\t\twrapText: true,\n\t\t\t\thorizontal: 'center',\n\t\t\t\tvertical: 'middle',\n\t\t\t};\n\t\t\tworksheet.getCell(cell).border = {\n\t\t\t\ttop: { style: 'thin' },\n\t\t\t\tleft: { style: 'thin' },\n\t\t\t\tbottom: { style: 'thin' },\n\t\t\t\tright: { style: 'thin' },\n\t\t\t};\n\t\t});\n\n\t\t// Ghi dữ liệu vào sheet\n\t\tlet currentRow = 8;\n\t\tif (data.length > 0) {\n\t\t\tdata.forEach((sample, index) => {\n\t\t\t\tworksheet.getCell(`A${currentRow}`).value = index + 1;\n\t\t\t\tworksheet.getCell(`B${currentRow}`).value = sample?.sample_uid;\n\t\t\t\tworksheet.getCell(`C${currentRow}`).value = sample?.sample_name;\n\t\t\t\tworksheet.getCell(`D${currentRow}`).value = sample?.sample_qty;\n\n\t\t\t\t// Kiểm tra nếu test_orders tồn tại và là một mảng\n\t\t\t\tconst testOrders = sample.test_orders ?? [];\n\t\t\t\ttestOrders.forEach((test_order, testIndex) => {\n\t\t\t\t\tworksheet.getCell(`E${currentRow + testIndex}`).value = test_order?.test_name;\n\t\t\t\t\tworksheet.getCell(`F${currentRow + testIndex}`).value = test_order?.protocol?.code;\n\t\t\t\t\tworksheet.getCell(`G${currentRow + testIndex}`).value = test_order?.result_deadline;\n\t\t\t\t\tworksheet.getCell(`H${currentRow + testIndex}`).value = test_order?.tested_by?.name;\n\t\t\t\t\tconst dataCell = [\n\t\t\t\t\t\t`E${currentRow + testIndex}`,\n\t\t\t\t\t\t`F${currentRow + testIndex}`,\n\t\t\t\t\t\t`G${currentRow + testIndex}`,\n\t\t\t\t\t\t`H${currentRow + testIndex}`,\n\t\t\t\t\t];\n\t\t\t\t\tdataCell.forEach((cell) => {\n\t\t\t\t\t\tworksheet.getCell(cell).alignment = {\n\t\t\t\t\t\t\twrapText: true,\n\t\t\t\t\t\t\tvertical: 'middle'\n\t\t\t\t\t\t};\t\t\t\t\t\t\n\t\t\t\t\t\tworksheet.getCell(cell).border = {\n\t\t\t\t\t\t\ttop: { style: 'thin' },\n\t\t\t\t\t\t\tleft: { style: 'thin' },\n\t\t\t\t\t\t\tbottom: { style: 'thin' },\n\t\t\t\t\t\t\tright: { style: 'thin' },\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t// Gộp các ô nếu có test_orders\n\t\t\t\tif (testOrders.length > 0) {\n\t\t\t\t\tworksheet.mergeCells(`A${currentRow}:A${currentRow + testOrders.length - 1}`);\n\t\t\t\t\tworksheet.mergeCells(`B${currentRow}:B${currentRow + testOrders.length - 1}`);\n\t\t\t\t\tworksheet.mergeCells(`C${currentRow}:C${currentRow + testOrders.length - 1}`);\n\t\t\t\t\tworksheet.mergeCells(`D${currentRow}:D${currentRow + testOrders.length - 1}`);\n\t\t\t\t}\n\n\t\t\t\tconst cells = [`A${currentRow}`, `B${currentRow}`, `C${currentRow}`, `D${currentRow}`];\n\t\t\t\tcells.forEach((cell) => {\n\t\t\t\t\tworksheet.getCell(cell).alignment = {\n\t\t\t\t\t\twrapText: true,\n\t\t\t\t\t\thorizontal: 'center',\n\t\t\t\t\t\tvertical: 'middle',\n\t\t\t\t\t};\n\t\t\t\t\tworksheet.getCell(cell).border = {\n\t\t\t\t\t\ttop: { style: 'thin' },\n\t\t\t\t\t\tleft: { style: 'thin' },\n\t\t\t\t\t\tbottom: { style: 'thin' },\n\t\t\t\t\t\tright: { style: 'thin' },\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\t// Tăng currentRow lên số lượng test_orders hoặc ít nhất là 1\n\t\t\t\tcurrentRow += testOrders.length || 1;\n\t\t\t});\n\t\t}\n\n\t\t// Ghi giá trị cho ô\n\t\tworksheet.getCell(`B${currentRow + 2}`).value = 'Người bàn giao mẫu';\n\t\tworksheet.getCell(`B${currentRow + 2}`).alignment = {\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t};\n\t\tworksheet.getCell(`B${currentRow + 6}`).value = '';\n\t\tworksheet.getCell(`B${currentRow + 6}`).alignment = {\n\t\t\tvertical: 'middle',\n\t\t\thorizontal: 'center',\n\t\t};\n\t\tworksheet.mergeCells(`B${currentRow + 2}:C${currentRow + 2}`);\n\t\tworksheet.mergeCells(`B${currentRow + 6}:C${currentRow + 6}`);\n\n\t\tworksheet.getCell(`F${currentRow + 2}`).value = 'Người nhận bàn giao';\n\t\tworksheet.getCell(`F${currentRow + 2}`).alignment = {\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t};\n\t\tworksheet.mergeCells(`F${currentRow + 2}:G${currentRow + 2}`);\n\n\t\t// Áp dụng font Times New Roman và cỡ chữ 14 cho toàn bộ sheet\n\t\tworksheet.eachRow({ includeEmpty: true }, (row) => {\n\t\t\trow.eachCell({ includeEmpty: true }, (cell) => {\n\t\t\t\tconst currentFont = cell.font || {};\n\t\t\t\tcell.font = {\n\t\t\t\t\t...currentFont,\n\t\t\t\t\tname: 'Times New Roman',\n\t\t\t\t\tsize: 14,\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t\tworksheet.getCell('A2').font = { bold: true, name: 'Times New Roman', size: 20 }; // Font chữ\n\n\t\t// Tạo buffer chứa tệp Excel\n\t\tconst excelBuffer = await workbook.xlsx.writeBuffer();\n\n\t\t// Đặt header và payload\n\t\tmsg.req.headers = {\n\t\t\t'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\t\t\t'Content-Disposition': 'attachment; filename=sample.xlsx',\n\t\t};\n\t\tmsg.payload = excelBuffer; // Gửi buffer\n\n\t\treturn msg;\n\n\t} catch (error) {\n\t\tnode.warn('Error generating Excel file:' +  error);\n\t}\n}\n\ntry {\n\tmsg = await createAndWriteExcel();\n\tnode.warn(msg);\n\treturn msg;\n} catch (error) {\n\tnode.warn(error);\n};\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "ExcelJS",
                "module": "exceljs"
            }
        ],
        "x": 1450,
        "y": 160,
        "wires": [
            [
                "61e76c504459f143"
            ]
        ]
    },
    {
        "id": "61e76c504459f143",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1650,
        "y": 160,
        "wires": []
    },
    {
        "id": "45687c07e9aa99a9",
        "type": "http in",
        "z": "46183d332de8b18f",
        "name": "GET: excel_sample_receipt",
        "url": "/api:hrFfPpfK/excel_sample_receipt/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 1170,
        "y": 120,
        "wires": [
            [
                "98ae3de7c2a3b68f"
            ]
        ]
    },
    {
        "id": "98ae3de7c2a3b68f",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "generate Sample Receipt Excel",
        "func": "const axios = global.get('axios')\nnode.warn(\"API hit: generate Sample Receipt Excel\")\n\nasync function fetchData(id) {\n\ttry {\n\t\tconst response = await axios.get('https://xn.irdop.org/api:hrFfPpfK/receipt_detail/_get/receipt/' + id, {\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t// client: getCookies...\n\t\t\t\tauthorization: msg.req.headers.authorization,\n\t\t\t},\n\t\t});\n\t\treturn response.data;\n\t} catch (error) {\n\t\tconsole.error('Error fetching data:', error);\n\t}\n}\n\nfunction getDateFormatted(timestamp) {\n\tconst today = timestamp ? new Date(timestamp) : new Date();\n\tconst day = String(today.getDate()).padStart(2, '0');\n\tconst month = String(today.getMonth() + 1).padStart(2, '0'); // Tháng bắt đầu từ 0\n\tconst year = today.getFullYear();\n\treturn `${day}-${month}-${year}`;\n}\n\nasync function createAndWriteExcel() {\n\t/**\n\t * Tạo file Excel, ghi dữ liệu và chèn hình ảnh vào một ô.\n\t *\n\t * @param {string} fileName - Tên file Excel sẽ được tạo (bao gồm đuôi .xlsx).\n\t * @param {Array<Array>} data - Dữ liệu cần ghi vào file Excel, mỗi phần tử là một hàng.\n\t * @param {string} imagePath - Đường dẫn đến hình ảnh cần chèn.\n\t */\n\ttry {\n\t\t// Tạo một workbook mới\n\t\tconst workbook = new ExcelJS.Workbook();\n\t\t// Sheet 1: Tiếp nhận mẫu\n\t\tconst worksheet = workbook.addWorksheet('Tiếp nhận mẫu');\n\n\t\t// Điều chỉnh kích thước cột\n\t\tworksheet.columns = [\n\t\t\t{ width: 40 / 7.776 }, // Cột A\n\t\t\t{ width: 160 / 7.776 }, // Cột B\n\t\t\t{ width: 90 / 7.776 }, // Cột C\n\t\t\t{ width: 150 / 7.776 }, // Cột D\n\t\t\t{ width: 240 / 7.776 }, // Cột E\n\t\t\t{ width: 260 / 7.776 }, // Cột F\n\t\t\t{ width: 105 / 7.776 }, // Cột G\n\t\t];\n\n\t\t// // Dữ liệu ghi vào sheet\n\t\tconst dataReceipt = await fetchData(parseInt(msg.req.params.id));\n\n\t\tconst data = dataReceipt?.samples;\n\n\t\t// Hàng 1 : HEADER\n\t\tworksheet.mergeCells('B1:C1');\n\t\tworksheet.mergeCells('E1:G1');\n\n\t\tworksheet.getCell('E1').alignment = {\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t};\n\t\tworksheet.getCell('E1').value = `CỘNG HÒA XÃ HỘI CHỦ NGHĨA VIỆT NAM\\nĐộc lập - Tự do - Hạnh phúc`;\n\n\n\t\t// Tải hình ảnh từ URL dưới dạng buffer\n\t\tconst imageUrl = 'https://irdop.org/wp-content/uploads/2024/07/IRDOP-LOGO-2710-02-2.png';\n\t\tconst response = await axios.get(imageUrl, { responseType: 'arraybuffer' });\n\t\tconst imageBuffer = Buffer.from(response.data, 'binary');\n\n\t\t// Chèn hình ảnh vào ô C1\n\t\tconst imageId = workbook.addImage({\n\t\t\tbuffer: imageBuffer,\n\t\t\textension: 'png',\n\t\t});\n\n\t\tworksheet.addImage(imageId, {\n\t\t\ttl: { col: 1, row: 0 }, // Vị trí góc trên bên trái (ô B1)\n\t\t\text: { width: 196, height: 60 }, // Kích thước hình ảnh\n\t\t});\n\n\t\tworksheet.getRow(1).height = 45; // Chiều cao hàng 1\n\n\t\tworksheet.getCell('A2').value = 'PHIẾU TIẾP NHẬN MẪU';\n\t\tworksheet.mergeCells('A2:G2'); // Merge cell\n\t\tworksheet.getCell('A2').alignment = {\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t}; // Alignment\n\n\t\tworksheet.getRow(2).height = 60; // Chiều cao hàng 2 : Title\n\n\t\t// Hàng 3 >>\n\t\tworksheet.getCell('A3').value = '1.';\n\t\tworksheet.getCell('B3').value = 'Số phiếu yêu cầu đến:';\n\t\tworksheet.mergeCells('B3:C3');\n\t\tworksheet.getCell('D3').font = {bold:true};\n\t\tworksheet.getCell('D3').alignment = {\n\t\t\thorizontal: 'left',\n\t\t};\n\t\tworksheet.getCell('A3').font = { bold: true };\n\t\tworksheet.getCell('B3').font = { bold: true };\n\t\tconst receipt_date =  getDateFormatted(dataReceipt.created_at).split('-'); // DD,MM,YY\n\t\tworksheet.getCell('E3').value = '    Ngày ' + receipt_date[0] + ' tháng ' + receipt_date[1] + ' năm '+ receipt_date[2];\n\t\tworksheet.mergeCells('E3:G3');\n\n\t\tworksheet.getCell('B4').value = 'Mã tiếp nhận mẫu: ';\n\t\tworksheet.mergeCells('C4:D4');\n\t\tworksheet.getCell('C4').value = dataReceipt.receipt_uid;\n\t\tworksheet.getCell('C4').font = { bold: true };\n\t\tworksheet.getCell('C4').alignment = {\n\t\t\thorizontal: 'right',\n\t\t};\n\t\tworksheet.getCell('E4').value = '    Ngày tiếp nhận mẫu: ' + `${receipt_date[0]}/${receipt_date[1]}/${receipt_date[2]}`;\n\t\tworksheet.mergeCells('E4:G4');\n\t\tworksheet.getRow(4).height = 18.75;\n\n\t\tworksheet.getCell('A6').value = '  1.1 Thông tin khách hàng:';\n\t\tworksheet.mergeCells('A6:C6');\n\t\tworksheet.getCell('A6').font = { italic: true };\n\n\t\tworksheet.getCell('B7').value = 'Tên cơ sở, người yêu cầu thử nghiệm: ' + dataReceipt.client.client_name;\n\t\tworksheet.mergeCells('B7:G7');\n\t\t\n\t\tworksheet.getCell('B8').value = 'Địa chỉ: ' + dataReceipt.client.address;\n\t\tworksheet.mergeCells('B8:G8');\n\n\t\tworksheet.getCell('B9').value = 'MST/CCCD: ' + dataReceipt.client.legal_id;\n\t\tworksheet.mergeCells('B9:G9');\n\n\t\tworksheet.getCell('A11').value = '  1.2 Người gửi mẫu: ';\n\t\tworksheet.mergeCells('A11:B11');\n\t\tworksheet.getCell('C11').value = dataReceipt.contact_person_name;\n\t\tworksheet.mergeCells('C11:G11');\n\t\tworksheet.getCell('A11').font = { italic: true };\n\t\tworksheet.getCell('C11').font = { italic: true };\n\n\t\tworksheet.getCell('B12').value = 'SDT: '+ dataReceipt.contact_person_phone;\n\t\tworksheet.mergeCells('B12:E12');\n\t\tworksheet.getCell('F12').value = 'Email*: '+ dataReceipt.contact_person_email;\n\t\tworksheet.mergeCells('F12:G12');\n\t\tworksheet.getCell('B13').value = 'CCCD: ';\n\t\tworksheet.mergeCells('B13:E13');\n\t\tworksheet.getCell('F13').value = 'Ngày gửi mẫu: ';\n\t\tworksheet.mergeCells('F13:G13');\n\n\t\tworksheet.getCell('A15').value = '  1.3 Người nhận mẫu: ' + dataReceipt.receipt_by_user.name;\n\t\tworksheet.mergeCells('A15:G15');\n\t\tworksheet.getCell('A15').font = { italic: true };\n\n\t\tworksheet.getCell('B16').value = 'Tài liệu kèm theo: ';\n\t\tworksheet.mergeCells('B16:G16');\n\n\t\tworksheet.getCell('A18').value = '2.';\n\t\tworksheet.getCell('B18').value = 'Ngày hẹn trả kết quả dự kiến:';\n\t\tworksheet.mergeCells('B18:D18');\n\t\tworksheet.getCell('A18').font = { bold: true };\n\t\tworksheet.getCell('B18').font = { bold: true };\n\t\tworksheet.mergeCells('E18:G18');\n\n\t\tworksheet.getCell('A20').value = '3.';\n\t\tworksheet.getCell('B20').value = 'Thông tin đăng ký thử nghiệm (mẫu):';\n\t\tworksheet.mergeCells('B20:G20');\n\t\tworksheet.getCell('A20').font = { bold: true };\n\t\tworksheet.getCell('B20').font = { bold: true };\n\t\t// A7:H7 Title\n\t\tconst titleCell = ['A22', 'B22', 'C22', 'D22', 'E22', 'F22', 'G22'];\n\t\tconst titleValue = [\n\t\t\t'TT',\n\t\t\t'Thông tin mẫu',\n\t\t\t'Số lượng mẫu',\n\t\t\t'Mô tả khi nhận',\n\t\t\t'Chỉ tiêu yêu cầu kiểm nghiệm',\n\t\t\t'Phương pháp thử',\n\t\t\t'Ghi chú',\n\t\t];\n\t\ttitleCell.forEach((cell, index) => {\n\t\t\tworksheet.getCell(cell).value = titleValue[index];\n\t\t\tworksheet.getCell(cell).font = { italic: true };\n\t\t\tworksheet.getCell(cell).alignment = {\n\t\t\t\thorizontal: 'center',\n\t\t\t\tvertical: 'middle',\n\t\t\t};\n\t\t\tworksheet.getCell(cell).border = {\n\t\t\t\ttop: { style: 'thin' },\n\t\t\t\tleft: { style: 'thin' },\n\t\t\t\tbottom: { style: 'thin' },\n\t\t\t\tright: { style: 'thin' },\n\t\t\t};\n\t\t});\n\n\t\t// Ghi dữ liệu vào sheet\n\t\tlet currentRow = 23;\n\t\tif (data.length > 0) {\n\t\t\tdata.forEach((sample, index) => {\n\t\t\t\tworksheet.getCell(`A${currentRow}`).value = index + 1;\n\t\t\t\tworksheet.getCell(`B${currentRow}`).value = sample?.sample_name;\n\t\t\t\tworksheet.getCell(`C${currentRow}`).value = sample?.sample_qty;\n\t\t\t\tworksheet.getCell(`D${currentRow}`).value = sample?.sample_desc;\n\n\t\t\t\t// Kiểm tra nếu test_orders tồn tại và là một mảng\n\t\t\t\tconst testOrders = sample.test_orders ?? [];\n\t\t\t\ttestOrders.forEach((test_order, testIndex) => {\n\t\t\t\t\tworksheet.getCell(`E${currentRow + testIndex}`).value = test_order?.test_name;\n\t\t\t\t\tworksheet.getCell(`F${currentRow + testIndex}`).value = test_order?.protocol?.code;\n\t\t\t\t\tconst dataCell = [`E${currentRow + testIndex}`, `F${currentRow + testIndex}`];\n\t\t\t\t\tdataCell.forEach((cell) => {\n\t\t\t\t\t\tworksheet.getCell(cell).border = {\n\t\t\t\t\t\t\ttop: { style: 'thin' },\n\t\t\t\t\t\t\tleft: { style: 'thin' },\n\t\t\t\t\t\t\tbottom: { style: 'thin' },\n\t\t\t\t\t\t\tright: { style: 'thin' },\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t// Gộp các ô nếu có test_orders\n\t\t\t\tif (testOrders.length > 0) {\n\t\t\t\t\tworksheet.mergeCells(`A${currentRow}:A${currentRow + testOrders.length - 1}`);\n\t\t\t\t\tworksheet.mergeCells(`B${currentRow}:B${currentRow + testOrders.length - 1}`);\n\t\t\t\t\tworksheet.mergeCells(`C${currentRow}:C${currentRow + testOrders.length - 1}`);\n\t\t\t\t\tworksheet.mergeCells(`D${currentRow}:D${currentRow + testOrders.length - 1}`);\n\t\t\t\t\tworksheet.mergeCells(`G${currentRow}:G${currentRow + testOrders.length - 1}`);\n\t\t\t\t}\n\n\t\t\t\t// Lấy các ô merge để căn lề\n\t\t\t\tconst cells = [`A${currentRow}`, `B${currentRow}`, `C${currentRow}`, `D${currentRow}`, `G${currentRow}`];\n\t\t\t\tcells.forEach((cell) => {\n\t\t\t\t\tworksheet.getCell(cell).alignment = {\n\t\t\t\t\t\thorizontal: 'center',\n\t\t\t\t\t\tvertical: 'middle',\n\t\t\t\t\t};\n\t\t\t\t\tworksheet.getCell(cell).border = {\n\t\t\t\t\t\ttop: { style: 'thin' },\n\t\t\t\t\t\tleft: { style: 'thin' },\n\t\t\t\t\t\tbottom: { style: 'thin' },\n\t\t\t\t\t\tright: { style: 'thin' },\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\t// Tăng currentRow lên số lượng test_orders hoặc ít nhất là 1\n\t\t\t\tcurrentRow += testOrders.length || 1;\n\t\t\t});\n\t\t}\n\n\t\t// Ghi giá trị 5.\n\t\tworksheet.getCell(`A${currentRow + 1}`).value = '4.';\n\t\tworksheet.getCell(`B${currentRow + 1}`).value = 'Thông tin liên hệ: ';\n\t\tworksheet.mergeCells(`B${currentRow + 1}:G${currentRow + 1}`);\n\t\tworksheet.getCell(`A${currentRow + 1}`).font = { bold: true };\n\t\tworksheet.getCell(`B${currentRow + 1}`).font = { bold: true };\n\n\t\tworksheet.getCell(`B${currentRow + 2}`).value = 'SDT: 024 355 35 355';\n\t\tworksheet.mergeCells(`B${currentRow + 2}:G${currentRow + 2}`);\n\n\t\tworksheet.getCell(`B${currentRow + 3}`).value = 'Email: kiemnghiem@irdop.org';\n\t\tworksheet.mergeCells(`B${currentRow + 3}:G${currentRow + 3}`);\n\n\t\tworksheet.getCell(`A${currentRow + 5}`).value = 'Phòng dịch vụ khách hàng';\n\t\tworksheet.mergeCells(`A${currentRow + 5}:D${currentRow + 5}`);\n\t\tworksheet.getCell(`A${currentRow + 5}`).font = { bold: true };\n\t\tworksheet.getCell(`A${currentRow + 5}`).alignment = {\n\t\t\thorizontal: 'center',\n\t\t};\n\t\tworksheet.getCell(`F${currentRow + 5}`).value = 'Đại diện gửi mẫu';\n\t\tworksheet.mergeCells(`F${currentRow + 5}:G${currentRow + 5}`);\n\t\tworksheet.getCell(`F${currentRow + 5}`).font = { bold: true };\n\t\tworksheet.getCell(`F${currentRow + 5}`).alignment = {\n\t\t\thorizontal: 'center',\n\t\t};\n\n\t\tworksheet.getCell(`A${currentRow + 6}`).value = '(Người nhận mẫu ký tên và ghi rõ họ tên)';\n\t\tworksheet.mergeCells(`A${currentRow + 6}:D${currentRow + 6}`);\n\t\tworksheet.getCell(`A${currentRow + 6}`).alignment = {\n\t\t\thorizontal: 'center',\n\t\t};\n\n\t\tworksheet.getCell(`A${currentRow + 11}`).value = dataReceipt.receipt_by_user.name;\n\t\tworksheet.mergeCells(`A${currentRow + 11}:D${currentRow + 11}`);\n\t\tworksheet.getCell(`A${currentRow + 11}`).alignment = {\n\t\t\thorizontal: 'center',\n\t\t};\n\n\t\tworksheet.getCell(`F${currentRow + 11}`).value = '(Theo phiếu yêu cầu đính kèm)';\n\t\tworksheet.mergeCells(`F${currentRow + 11}:G${currentRow + 11}`);\n\t\tworksheet.getCell(`F${currentRow + 11}`).alignment = {\n\t\t\thorizontal: 'center',\n\t\t};\n\n\t\t// Áp dụng font Times New Roman và cỡ chữ 14 cho toàn bộ sheet\n\t\tworksheet.eachRow({ includeEmpty: true }, (row) => {\n\t\t\trow.eachCell({ includeEmpty: true }, (cell) => {\n\t\t\t\tconst currentFont = cell.font || {};\n\t\t\t\tcell.font = {\n\t\t\t\t\t...currentFont,\n\t\t\t\t\tname: 'Times New Roman',\n\t\t\t\t\tsize: 14,\n\t\t\t\t};\n\t\t\t\tconst currentAlignment = cell.alignment || {};\n\t\t\t\tcell.alignment = {\n\t\t\t\t\t...currentAlignment,\n\t\t\t\t\twrapText: true,\n\t\t\t\t\tvertical: 'middle',\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t\tworksheet.getCell('E1').font = { bold: true, name: 'Times New Roman', size: 16 }; // Font chữ\n\t\tworksheet.getCell('A2').font = { bold: true, name: 'Times New Roman', size: 20 }; // Font chữ\n\t\t\n\t\t// Biên bản bàn giao\n\t\tconst sheet2  = workbook.addWorksheet ('Biên bản bàn giao mẫu');\n\n\t\t// Hàng 1 title\n\t\tsheet2.getCell('D1').value = `VIỆN NGHIÊN CỨU VÀ PHÁT TRIỂN SẢN PHẨM THIÊN NHIÊN\n        176 Phùng Khoang, Trung Văn, Nam Từ Liêm, Hà Nội\n        Phòng phân tích - Kiểm nghiệm`;\n\n\t\tsheet2.mergeCells('D1:G1');\n\n\t\tsheet2.getCell('D1').alignment = {\n\t\t\twrapText: true,\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t};\n\t\tsheet2.getCell('D1').font = { bold: true };\n\n\t\t['C1', 'D1'].forEach((cell) => {\n\t\t\tsheet2.getCell(cell).border = {\n\t\t\t\ttop: { style: 'thick' },\n\t\t\t\tleft: { style: 'thick' },\n\t\t\t\tbottom: { style: 'thick' },\n\t\t\t\tright: { style: 'thick' },\n\t\t\t};\n\t\t});\n\n\t\t// Tải hình ảnh từ URL dưới dạng buffer\n\t\tconst imageUrl2 = 'https://irdop.org/wp-content/uploads/2024/07/IRDOP-LOGO-2710-02-2.png';\n\t\tconst response2 = await axios.get(imageUrl2, { responseType: 'arraybuffer' });\n\t\tconst imageBuffer2 = Buffer.from(response2.data, 'binary');\n\n\t\t// Chèn hình ảnh vào ô C1\n\t\tconst imageId2 = workbook.addImage({\n\t\t\tbuffer: imageBuffer,\n\t\t\textension: 'png',\n\t\t});\n\n\t\tsheet2.addImage(imageId2, {\n\t\t\ttl: { col: 2.18, row: 0.283 }, // Vị trí góc trên bên trái (ô C1)\n\t\t\text: { width: 229, height: 70 }, // Kích thước hình ảnh\n\t\t});\n\n\t\tsheet2.getRow(1).height = 60; // Chiều cao hàng 1\n\n\t\tsheet2.getCell('A2').value = 'BIÊN BẢN BÀN GIAO MẪU THỬ NỘI BỘ';\n\t\tsheet2.mergeCells('A2:H2'); // Merge cell\n\t\tsheet2.getCell('A2').alignment = {\n\t\t\twrapText: true,\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t}; // Alignment\n\n\t\tsheet2.getRow(2).height = 60; // Chiều cao hàng 2\n\n\t\tsheet2.getCell('B3').value = 'Thông tin mẫu đến';\n\t\tsheet2.getCell('D3').value = '';\n\t\tsheet2.mergeCells('D3:E3');\n\t\tsheet2.getCell('F3').value = 'Ngày bàn giao mẫu';\n\t\tsheet2.getCell('G3').value = getDateFormatted(dataReceipt.created_at);\n\t\tsheet2.mergeCells('G3:H3');\n\t\tsheet2.getCell('B4').value = 'Người bàn giao mẫu thử ( thuộc p. Dịch vụ)';\n\t\tsheet2.getCell('D4').value = dataReceipt.receipt_by_user.name;\n\t\tsheet2.mergeCells('D4:E4');\n\t\tsheet2.getCell('F4').value = 'Ngày bàn giao mẫu cho lab';\n\t\tsheet2.getCell('G4').value = getDateFormatted(dataReceipt.created_at);\n\t\tsheet2.mergeCells('G4:H4');\n\n\t\tsheet2.getCell('A6').value = 'Danh mục bàn giao các mẫu giao: trong bảng sau';\n\t\tsheet2.getCell('A6').font = { bold: true };\n\n\t\t// Điều chỉnh kích thước cột\n\t\tsheet2.columns = [\n\t\t\t{ width: 40 / 7.776 }, // Cột A\n\t\t\t{ width: 160 / 7.776 }, // Cột B\n\t\t\t{ width: 275 / 7.776 }, // Cột C\n\t\t\t{ width: 125 / 7.776 }, // Cột D\n\t\t\t{ width: 375 / 7.776 }, // Cột E\n\t\t\t{ width: 325 / 7.776 }, // Cột F\n\t\t\t{ width: 150 / 7.776 }, // Cột G\n\t\t\t{ width: 200 / 7.776 }, // Cột H\n\t\t];\n\n\t\t// A7:H7 Title\n\t\tconst titleCell2 = ['A7', 'B7', 'C7', 'D7', 'E7', 'F7', 'G7', 'H7'];\n\t\tconst titleValue2 = [\n\t\t\t'TT',\n\t\t\t'Mã mẫu',\n\t\t\t'Tên mẫu',\n\t\t\t'Số lượng mẫu',\n\t\t\t'Chỉ tiêu',\n\t\t\t'Phương pháp thử',\n\t\t\t'Ngày trả kết quả',\n\t\t\t'Người thực hiện chính',\n\t\t];\n\t\ttitleCell2.forEach((cell, index) => {\n\t\t\tsheet2.getCell(cell).value = titleValue2[index];\n\t\t\tsheet2.getCell(cell).font = { bold: true };\n\t\t\tsheet2.getCell(cell).alignment = {\n\t\t\t\twrapText: true,\n\t\t\t\thorizontal: 'center',\n\t\t\t\tvertical: 'middle',\n\t\t\t};\n\t\t\tsheet2.getCell(cell).border = {\n\t\t\t\ttop: { style: 'thin' },\n\t\t\t\tleft: { style: 'thin' },\n\t\t\t\tbottom: { style: 'thin' },\n\t\t\t\tright: { style: 'thin' },\n\t\t\t};\n\t\t});\n\n\t\t// Ghi dữ liệu vào sheet\n\t\tlet sheer2CurrentRow = 8;\n\t\tif (data.length > 0) {\n\t\t\tdata.forEach((sample, index) => {\n\t\t\t\tsheet2.getCell(`A${sheer2CurrentRow}`).value = index + 1;\n\t\t\t\tsheet2.getCell(`B${sheer2CurrentRow}`).value = sample?.sample_uid;\n\t\t\t\tsheet2.getCell(`C${sheer2CurrentRow}`).value = sample?.sample_name;\n\t\t\t\tsheet2.getCell(`D${sheer2CurrentRow}`).value = sample?.sample_qty;\n\n\t\t\t\t// Kiểm tra nếu test_orders tồn tại và là một mảng\n\t\t\t\tconst testOrders = sample.test_orders ?? [];\n\t\t\t\ttestOrders.forEach((test_order, testIndex) => {\n\t\t\t\t\tsheet2.getCell(`E${sheer2CurrentRow + testIndex}`).value = test_order?.test_name;\n\t\t\t\t\tsheet2.getCell(`F${sheer2CurrentRow + testIndex}`).value = test_order?.protocol?.code;\n\t\t\t\t\tsheet2.getCell(`G${sheer2CurrentRow + testIndex}`).value = test_order?.result_deadline;\n\t\t\t\t\tsheet2.getCell(`H${sheer2CurrentRow + testIndex}`).value = test_order?.tested_by?.name;\n\t\t\t\t\tconst dataCell = [\n\t\t\t\t\t\t`E${sheer2CurrentRow + testIndex}`,\n\t\t\t\t\t\t`F${sheer2CurrentRow + testIndex}`,\n\t\t\t\t\t\t`G${sheer2CurrentRow + testIndex}`,\n\t\t\t\t\t\t`H${sheer2CurrentRow + testIndex}`,\n\t\t\t\t\t];\n\t\t\t\t\tdataCell.forEach((cell) => {\n\t\t\t\t\t\tsheet2.getCell(cell).alignment = {\n\t\t\t\t\t\t\twrapText: true,\n\t\t\t\t\t\t\tvertical: 'middle'\n\t\t\t\t\t\t};\t\t\t\t\t\t\n\t\t\t\t\t\tsheet2.getCell(cell).border = {\n\t\t\t\t\t\t\ttop: { style: 'thin' },\n\t\t\t\t\t\t\tleft: { style: 'thin' },\n\t\t\t\t\t\t\tbottom: { style: 'thin' },\n\t\t\t\t\t\t\tright: { style: 'thin' },\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t// Gộp các ô nếu có test_orders\n\t\t\t\tif (testOrders.length > 0) {\n\t\t\t\t\tsheet2.mergeCells(`A${sheer2CurrentRow}:A${sheer2CurrentRow + testOrders.length - 1}`);\n\t\t\t\t\tsheet2.mergeCells(`B${sheer2CurrentRow}:B${sheer2CurrentRow + testOrders.length - 1}`);\n\t\t\t\t\tsheet2.mergeCells(`C${sheer2CurrentRow}:C${sheer2CurrentRow + testOrders.length - 1}`);\n\t\t\t\t\tsheet2.mergeCells(`D${sheer2CurrentRow}:D${sheer2CurrentRow + testOrders.length - 1}`);\n\t\t\t\t}\n\n\t\t\t\tconst cells = [`A${sheer2CurrentRow}`, `B${sheer2CurrentRow}`, `C${sheer2CurrentRow}`, `D${sheer2CurrentRow}`];\n\t\t\t\tcells.forEach((cell) => {\n\t\t\t\t\tsheet2.getCell(cell).alignment = {\n\t\t\t\t\t\twrapText: true,\n\t\t\t\t\t\thorizontal: 'center',\n\t\t\t\t\t\tvertical: 'middle',\n\t\t\t\t\t};\n\t\t\t\t\tsheet2.getCell(cell).border = {\n\t\t\t\t\t\ttop: { style: 'thin' },\n\t\t\t\t\t\tleft: { style: 'thin' },\n\t\t\t\t\t\tbottom: { style: 'thin' },\n\t\t\t\t\t\tright: { style: 'thin' },\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\t// Tăng sheer2CurrentRow lên số lượng test_orders hoặc ít nhất là 1\n\t\t\t\tsheer2CurrentRow += testOrders.length || 1;\n\t\t\t});\n\t\t}\n\n\t\t// Ghi giá trị cho ô\n\t\tsheet2.getCell(`B${sheer2CurrentRow + 2}`).value = 'Người bàn giao mẫu';\n\t\tsheet2.getCell(`B${sheer2CurrentRow + 2}`).alignment = {\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t};\n\t\tsheet2.getCell(`B${sheer2CurrentRow + 2}`).font = { bold: true};\n\n\t\tsheet2.getCell(`B${sheer2CurrentRow + 6}`).value = '';\n\t\tsheet2.getCell(`B${sheer2CurrentRow + 6}`).alignment = {\n\t\t\tvertical: 'middle',\n\t\t\thorizontal: 'center',\n\t\t};\n\t\tsheet2.mergeCells(`B${sheer2CurrentRow + 2}:C${sheer2CurrentRow + 2}`);\n\n\t\tsheet2.getCell(`B${sheer2CurrentRow + 6}`).value = dataReceipt.receipt_by_user.name;\n\t\tsheet2.mergeCells(`B${sheer2CurrentRow + 6}:C${sheer2CurrentRow + 6}`);\n\n\t\tsheet2.getCell(`F${sheer2CurrentRow + 2}`).value = 'Người nhận bàn giao';\n\t\tsheet2.getCell(`F${sheer2CurrentRow + 2}`).alignment = {\n\t\t\thorizontal: 'center',\n\t\t\tvertical: 'middle',\n\t\t};\n\t\tsheet2.getCell(`F${sheer2CurrentRow + 2}`).font = { bold: true }\n\t\tsheet2.mergeCells(`F${sheer2CurrentRow + 2}:G${sheer2CurrentRow + 2}`);\n\n\t\t// Áp dụng font Times New Roman và cỡ chữ 14 cho toàn bộ sheet\n\t\tsheet2.eachRow({ includeEmpty: true }, (row) => {\n\t\t\trow.eachCell({ includeEmpty: true }, (cell) => {\n\t\t\t\tconst currentFont = cell.font || {};\n\t\t\t\tcell.font = {\n\t\t\t\t\t...currentFont,\n\t\t\t\t\tname: 'Times New Roman',\n\t\t\t\t\tsize: 14,\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t\tsheet2.getCell('A2').font = { bold: true, name: 'Times New Roman', size: 20 }; // Font chữ\n\n\t\t// Tạo buffer chứa tệp Excel\n\t\tconst excelBuffer = await workbook.xlsx.writeBuffer();\n\n\t\t// Đặt header và payload\n\t\tmsg.headers = {\n\t\t\t'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\t\t\t'Content-Disposition': `attachment; filename=\"${dataReceipt.receipt_uid}.xlsx\"`,\n\t\t};\n\t\tmsg.payload = excelBuffer; // Gửi buffer thay vì stream\n\n\t\tnode.warn(`Export excel: ${dataReceipt.receipt_uid}.xlsx`);\n\n\t\treturn msg;\n\t\t\n\t} catch (error) {\n\t\tconsole.error('Error generating Excel file:', error);\n\t}\n}\n\n\ntry {\n\tmsg = await createAndWriteExcel();\n\treturn msg;\n} catch (error) {\n\tnode.warn(error);\n};\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "ExcelJS",
                "module": "exceljs"
            }
        ],
        "x": 1450,
        "y": 120,
        "wires": [
            [
                "2024c039c239926c"
            ]
        ]
    },
    {
        "id": "2024c039c239926c",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1650,
        "y": 120,
        "wires": []
    },
    {
        "id": "ba04a21b30240d1e",
        "type": "inject",
        "z": "46183d332de8b18f",
        "d": true,
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "180",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 230,
        "y": 740,
        "wires": [
            [
                "f4dbf19ea679ed74"
            ]
        ]
    },
    {
        "id": "f4dbf19ea679ed74",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "refreshReceiptCache",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\n// Recent Receipt Cache is updating, wait till it done\nif(Date.now() - cache.recentReceipts.cached_at < 2 * 60 * 1000){        \n    // clear queue xano req\n    xano.flag = false;\n    return msg;\n}\n\nnode.warn('API hit')\n\nwhile(xano.flag === true){\n    await new Promise( wait => setTimeout(wait, 2000)) // 2s\n}\n\ntry {\n    const timeStart = Date.now();       // time start\n    let recentReceipts;                 // Return value for msg.payload\n\n    // setflag true\n    xano.flag = true;\n    node.warn('Refresh Recent Receipts');\n    // Get lastest data\n    if (xano.bridge_api) {      // GET from xano\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": global.get('authToken')\n        }\n        const xanoResponse = await xano.get_recent_receipts(headers);\n        if (xanoResponse.status === 200) {\n            recentReceipts = xanoResponse.data;\n        }\n    }\n    else {                      // RED DB access\n        recentReceipts = await Receipt.recentReceipts();\n    }\n\n    if (recentReceipts) {       // Cache the result\n        cache.recentReceipts = {\n            value: recentReceipts,\n            cached_at: Date.now()\n        };\n    }\n\n    // Time Cache Filled\n    const filledTime = (Date.now() - timeStart) / 1000;\n    node.warn(`Recent Receipts: Cache Filled (${filledTime}s)`);\n    node.warn(cache.recentReceipts);\n    xano.flag = false;\n    \n} catch (error) {\n    xano.flag = false;\n    node.warn('Recent receipt error: ' + error);\n    const errStack = error.stack;\n    node.warn(errStack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "66bfd28d72d778fa",
        "type": "inject",
        "z": "46183d332de8b18f",
        "d": true,
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.2",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 230,
        "y": 780,
        "wires": [
            [
                "2bd4797b269524dc"
            ]
        ]
    },
    {
        "id": "2bd4797b269524dc",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "function 5",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\n// Recent Receipt Cache is updating, wait till it done\nwhile(xano.flag === true){\n    await new Promise( wait => setTimeout(wait, 5000)) // 5s\n}\n\ntry {\n    if (xano.bridge_auth) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": global.get('authToken')\n        };\n        const authResponse = await xano.auth_me_employee(headers);\n        msg.payload = cache.recentReceipts.value;\n        node.warn(msg);\n    }\n    else {\n        // TODO: RED auth\n    }\n} catch (error) {\n    node.warn(error);\n};",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 780,
        "wires": [
            []
        ]
    },
    {
        "id": "07a1f2e0af111f21",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "g": "90124c05cecd5787",
        "name": "GET: sample_detail",
        "url": "/api:hrFfPpfK/sample_detail/_get/sample/:sample_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 230,
        "y": 540,
        "wires": [
            [
                "090ebfb08a8ab273"
            ]
        ]
    },
    {
        "id": "090ebfb08a8ab273",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "90124c05cecd5787",
        "name": "getDetailSample",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\ntry {\n    /** 1. Try cache */\n    const detailSample_cache = cache.detailSample;\n    const expireTime = 4 * 60 * 1000; // 4 minutes\n    if (detailSample_cache && Date.now() - detailSample_cache.cached_at < expireTime) {\n        /** 1.1 Check auth */\n        if (xano.bridge_auth) {\n            const authResponse = await xano.auth_me_employee(msg.req.headers);\n            if (authResponse.status === 200) {\n                msg.payload = detailSample_cache.value;\n                node.warn(\"Detail Sample: get cache\");\n                return msg;\n            }\n        }\n        else {\n            // TODO: RED auth\n        }\n    }\n\n    // clear cache\n    cache.detailSample = undefined;\n\n    /** 2. Get latest data */\n    let sample;\n\n    if (xano.bridge_api) {      // Bridge Xano\n        node.warn(msg.req.headers);\n        const xanoResponse = await xano.get_detail_sample(msg.req.params,msg.req.headers);\n        if (xanoResponse.status === 200) {\n            sample = xanoResponse.data;\n            cache.detailSample = {\n                value: sample,\n                cached_at: Date.now()\n            };\n            node.warn(\"Detail sample: set cache\");\n        }\n        else {\n            throw new Error('Xano Auth API returned non-200 status');\n        }\n        \n    } else {\n        // Direct RED database access\n        // receipts = await Receipt.detailSample();\n    }\n\n    cache.detailSample = {\n        value: sample,\n        cached_at: Date.now()\n    };\n    msg.payload = sample;\n    return msg;\n\n} catch (error) {\n    node.warn('Recent receipt error: ' + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 540,
        "wires": [
            [
                "060cdca3bfae5f5b"
            ]
        ]
    },
    {
        "id": "060cdca3bfae5f5b",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "90124c05cecd5787",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 540,
        "wires": []
    },
    {
        "id": "8d7268b919feebd5",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "90124c05cecd5787",
        "name": "getProcessingSample",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\n// PRECAUTION: cache mechanism is not thread-safe and may cause race condition\n// PRECAUTION: processingSamples uses authToken as signature key.\n\nwhile(xano.flag_processing === true){\n    await new Promise( wait => setTimeout(wait, 5000)) // 5s\n}\n\ntry {\n    xano.flag_processing = true ;\n    let processingSamples;  // Return value for msg.payload\n\n    /** 1. AUTHENTICATION */\n    if (xano.bridge_auth) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        };\n        const authResponse = await xano.auth_me_employee(headers);\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. Try cache */\n    const userToken = msg.req.headers.authorization.split(' ')[1];\n    const expireTime = 5 * 60 * 1000; //5m cache\n\n    // FIND CACHE FOR THIS USER TOKEN\n    if (cache.processingSamples &&\n        userToken &&\n        cache.processingSamples[userToken] &&\n        cache.processingSamples[userToken].value &&\n        Date.now() - cache.processingSamples[userToken].cached_at < expireTime\n    ) {\n        node.warn('Cache Hit');\n        processingSamples = cache.processingSamples[userToken].value;\n    }\n\n    // FOUND NO CACHE FOR THIS USER TOKEN\n    else {\n        node.warn('Cache Miss');\n        const start = Date.now();\n        // CREATE NEW CACHE\n        if (!cache.processingSamples) cache.processingSamples = {};\n        cache.processingSamples[userToken] = {};\n\n        // GET LATEST DATA FROM XANO BRIDGE API\n        if (xano.bridge_api) {\n            const headers = {\n                accept: 'application/json',\n                authorization: msg.req.headers.authorization,\n            };\n\n            // SEND XANO REQUEST\n            const xanoResponse = await xano.get_processing_samples(headers);\n            if (xanoResponse.status === 200) {\n                processingSamples = xanoResponse.data;\n            }\n        }\n\n        // GET LATEST DATA FROM RED AUTH API\n        else {\n            // TODO: RED auth\n        }\n\n        // SET CACHE\n        cache.processingSamples[userToken] = {\n            value: processingSamples,\n            cached_at: Date.now()\n        };\n        const end = Date.now();\n        node.warn(`Cache Filled in ${(end - start)/1000}s`);\n    }\n\n    msg.payload = processingSamples;\n    msg.statusCode = 200;\n    xano.flag_processing = false;\n    return msg;\n\n} catch (error) {\n    xano.flag_processing = false;\n    node.warn(error.statusCode || error.response?.status || 500);\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 580,
        "wires": [
            [
                "fb3a0e2a0a704a0d"
            ]
        ]
    },
    {
        "id": "ad7bd9e2daa32fef",
        "type": "http in",
        "z": "46183d332de8b18f",
        "g": "90124c05cecd5787",
        "name": "GET: processing_samples",
        "url": "/api:FzsHe1z4/sample_mgr/get_processing_samples",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 250,
        "y": 580,
        "wires": [
            [
                "8d7268b919feebd5"
            ]
        ]
    },
    {
        "id": "fb3a0e2a0a704a0d",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "90124c05cecd5787",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 580,
        "wires": []
    },
    {
        "id": "1cb34f3ccb1d836b",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "g": "57283995a4e830fa",
        "name": "post new receit",
        "url": "/new_receipt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 220,
        "y": 260,
        "wires": [
            [
                "47f3cb2d817de769"
            ]
        ]
    },
    {
        "id": "47f3cb2d817de769",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "newReceipt",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { Receipt } = global.get(\"tables\");\n\ntry {\n    let receipt;            // Storing Created Receipt Object\n\n    /** 1. AUTHENTICATE */\n    if (xano.bridge_api) {\n        // This block is intentionally left blank\n        // If bridge_api is true, Authentication is alreadt done in Xano\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. CREATE RECORD */\n    if (xano.bridge_api) {  // Forward to xano\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            authorization: msg.req.headers.authorization,\n        };\n        const xanoResponse = await xano.post_create_receipt(\n            headers,\n            msg.req.body,\n        );\n        receipt = xanoResponse.data;\n    }\n    else {                  // USE Node-RED engine\n        // TODO: Auth\n        const newReceipt = msg.req.params.new_receipt;\n        // newReceipt = new Receipt.create(newReceipt)\n        // Post to Xano ... \n    }\n\n    /** 3. SET CACHE */\n    if (                    // Kiem tra neu new receipt chua them vao cache\n        receipt &&                                                          // receipt must exist to be added to cache\n        cache.recentReceipts &&                                             // cache must exist\n        cache.recentReceipts.value &&                                       // cache must have a value\n        (Date.now() - cache.recentReceipts.cached_at) < 4 * 60 * 1000 &&    // this cache must still be valid\n        cache.recentReceipts.value[0] &&                                    // there must be at least one receipt in the cache\n        cache.recentReceipts.value[0].receipt_uid !== receipt.receipt_uid   // The first receipt in cache is not the same as the new receipt\n    ) {\n        cache.recentReceipts.cached_at = Date.now();\n        cache.recentReceipts.value = [receipt, ...cache.recentReceipts.value];   // Add new receipt to the beginning of the array\n    }\n\n    /** 4. RETURN TO CLIENT */\n    msg.payload = receipt;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Create receipt error: \" + error);\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 260,
        "wires": [
            [
                "4440c61fceb80da0"
            ]
        ]
    },
    {
        "id": "4440c61fceb80da0",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 260,
        "wires": []
    },
    {
        "id": "c9dd0bee078610dd",
        "type": "http in",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "GET: recent_receipts",
        "url": "/api:hrFfPpfK/receipt_list/_get/recent_receipts",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 230,
        "y": 200,
        "wires": [
            [
                "11bbf920bc70be60"
            ]
        ]
    },
    {
        "id": "5ee6e7e6112b7d57",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 200,
        "wires": []
    },
    {
        "id": "99cd3462bc22c5a8",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "g": "57283995a4e830fa",
        "name": "GET: receipt_detail",
        "url": "/api:hrFfPpfK/receipt_detail/_get/receipt/:receipt_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 230,
        "y": 300,
        "wires": [
            [
                "2cb72e179fa185f8"
            ]
        ]
    },
    {
        "id": "2cb72e179fa185f8",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "getReceiptDetail",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\ntry {\n    /** 1. Try cache */\n    const detailReceipt_cache = cache.detailReceipt;\n    const expireTime = 4 * 60 * 1000; // 4 minutes\n    if (detailReceipt_cache && Date.now() - detailReceipt_cache.cached_at < expireTime) {\n        /** 1.1 Check auth */\n        if (xano.bridge_auth) {\n            const authResponse = await xano.auth_me_employee(msg.req.headers);\n            if (authResponse.status === 200) {\n                msg.payload = detailReceipt_cache.value;\n                node.warn(\"Detail Receipt: get cache\");\n                return msg;\n            }\n        }\n        else {\n            // TODO: RED auth\n        }\n    }\n\n    // clear cache\n    cache.detailReceipt = undefined;\n\n    /** 2. Get latest data */\n    let receipt;\n\n    if (xano.bridge_api) {      // Bridge Xano\n        node.warn(msg.req.headers);\n        const xanoResponse = await xano.get_detail_receipt(msg.req.params,msg.req.headers);\n        if (xanoResponse.status === 200) {\n            receipt = xanoResponse.data;\n            cache.detailReceipt = {\n                value: receipt,\n                cached_at: Date.now()\n            };\n            node.warn(\"Detail Receipt: set cache\");\n        }\n        else {\n            throw new Error('Xano Auth API returned non-200 status');\n        }\n        \n    } else {\n        // Direct RED database access\n        // receipts = await Receipt.detailReceipt();\n    }\n\n    cache.detailReceipt = {\n        value: receipt,\n        cached_at: Date.now()\n    };\n    msg.payload = receipt;\n    return msg;\n\n} catch (error) {\n    node.warn('Recent receipt error: ' + error);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 300,
        "wires": [
            [
                "bbe9b9eb9dd66dc6"
            ]
        ]
    },
    {
        "id": "bbe9b9eb9dd66dc6",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 300,
        "wires": []
    },
    {
        "id": "1ef57e1e3ad923f3",
        "type": "http in",
        "z": "46183d332de8b18f",
        "d": true,
        "g": "57283995a4e830fa",
        "name": "post new receit",
        "url": "/new_receipt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 220,
        "y": 340,
        "wires": [
            [
                "89a8e8326f42fe01"
            ]
        ]
    },
    {
        "id": "89a8e8326f42fe01",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "updateReceipt",
        "func": "const xano = global.get(\"xano\");\nconst cache = global.get(\"cache\");\nconst { Receipt } = global.get(\"tables\");\n\ntry {\n    let receipt;            // Storing Created Receipt Object\n\n    /** 1. AUTHENTICATE */\n    if (xano.bridge_api) {\n        // This block is intentionally left blank\n        // If bridge_api is true, Authentication is alreadt done in Xano\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. CREATE RECORD */\n    if (xano.bridge_api) {  // Forward to xano\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            authorization: msg.req.headers.authorization,\n        };\n        const xanoResponse = await xano.post_create_receipt(\n            headers,\n            msg.req.body,\n        );\n        receipt = xanoResponse.data;\n    }\n    else {                  // USE Node-RED engine\n        // TODO: Auth\n        const newReceipt = msg.req.params.new_receipt;\n        // newReceipt = new Receipt.create(newReceipt)\n        // Post to Xano ... \n    }\n\n    /** 3. SET CACHE */\n    if (                    // Kiem tra neu new receipt chua them vao cache\n        receipt &&                                                          // receipt must exist to be added to cache\n        cache.recentReceipts &&                                             // cache must exist\n        cache.recentReceipts.value &&                                       // cache must have a value\n        (Date.now() - cache.recentReceipts.cached_at) < 4 * 60 * 1000 &&    // this cache must still be valid\n        cache.recentReceipts.value[0] &&                                    // there must be at least one receipt in the cache\n        cache.recentReceipts.value[0].receipt_uid !== receipt.receipt_uid   // The first receipt in cache is not the same as the new receipt\n    ) {\n        cache.recentReceipts.cached_at = Date.now();\n        cache.recentReceipts.value = [receipt, ...cache.recentReceipts.value];   // Add new receipt to the beginning of the array\n    }\n\n    /** 4. RETURN TO CLIENT */\n    msg.payload = receipt;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(\"Create receipt error: \" + error);\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload =\n        error.message ||\n        error.response?.data?.message ||\n        \"Internal Server Error\";\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 340,
        "wires": [
            [
                "2654e3fc0cab17e1"
            ]
        ]
    },
    {
        "id": "2654e3fc0cab17e1",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 340,
        "wires": []
    },
    {
        "id": "2e004b1018baf7e7",
        "type": "http in",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "POST: Bulk Recetip",
        "url": "/api:hrFfPpfK/receipt_list/_get/bulk_receipts",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 230,
        "y": 380,
        "wires": [
            [
                "5719ec270d4ff6ae"
            ]
        ]
    },
    {
        "id": "5719ec270d4ff6ae",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "bulkReceipt",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\nif(xano.flag_bulk === true){\n    node.status({ fill:\"yellow\", shape:\"dot\", text:\"🤷🏼\" })\n    await new Promise( wait => setTimeout(wait, 5000)) // 2s\n}\nnode.status({ fill:\"green\", shape:\"dot\", text:\"🏃‍♀️\" })\n\ntry {\n    /** 1. AUTH */    \n    const timeStart = Date.now();\n\n    xano.flag_bulk = true;\n\n    if (xano.bridge_auth) {\n    const xano_headers = {\n        'Content-Type': 'application/json',\n        authorization: msg.req.headers.authorization,\n    }\n    const authResponse = await xano.auth_me_employee(xano_headers);\n    global.set('xano_headers', xano_headers);\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. GET DATA */\n    const receipt_ids = msg.req.body.receipt_ids;\n\n    const bulk_receipt = await Receipt.bulkGet(receipt_ids);\n\n    /** 4. RETURN */\n    msg.payload = bulk_receipt;\n    msg.statusCode = 200;\n    const filledTime = (Date.now() - timeStart) / 1000;\n    node.warn(`Bulk get ${bulk_receipt.length} receipts: (${filledTime}s)`);\n    xano.flag_bulk = false;\n    node.status({ fill:\"gray\", shape:\"ring\", text:\"OK\" })\n    return msg;\n} catch (error) {\n    xano.flag_bulk = false;\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 380,
        "wires": [
            [
                "3193afaf0ad7f95b"
            ]
        ]
    },
    {
        "id": "11bbf920bc70be60",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "getRecentReceipt",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\n// Recent Receipt Cache is updating, wait till it done\nnode.status({fill:\"green\",shape:\"ring\",text:\"hit\"});\n\nwhile(xano.flag === true){\n    node.status({fill:\"yellow\",shape:\"dot\",text:\"queing\"});\n    await new Promise( wait => setTimeout(wait, 5000)) // 5s\n}\n\nnode.status({fill:\"green\",shape:\"ring\",text:\"hit\"});\n\ntry {\n    // setflag true\n    xano.flag = true;\n\n    let recentReceipts;                 // Return value for msg.payload\n    const expireTime = 6 * 60 * 1000;   // 6 minutes cache expiration time\n\n    const timeStart = Date.now();\n    /** 1. AUTH */\n    if (xano.bridge_auth) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        };\n        const authResponse = await xano.auth_me_employee(headers);\n        if(authResponse.status === 200) global.set('authToken', msg.req.headers.authorization);\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. TRY CACHE */\n    if ( cache.recentReceipts &&\n        cache.recentReceipts.value &&\n        Date.now() - cache.recentReceipts.cached_at < expireTime ) {\n            //node.warn(\"Cache Hit\");\n            recentReceipts = cache.recentReceipts.value;\n    }\n\n    /** 3. CACHE MISS, get latest data */\n    else {\n        if (xano.bridge_api) {      // GET from xano\n            const headers = {\n                \"Content-Type\": \"application/json\",\n                \"authorization\": msg.req.headers.authorization\n            }\n            const xanoResponse = await xano.get_recent_receipts(headers);\n            if (xanoResponse.status === 200) {\n                recentReceipts = xanoResponse.data;\n            }\n        }\n        else {                      // RED DB access\n            recentReceipts = await Receipt.recentReceipts();\n        }\n\n        if (recentReceipts) {       // Cache the result\n            cache.recentReceipts = {\n                value: recentReceipts,\n                cached_at: Date.now()\n            };\n        }\n        // Time Cache Filled\n        const filledTime = (Date.now() - timeStart) / 1000;\n        node.warn(`Cache Filled (${filledTime}s)`);\n    }\n    \n    xano.flag = false;\n    /** 4. RETURN */\n    msg.payload = recentReceipts;\n    msg.statusCode = 200;\n\n    node.status({fill:\"gray\",shape:\"ring\",text:\"OK\"});\n    return msg;\n} catch (error) {\n    xano.flag = false;\n    node.warn('Recent receipt error: ' + error);\n    const errStack = error.stack;\n    node.warn(errStack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 200,
        "wires": [
            [
                "5ee6e7e6112b7d57"
            ]
        ]
    },
    {
        "id": "3193afaf0ad7f95b",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 380,
        "wires": []
    },
    {
        "id": "fd2e6cf46cdde1bd",
        "type": "http in",
        "z": "46183d332de8b18f",
        "name": "",
        "url": "/build_processing_sample",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 290,
        "y": 700,
        "wires": [
            [
                "97ca914892d0fded"
            ]
        ]
    },
    {
        "id": "97ca914892d0fded",
        "type": "function",
        "z": "46183d332de8b18f",
        "name": "function 7",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Sample } = global.get('tables');\n\n// PRECAUTION: cache mechanism is not thread-safe and may cause race condition\n\nwhile(xano.flag_processing === true){\n    await new Promise( wait => setTimeout(wait, 2000)) // 2s\n}\n\ntry {\n    let processingSamples;  // Return value for msg.payload\n\n    /** 1. AUTHENTICATION */\n    if (xano.bridge_auth) {\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": msg.req.headers.authorization\n        };\n        const authResponse = await xano.auth_me_employee(headers);\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. GET from DB */\n    const userToken = msg.req.headers.authorization.split(' ')[1];\n    xano.flag_processing = true ;                                   // TODO: Remove\n\n    // GET LATEST DATA FROM XANO BRIDGE API\n    processingSamples = await Sample.getProcessingSamples(userToken);\n\n    msg.payload = processingSamples;\n    msg.statusCode = 200;\n    xano.flag_processing = false;\n    return msg;\n} catch (error) {\n    xano.flag_processing = false;\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 700,
        "wires": [
            [
                "dc5e942be91e7b45"
            ]
        ]
    },
    {
        "id": "dc5e942be91e7b45",
        "type": "http response",
        "z": "46183d332de8b18f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 720,
        "y": 700,
        "wires": []
    },
    {
        "id": "d1051bd5a1a694ca",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "0ebdf399fafbbae5",
        "name": "create_batch_order",
        "func": "const table = global.get('tables');\nconst cache = global.get('cache');\n\n// API tạo hàng loạt receipt mới\ntry {\n    let orders = msg.req.body;                          // extract request order\n    let newOrdersInstances = [];                        // array of new order instances\n\n    if (!Array.isArray(orders)) orders = [orders];      // make sure request order is an array\n    orders.forEach(order => validateNewOrder(order));   // validate every orders, samples and analytes\n\n    // CREATING NEW ORDERS, SAMPLES AND ANALYTES\n    for (const order of orders) {\n        node.warn(`Creating Order ${orders.indexOf(order) + 1}...`);\n        const newOrderInstance = await createNewOrder(order);\n        newOrdersInstances.push(newOrderInstance);\n    }\n\n    // CONVERTING NEW ORDERS TO JSON XANO FORMAT\n    const newOrders = newOrdersInstances.map(async instance =>await instance.jsonFullXano());\n    const newOrdersFull = await Promise.all(newOrders);\n    node.warn(newOrdersFull);\n\n    // return receipt\n    msg.payload = newOrdersFull;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(error.stack);\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    return msg;\n}\n\n// validate new order from http request body\nfunction validateNewOrder(order) {\n    const tableHelper = table.tableHelper\n    tableHelper.receiptValidate(order, true);\n    \n    // validate samples and analytes\n    for (const sample of order.samples) {\n        tableHelper.sampleValidate(sample, true);           // validate sample\n        for (const analyte of sample.analytes) {\n            tableHelper.sampleAnalyteValidate(analyte, true);     // validate analyte\n        }\n    }\n}\n\nasync function createNewOrder(order) {\n    // CREATE A RECEIPT\n    const newReceipt = await table.Receipt.create(order);\n    node.warn(await newReceipt.json())\n\n    // CHECK IF RECEIPT IS CREATED\n    if (!newReceipt) {\n        const error = new Error('Unexpected error: Failed to create receipt');\n        error.statusCode = 500;\n        throw error;\n    }\n\n    // CREATE SAMPLES IN THE RECEIPT\n    if (Array.isArray(order.samples) && order.samples.length) {\n        for (const sample of order.samples) {\n            sample.sample_receipt_id = newReceipt.id;\n            const newSample = await table.Sample.create(sample);\n\n            // CHECK IF SAMPLE IS CREATED\n            if (!newSample) {\n                const error = new Error('Unexpected error: Failed to create sample ' + sample.sample_name + ' for receipt ' + newReceipt.id);\n                error.statusCode = 500;\n                throw error;\n            }\n\n            // CREATE ANALYTES IN THE SAMPLE\n            if (sample.analytes && Array.isArray(sample.analytes) && sample.analytes.length) {\n                for (const analyte of sample.analytes) {\n                    analyte.sample_receipt_id = newSample.id;\n                    analyte.sample_id = newSample.id;\n                    analyte.created_at = Date.now();\n                    await table.SampleAnalyte.create(analyte);\n                }\n            }\n        }\n    }\n\n    // RETURN FULL RECEIPT WITH SAMPLES AND ANALYTES\n    return await newReceipt;\n}\n\n/// input format\n/*\n[\n  {\n    ...receipt,\n    samples: [{\n        ...sample,\n        analytes: [{\n            ...analyte,\n          }\n        ]\n      }\n    ]\n  }\n]\n  */",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 60,
        "wires": [
            [
                "a9fde53619f580f5"
            ]
        ]
    },
    {
        "id": "56d3a89ac68c4146",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "searchReceipts",
        "func": "const xano = global.get('xano');\nconst cache = global.get('cache');\nconst { Receipt } = global.get('tables');\n\nnode.status({fill:\"green\",shape:\"ring\",text:\"Searching...\"});\nif(xano.flag_bulk === true){\n    node.status({fill:\"yellow\",shape:\"ring\",text:\"Queuing...\"})\n    await new Promise( wait => setTimeout(wait, 2000)) // 2s\n}\n\nnode.status({fill:\"green\",shape:\"ring\",text:\"Searching...\"});\n\ntry {\n    /** 1. AUTH */    \n    const timeStart = Date.now();\n\n    xano.flag_bulk = true;\n\n    if (xano.bridge_auth) {\n    const xano_headers = {\n        'Content-Type': 'application/json',\n        authorization: msg.req.headers.authorization,\n    }\n    const authResponse = await xano.auth_me_employee(xano_headers);\n    global.set('xano_headers', xano_headers);\n    }\n    else {\n        // TODO: RED auth\n    }\n\n    /** 2. GET DATA */\n    const query = msg.req.body.query;\n\n    const bulk_receipt = await Receipt.search(query);\n    node.warn({search_query: query, results: bulk_receipt});\n\n    /** 4. RETURN */\n    msg.payload = bulk_receipt;\n    msg.statusCode = 200;\n    const filledTime = (Date.now() - timeStart) / 1000;\n    node.warn(`Search: (${filledTime}s)`);\n    xano.flag_bulk = false;\n    node.status({fill:\"gray\",shape:\"ring\",text:\"OK\"});\n    return msg;\n} catch (error) {\n    xano.flag_bulk = false;\n    node.warn(error.stack);\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 440,
        "wires": [
            [
                "90e8a0f8e82bbe33"
            ]
        ]
    },
    {
        "id": "37730e93de030aea",
        "type": "http in",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "POST: Search receipts",
        "url": "/api:hrFfPpfK/receipt_list/_search/receipt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 240,
        "y": 440,
        "wires": [
            [
                "56d3a89ac68c4146"
            ]
        ]
    },
    {
        "id": "90e8a0f8e82bbe33",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "57283995a4e830fa",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 440,
        "wires": []
    },
    {
        "id": "bacb0542964eb8d8",
        "type": "function",
        "z": "46183d332de8b18f",
        "g": "0ebdf399fafbbae5",
        "name": "set_analyte_protocol",
        "func": "const table = global.get('tables');\nconst cache = global.get('cache');\n\n// API tạo hàng loạt receipt mới\ntry {\n    let orders = msg.req.body;                          // extract request order\n    let newOrdersInstances = [];                        // array of new order instances\n\n    if (!Array.isArray(orders)) orders = [orders];      // make sure request order is an array\n    orders.forEach(order => validateNewOrder(order));   // validate every orders, samples and analytes\n\n    // CREATING NEW ORDERS, SAMPLES AND ANALYTES\n    for (const order of orders) {\n        node.warn('Creating Order 1...');\n        const newOrderInstance = await createNewOrder(order);\n        newOrdersInstances.push(newOrderInstance);\n    }\n\n    // CONVERTING NEW ORDERS TO JSON XANO FORMAT\n    const newOrders = newOrdersInstances.map(instance => instance.jsonFullXano());\n\n    // return receipt\n    msg.payload = newOrders;\n    msg.statusCode = 200;\n    return msg;\n} catch (error) {\n    node.warn(error.stack);\n    msg.payload = error.message || error.response?.data?.message || 'Internal Server Error';\n    msg.statusCode = error.statusCode || error.response?.status || 500;\n    return msg;\n}\n\n// validate new order from http request body\nfunction validateNewOrder(order) {\n    const tableHelper = table.tableHelper\n    tableHelper.validateOrder(order, true);\n    \n    // validate samples and analytes\n    for (const sample of order.samples) {\n        tableHelper.validateSample(sample, true);           // validate sample\n        for (const analyte of sample.analytes) {\n            tableHelper.validateAnalyte(analyte, true);     // validate analyte\n        }\n    }\n}\n\nasync function createNewOrder(order) {\n    // CREATE A RECEIPT\n    const newReceipt = await table.receipt.create(order);\n\n    // CHECK IF RECEIPT IS CREATED\n    if (!newReceipt) {\n        const error = new Error('Unexpected error: Failed to create receipt');\n        error.statusCode = 500;\n        throw error;\n    }\n\n    // CREATE SAMPLES IN THE RECEIPT\n    if (Array.isArray(order.samples) && order.samples.length) {\n        for (const sample of order.samples) {\n            sample.sample_receipt_id = newReceipt.id;\n            const newSample = await table.sample.create(sample);\n\n            // CHECK IF SAMPLE IS CREATED\n            if (!newSample) {\n                const error = new Error('Unexpected error: Failed to create sample ' + sample.sample_name + ' for receipt ' + newReceipt.id);\n                error.statusCode = 500;\n                throw error;\n            }\n\n            // CREATE ANALYTES IN THE SAMPLE\n            if (Array.isArray(sample.analytes) && sample.analytes.length) {\n                for (const analyte of sample.analytes) {\n                    analyte.sample_receipt_id = newSample.id;\n                    analyte.sample_id = newSample.id;\n                    await table.sampleAnalyte.create(analyte);\n                }\n            }\n        }\n    }\n\n    // RETURN FULL RECEIPT WITH SAMPLES AND ANALYTES\n    return await newReceipt.jsonFullXano();\n}\n\n/// input format\n/*\n[\n  {\n    ...receipt,\n    samples: [{\n        ...sample,\n        analytes: [{\n            ...analyte,\n          }\n        ]\n      }\n    ]\n  }\n]\n  */",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 100,
        "wires": [
            [
                "69c05241cea6e0c4"
            ]
        ]
    },
    {
        "id": "409496890a4f5b21",
        "type": "http in",
        "z": "46183d332de8b18f",
        "g": "0ebdf399fafbbae5",
        "name": "",
        "url": "/test/create_batch_order",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 260,
        "y": 60,
        "wires": [
            [
                "d1051bd5a1a694ca"
            ]
        ]
    },
    {
        "id": "a9fde53619f580f5",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "0ebdf399fafbbae5",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 60,
        "wires": []
    },
    {
        "id": "69c05241cea6e0c4",
        "type": "http response",
        "z": "46183d332de8b18f",
        "g": "0ebdf399fafbbae5",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 770,
        "y": 100,
        "wires": []
    },
    {
        "id": "15d91a62f37a48fa",
        "type": "inject",
        "z": "10b4777ab9cd5025",
        "name": "Media",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "0.001",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 110,
        "y": 80,
        "wires": [
            [
                "ee2300aa8c3ac379",
                "cc58e16a8ef6e265"
            ]
        ]
    },
    {
        "id": "ee2300aa8c3ac379",
        "type": "function",
        "z": "10b4777ab9cd5025",
        "name": "Media Repo",
        "func": "// node-RED functions\nconst { Pool } = global.get('pg');\n\n// CONNECTING TO LAB DB\n(async () => {\n\ttry {\n        //replace\n\t\tconst pool = new Pool(JSON.parse(env.get('labDB')));\n\n\t\tif (await testConnection()) {\n                        node.warn('[ INFO ] FILEHUB DB pool already connected');\n                }\n                else {\n                        await pool.connect();\n                        node.warn('[ SUCCESS ] FILEHUB DB pool connected');\n                }\n                global.set('filehubRepoClient', pool);\n\t} catch (error) {\n\t\tnode.warn(`[ LAB REPO ERROR ] FILEHUB DB connection failed: ${error.stack}`);\n                node.warn(error.stack);\t\n\t}\n})();\n\nconst filehubRepoClient = global.get('filehubRepoClient');\n\n/**\nCREATE TABLE media (\n    media_uid VARCHAR(50) PRIMARY KEY DEFAULT 'media_' || substr(gen_random_uuid()::TEXT, 1, 10),\n    media_mime VARCHAR(50) NOT NULL, -- mime type\n    media_name VARCHAR(255) NOT NULL, -- file name or uid (with extension)\n    media_size INT NOT NULL, -- size in bytes\n    description_short TEXT, -- AI generated 2–3 sentences\n    media_hash TEXT, -- hash of the file\n    uris TEXT[] NOT NULL, -- ['https://...', 'https://...']\n    tags TEXT[], -- tags for classification\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by_uid VARCHAR(50) NOT NULL, -- identity uid\n    modified_by_uid VARCHAR(50) NOT NULL -- identity uid\n);\n*/\n\n// CRUD FUNCTIONS\nasync function createMedia(media, rethrow) {\n\t\ttry {\n\t\t\t\t// Lấy media schema\n\t\t\t\tconst validColumns = await matchValidColumns('media', Object.keys(media));\n\n\t\t\t\t// Lọc các trường input có trong media schema\n\t\t\t\tconst validMedia = Object.fromEntries(\n\t\t\t\t\t\tObject.entries(media).filter(([key]) => validColumns.includes(key))\n\t\t\t\t);\n\n\t\t\t\t// Dựng query và thực thi\n\t\t\t\tconst query = `\n\t\t\t\t\t\tINSERT INTO media (${validColumns.join(',')})\n\t\t\t\t\t\tVALUES (${validColumns.map((column, index) => `$${index + 1}`).join(',')})\n\t\t\t\t\t\tRETURNING *`;\n\t\t\t\tconst params = validColumns.map(column => validMedia[column]);\n\t\t\t\tconst result = await filehubRepoClient.query(query, params);\n\t\t\t\tnode.warn({result});\n\n\t\t\t\t// Trả về kết quả\n\t\t\t\tif (result?.rowCount === 0) return null;\n\t\t\t\telse return {\n\t\t\t\t\t\t...result.rows[0],\n\t\t\t\t\t\tclassName: 'Media'\n\t\t\t\t};\n\t\t} catch (error) {\n\t\t\t\thandleError(error, 'createMedia', rethrow);\n\t\t}\n}\n\nasync function getMedia(uid, rethrow) {\n\t\ttry {\n\t\t\t\tconst query = `SELECT * FROM media WHERE media_uid = $1`;\n\t\t\t\tconst params = [uid];\n\t\t\t\tconst result = await filehubRepoClient.query(query, params);\n\t\t\t\t\n\t\t\t\tnode.warn({result});\n\t\t\t\tif (result?.rows[0]) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t...result.rows[0],\n\t\t\t\t\t\t\t\tclassName: 'Media',\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\t\thandleError(error, 'getMedia', rethrow);\n\t\t}\n}\n\nasync function setMedia(media, rethrow) {\n\t\ttry {\n\t\t\t\tif (media?.media_uid) {\n\t\t\t\t\t\t// Lấy media schema\n\t\t\t\t\t\tconst validColumns = await matchValidColumns('media', Object.keys(media));\n\n\t\t\t\t\t\t// Lọc các trường input có trong media schema\n\t\t\t\t\t\tconst validMedia = Object.fromEntries(\n\t\t\t\t\t\t\t\tObject.entries(media).filter(([key]) => validColumns.includes(key))\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Dựng query và thực thi\n\t\t\t\t\t\tconst query = `\n\t\t\t\t\t\t\t\tUPDATE media\n\t\t\t\t\t\t\t\tSET ${validColumns.map((column, index) => `${column} = $${index + 2}`).join(',')}\n\t\t\t\t\t\t\t\tWHERE media_uid = $1\n\t\t\t\t\t\t\t\tRETURNING *`;\n\t\t\t\t\t\tconst params = [media.media_uid, ...validColumns.map(column => validMedia[column])];\n\t\t\t\t\t\tconst result = await filehubRepoClient.query(query, params);\n\t\t\t\t\t\tnode.warn({result});\n\n\t\t\t\t\t\t// Trả về kết quả\n\t\t\t\t\t\tif (result?.rowCount === 0) return null;\n\t\t\t\t\t\telse return {\n\t\t\t\t\t\t\t\t...result.rows[0],\n\t\t\t\t\t\t\t\tclassName: 'Media'\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthrow new Error(`Invalid media uid: ${media?.media_uid}`);\n\t\t} catch (error) {\n\t\t\t\thandleError(error, 'setMedia', rethrow);\n\t\t}\n}\n\n// HELPER FUNCTIONS\nasync function matchValidColumns(table_name, columns) {\n\ttry {\n\t\t/** 1. Get table columns from server */\n\t\t// Construct the SQL query to get the column names from the information schema\n\t\tconst validColumnsQuery = `SELECT column_name FROM information_schema.columns WHERE table_name = $1`;\n\t\tconst validColumnsParams = [table_name];\n\n\t\t// Execute the SQL query;\n\t\tconst validColumnsResult = await filehubRepoClient.query(validColumnsQuery, validColumnsParams);\n\n\t\t// Extract the column names from the query result\n\t\tconst validColumns = validColumnsResult.rows.map((row) => row.column_name);\n\n\t\t/** 2. Match columns */\n\t\t// Filter the input columns to include only valid columns\n\t\tconst matchedColumns = columns.filter((column) => validColumns.includes(column));\n\n\t\t// Return the matched columns\n\t\treturn matchedColumns || []; // if no match return []\n\t} catch (error) {\n\t\thandleError(error, 'matchValidColumns');\n                return [];\n\t}\n}\n\nasync function handleError(error, function_name, rethrow) {\n        node.warn(`[ LAB REPO ERROR ] ${function_name}: ${error.stack}`);\n        if (rethrow) throw error;\n        else return null;\n}\n\nasync function testConnection() {\n\ttry {\n\t\tconst client = await filehubRepoClient.connect(); // Lấy một client từ pool\n\t\tawait client.query('SELECT 1'); // Kiểm tra kết nối\n\t\tclient.release(); // Trả client về pool\n\t\treturn true; // Kết nối thành công\n\t} catch (error) {\n\t\treturn false; // Không kết nối được\n\t}\n}\n\nasync function disconnect() {\n\tconst client = global.get('filehubRepoClient');\n\tif (client) {\n\t\tawait client.end();\n\t\tglobal.set('filehubRepoClient', undefined);\n\t\tnode.warn('[ INFO ] FILEHUB DB pool disconnected');\n\t} else {\n\t\tnode.warn('[ WARNING ] FILEHUB DB pool not initialized, nothing to disconnect.');\n\t}\n}\n\n// export function\nglobal.set('fileHubRepo', {\n\t\tcreateMedia,\n\t\tgetMedia,\n\t\tsetMedia,\n\t\tdisconnect,\n\t\ttestConnection\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 80,
        "wires": [
            [
                "90c797fd623e1058"
            ]
        ]
    },
    {
        "id": "cc58e16a8ef6e265",
        "type": "function",
        "z": "10b4777ab9cd5025",
        "name": "ERROR",
        "func": "const ERROR = {\n    HTTP_400: (message = 'Bad Request') => {\n        const error = new Error(message);\n        error.statusCode = 400;\n        error.errorName = 'Bad Request';\n        return error;\n    },\n    HTTP_401: (message = 'Unauthorized') => {\n        const error = new Error(message);\n        error.statusCode = 401;\n        error.errorName = 'Unauthorized';\n        return error;\n    },\n    HTTP_403: (message = 'Forbidden') => {\n        const error = new Error(message);\n        error.statusCode = 403;\n        error.errorName = 'Forbidden';\n        return error;\n    },\n    HTTP_404: (message = 'Not Found') => {\n        const error = new Error(message);\n        error.statusCode = 404;\n        error.errorName = 'Not Found';\n        return error;\n    },\n    HTTP_500: (message = 'Internal Server Error') => {\n        const error = new Error(message);\n        error.statusCode = 500;\n        error.errorName = 'Internal Server Error';\n        return error;\n    },\n    HTTP_503: (message = 'Service Unavailable') => {\n        const error = new Error(message);\n        error.statusCode = 503;\n        error.errorName = 'Service Unavailable';\n        return error;\n    }\n}\n\nglobal.set('ERROR', ERROR);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "90c797fd623e1058",
        "type": "function",
        "z": "10b4777ab9cd5025",
        "name": "file Cache",
        "func": "const filehubCache = {};\nglobal.set('filehubCache', filehubCache);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "3a686b1b951a08f5",
        "type": "inject",
        "z": "10b4777ab9cd5025",
        "name": "test connection",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 200,
        "wires": [
            [
                "456922a14ac0dd64"
            ]
        ]
    },
    {
        "id": "456922a14ac0dd64",
        "type": "function",
        "z": "10b4777ab9cd5025",
        "name": "testConnection",
        "func": "async function testConnection() {\n    const filehubRepo = global.get('fileRepo');\n    node.warn({ filehubRepo });\n    const isConnected = await filehubRepo.testConnection();\n    if (isConnected) {\n        node.warn('[ TEST ] Connection to database successful!');\n    } else {\n        node.error('[ TEST ] Connection to database failed!');\n    }\n}\n\nawait testConnection();\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "23713cc1d54d87be",
        "type": "inject",
        "z": "10b4777ab9cd5025",
        "name": "test Get Media",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 280,
        "wires": [
            [
                "626c18e90689e1e5"
            ]
        ]
    },
    {
        "id": "626c18e90689e1e5",
        "type": "function",
        "z": "10b4777ab9cd5025",
        "name": "testGetMedia",
        "func": "async function testGetMedia() {\n    const filehubRepo = global.get('fileHubRepo');\n    const testUid = 'media_d0e24dbe-4'; // Thay bằng `media_uid` hợp lệ trong DB\n\n    const media = await filehubRepo.getMedia(testUid);\n    if (media) {\n        node.warn('[ TEST ] Media retrieved successfully:');\n        node.warn( media);\n    } else {\n        node.error('[ TEST ] Media not found!');\n    }\n}\n\n\nawait testGetMedia();\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "1cd407e0ce17e0f4",
        "type": "inject",
        "z": "10b4777ab9cd5025",
        "name": "test Create Media",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 240,
        "wires": [
            [
                "c3e0a4bcb26ae940"
            ]
        ]
    },
    {
        "id": "c3e0a4bcb26ae940",
        "type": "function",
        "z": "10b4777ab9cd5025",
        "name": "testCreate",
        "func": "async function testCreateMedia() {\n    const filehubRepo = global.get('fileHubRepo');\n\n    const newMedia = {\n        media_mime: 'image/png',\n        media_name: 'test_image.png',\n        media_size: 102400,\n        description_short: 'A test image file.',\n        media_hash: 'abcdef1234567890',\n        uris: ['https://example.com/file/test_image.png'],\n        tags: ['test', 'image'],\n        created_by_uid: 'test_user_1',\n        modified_by_uid: 'test_user_1'\n    };\n\n    const result = await filehubRepo.createMedia(newMedia);\n    if (result) {\n        node.warn('[ TEST ] Media created successfully:');\n        node.warn(result);\n    } else {\n        node.error('[ TEST ] Failed to create media!');\n    }\n}\n\n\nawait testCreateMedia();\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "da83853add779ccb",
        "type": "inject",
        "z": "10b4777ab9cd5025",
        "name": "test Set Media",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 110,
        "y": 320,
        "wires": [
            [
                "ce3eca672e52c6c9"
            ]
        ]
    },
    {
        "id": "ce3eca672e52c6c9",
        "type": "function",
        "z": "10b4777ab9cd5025",
        "name": "testSetMedia",
        "func": "async function testSetMedia() {\n    const filehubRepo = global.get('fileHubRepo');\n\n    const updatedMedia = {\n        media_uid: 'media_d0e24dbe-4', // Thay bằng `media_uid` hợp lệ trong DB\n        description_short: 'Updated description for the test media.',\n        tags: ['updated', 'test', 'media'],\n        modified_by_uid: 'test_user_2'\n    };\n\n    const result = await filehubRepo.setMedia(updatedMedia);\n    if (result) {\n        node.warn('[ TEST ] Media updated successfully:');\n        node.warn(result);\n    } else {\n        node.error('[ TEST ] Failed to update media!');\n    }\n}\n\nawait testSetMedia();\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "efe89d059b9717e5",
        "type": "inject",
        "z": "10b4777ab9cd5025",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 100,
        "y": 360,
        "wires": [
            [
                "3a1b886ea90edbdb"
            ]
        ]
    },
    {
        "id": "3a1b886ea90edbdb",
        "type": "function",
        "z": "10b4777ab9cd5025",
        "name": "function 10",
        "func": "const fs = global.get('fs').promises;\nconst local = 'file_storage//text.txt'; // Thay bằng đường dẫn bạn muốn kiểm tra\n\nawait fs.writeFile(local,[]);\n\n\n\n\n// function checkAndListFiles(folderPath) {\n//     // Kiểm tra xem đường dẫn có tồn tại hay không\n//     fs.access(folderPath, fs.constants.F_OK, (err) => {\n//         if (err) {\n//             node.error(`[ ERROR ] Folder does not exist: ${folderPath}`);\n//         } else {\n//             node.warn(`[ INFO ] Folder exists: ${folderPath}`);\n\n//             // Đọc danh sách file trong folder\n//             fs.readdir(folderPath, (err, files) => {\n//                 if (err) {\n//                     node.error(`[ ERROR ] Unable to read folder: ${err.message}`);\n//                 } else {\n//                     node.warn(`[ SUCCESS ] Files in folder '${folderPath}':`);\n//                     files.forEach((file) => {\n//                         node.warn(`- ${file}`);\n//                     });\n//                 }\n//             });\n//         }\n//     });\n// }\n\n// // Gọi hàm để kiểm tra\n// checkAndListFiles(path);",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "crypto",
                "module": "crypto"
            }
        ],
        "x": 330,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "0759cef1ad603e5c",
        "type": "inject",
        "z": "10b4777ab9cd5025",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 660,
        "y": 200,
        "wires": [
            [
                "4929f3f2b1efd473"
            ]
        ]
    },
    {
        "id": "4929f3f2b1efd473",
        "type": "function",
        "z": "10b4777ab9cd5025",
        "name": "create media",
        "func": "const { Protocol } = global.get('labTables');\n\nconst protocol = await Protocol.get(2);\n\nnode.warn({ protocol });\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 200,
        "wires": [
            []
        ]
    }
]